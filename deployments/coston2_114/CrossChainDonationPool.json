{"metadata":"{\"defaultCompiler\":{\"version\":\"0.8.25\"},\"sources\":{\"contracts/FlareHelp/CrossChainDonationPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {ContractRegistry} from \\\"@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol\\\";\\nimport {IEVMTransaction} from \\\"@flarenetwork/flare-periphery-contracts/coston2/IEVMTransaction.sol\\\";\\nimport {IFdcVerification} from \\\"@flarenetwork/flare-periphery-contracts/coston2/IFdcVerification.sol\\\";\\nimport \\\"./BadgeNft.sol\\\";\\n\\ncontract CrossChainDonationPool is Ownable, ReentrancyGuard {\\n    uint256 public nextRequestId;\\n    uint256 public totalPool; // total wei held in contract\\n    uint256 public totalXrplDonations; // total XRPL donations received\\n    uint256 public constant MIN_DONATION_AMOUNT = 1000000; // 1 XRP in drops (minimum XRPL payment)\\n    \\n    // XRPL payment tracking\\n    mapping(bytes32 => bool) public processedXrplTransactions;\\n    mapping(address => uint256) public donorXrplContributions;\\n    mapping(address => uint256) public donorFlareContributions;\\n    \\n    // XRPL addresses for receiving payments\\n    address public xrplReceiverAddress;\\n    string public xrplDestinationTag; // For identifying specific donations\\n    \\n    struct Request {\\n        string invoiceId;\\n        address creator;\\n        string hospitalXrpl;\\n        uint256 amountWei;\\n        bool funded;\\n        bool paidOut;\\n        uint256 fundedAt;\\n        address[] contributors; // Track who contributed to this specific request\\n    }\\n\\n    mapping(uint256 => Request) public requests;\\n    \\n    // Cross-chain donation tracking\\n    struct CrossChainDonation {\\n        address donor;\\n        uint256 amountWei;\\n        uint256 xrplAmount; // Amount in XRPL drops\\n        uint256 timestamp;\\n        string xrplTxHash;\\n        bool processed;\\n    }\\n    \\n    mapping(bytes32 => CrossChainDonation) public crossChainDonations;\\n    bytes32[] public donationHashes;\\n\\n    // Events\\n    event DonationMade(address indexed donor, uint256 amountWei, uint256 time);\\n    event XrplDonationReceived(address indexed donor, uint256 xrplAmount, string xrplTxHash, uint256 flareAmount);\\n    event RequestCreated(uint256 indexed requestId, string invoiceId, uint256 amountWei, string hospitalXrpl);\\n    event RequestFunded(uint256 indexed requestId, uint256 amountWei, string hospitalXrpl, address[] contributors);\\n    event RequestPaidOut(uint256 indexed requestId, uint256 amountWei, string hospitalXrpl);\\n    event BadgeAwarded(address indexed donor, uint256 badgeId, uint256 totalContributions);\\n\\n    BadgeNFT public badgeNft;\\n\\n    constructor(address initialOwner, address _badgeNft, address _xrplReceiver) Ownable(initialOwner) {\\n        badgeNft = BadgeNFT(_badgeNft);\\n        xrplReceiverAddress = _xrplReceiver;\\n        xrplDestinationTag = \\\"123456\\\"; // Example destination tag\\n    }\\n\\n    // Native Flare donations\\n    function donate() external payable {\\n        require(msg.value > 0, \\\"Must send value\\\");\\n        totalPool += msg.value;\\n        donorFlareContributions[msg.sender] += msg.value;\\n        emit DonationMade(msg.sender, msg.value, block.timestamp);\\n    }\\n\\n    // Process XRPL payments via FDC verification\\n    function processXrplPayment(\\n        IEVMTransaction.Proof calldata _transaction,\\n        string calldata xrplTxHash,\\n        uint256 xrplAmount\\n    ) external nonReentrant {\\n        bytes32 transactionHash = _transaction.data.requestBody.transactionHash;\\n        require(\\n            !processedXrplTransactions[transactionHash],\\n            \\\"Transaction already processed\\\"\\n        );\\n\\n        // Verify the XRPL transaction through FDC\\n        require(\\n            isXrplTransactionProofValid(_transaction),\\n            \\\"Invalid XRPL transaction proof\\\"\\n        );\\n\\n        // Mark transaction as processed\\n        processedXrplTransactions[transactionHash] = true;\\n\\n        // Calculate Flare equivalent (simplified - in production use price feeds)\\n        uint256 flareAmount = xrplAmount / 1000000; // 1 XRP = 1 wei (simplified)\\n        \\n        require(flareAmount >= 1 ether, \\\"Minimum donation not met\\\");\\n\\n        // Update tracking\\n        totalXrplDonations += xrplAmount;\\n        totalPool += flareAmount;\\n        donorXrplContributions[msg.sender] += xrplAmount;\\n\\n        // Store cross-chain donation\\n        bytes32 donationHash = keccak256(abi.encodePacked(xrplTxHash, msg.sender, block.timestamp));\\n        crossChainDonations[donationHash] = CrossChainDonation({\\n            donor: msg.sender,\\n            amountWei: flareAmount,\\n            xrplAmount: xrplAmount,\\n            timestamp: block.timestamp,\\n            xrplTxHash: xrplTxHash,\\n            processed: true\\n        });\\n        donationHashes.push(donationHash);\\n\\n        emit XrplDonationReceived(msg.sender, xrplAmount, xrplTxHash, flareAmount);\\n        \\n        // Award badge if significant contribution\\n        _awardBadgeIfEligible(msg.sender);\\n    }\\n\\n    // Create emergency request\\n    function createRequest(\\n        string calldata invoiceId, \\n        uint256 amountWei, \\n        string calldata hospitalXrpl\\n    ) external returns (uint256) {\\n        uint256 id = nextRequestId++;\\n        requests[id] = Request({\\n            invoiceId: invoiceId,\\n            creator: msg.sender,\\n            hospitalXrpl: hospitalXrpl,\\n            amountWei: amountWei,\\n            funded: false,\\n            paidOut: false,\\n            fundedAt: 0,\\n            contributors: new address[](0)\\n        });\\n        \\n        emit RequestCreated(id, invoiceId, amountWei, hospitalXrpl);\\n\\n        // Auto fund if pool has enough\\n        if (totalPool >= amountWei) {\\n            _fundRequest(id);\\n        }\\n        return id;\\n    }\\n\\n    // Fund request with contributor tracking\\n    function _fundRequest(uint256 requestId) internal {\\n        Request storage r = requests[requestId];\\n        require(!r.funded, \\\"Already funded\\\");\\n        require(totalPool >= r.amountWei, \\\"Insufficient pool\\\");\\n        \\n        r.funded = true;\\n        r.fundedAt = block.timestamp;\\n        totalPool -= r.amountWei;\\n        \\n        // Track contributors (simplified - in production, calculate proportional contributions)\\n        r.contributors.push(msg.sender);\\n        \\n        emit RequestFunded(requestId, r.amountWei, r.hospitalXrpl, r.contributors);\\n    }\\n\\n    // Manual funding by owner\\n    function fundRequest(uint256 requestId) external onlyOwner {\\n        _fundRequest(requestId);\\n    }\\n\\n    // Mark as paid out\\n    function markPaidOut(uint256 requestId) external onlyOwner {\\n        Request storage r = requests[requestId];\\n        require(r.funded, \\\"Not funded\\\");\\n        require(!r.paidOut, \\\"Already paid\\\");\\n        r.paidOut = true;\\n        emit RequestPaidOut(requestId, r.amountWei, r.hospitalXrpl);\\n    }\\n\\n    // Award badge based on contribution level\\n    function _awardBadgeIfEligible(address donor) internal {\\n        uint256 totalContributions = donorXrplContributions[donor] + donorFlareContributions[donor];\\n        \\n        // Award different badges based on contribution levels\\n        if (totalContributions >= 10 ether) {\\n            uint256 badgeId = badgeNft.mintBadge(donor);\\n            emit BadgeAwarded(donor, badgeId, totalContributions);\\n        }\\n    }\\n\\n    // Get donor's total impact\\n    function getDonorImpact(address donor) external view returns (\\n        uint256 xrplContributions,\\n        uint256 flareContributions,\\n        uint256 totalContributions,\\n        uint256 requestsHelped\\n    ) {\\n        xrplContributions = donorXrplContributions[donor];\\n        flareContributions = donorFlareContributions[donor];\\n        totalContributions = xrplContributions + flareContributions;\\n        \\n        // Count requests this donor contributed to (simplified)\\n        requestsHelped = 0;\\n        for (uint256 i = 0; i < nextRequestId; i++) {\\n            if (requests[i].funded) {\\n                for (uint256 j = 0; j < requests[i].contributors.length; j++) {\\n                    if (requests[i].contributors[j] == donor) {\\n                        requestsHelped++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // Get XRPL payment details for donors\\n    function getXrplPaymentDetails() external view returns (\\n        address receiver,\\n        string memory destinationTag,\\n        uint256 minAmount\\n    ) {\\n        return (xrplReceiverAddress, xrplDestinationTag, MIN_DONATION_AMOUNT);\\n    }\\n\\n    // Verify XRPL transaction through FDC\\n    function isXrplTransactionProofValid(\\n        IEVMTransaction.Proof calldata transaction\\n    ) public view returns (bool) {\\n        IFdcVerification fdc = ContractRegistry.getFdcVerification();\\n        return fdc.verifyEVMTransaction(transaction);\\n    }\\n\\n    // Fallback: accept direct transfers\\n    receive() external payable {\\n        totalPool += msg.value;\\n        donorFlareContributions[msg.sender] += msg.value;\\n        emit DonationMade(msg.sender, msg.value, block.timestamp);\\n        _awardBadgeIfEligible(msg.sender);\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.19\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"versionPragma\":\">=0.4.16\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\\n\\npragma solidity >=0.8.4;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted to signal this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\",\"versionPragma\":\">=0.8.4\"},\"@openzeppelin/contracts/access/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {IERC165, ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n\\n    /**\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\n     */\\n    function toUint(bool b) internal pure returns (uint256 u) {\\n        assembly (\\\"memory-safe\\\") {\\n            u := iszero(iszero(b))\\n        }\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/Panic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Helper library for emitting standardized panic codes.\\n *\\n * ```solidity\\n * contract Example {\\n *      using Panic for uint256;\\n *\\n *      // Use any of the declared internal constants\\n *      function foo() { Panic.GENERIC.panic(); }\\n *\\n *      // Alternatively\\n *      function foo() { Panic.panic(Panic.GENERIC); }\\n * }\\n * ```\\n *\\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\\n *\\n * _Available since v5.1._\\n */\\n// slither-disable-next-line unused-state\\nlibrary Panic {\\n    /// @dev generic / unspecified error\\n    uint256 internal constant GENERIC = 0x00;\\n    /// @dev used by the assert() builtin\\n    uint256 internal constant ASSERT = 0x01;\\n    /// @dev arithmetic underflow or overflow\\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\\n    /// @dev division or modulo by zero\\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\\n    /// @dev enum conversion error\\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\\n    /// @dev invalid encoding in storage\\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\\n    /// @dev empty array pop\\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\\n    /// @dev array out of bounds access\\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\\n    /// @dev resource error (too large allocation or too large array)\\n    uint256 internal constant RESOURCE_ERROR = 0x41;\\n    /// @dev calling invalid internal function\\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\\n\\n    /// @dev Reverts with a panic code. Recommended to use with\\n    /// the internal constants with predefined codes.\\n    function panic(uint256 code) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, 0x4e487b71)\\n            mstore(0x20, code)\\n            revert(0x1c, 0x24)\\n        }\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Panic} from \\\"../Panic.sol\\\";\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit addition of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\\n     */\\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        assembly (\\\"memory-safe\\\") {\\n            low := add(a, b)\\n            high := lt(low, a)\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit multiplication of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that product = high * 2 + low.\\n     */\\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = high * 2 + low.\\n        assembly (\\\"memory-safe\\\") {\\n            let mm := mulmod(a, b, not(0))\\n            low := mul(a, b)\\n            high := sub(sub(mm, low), lt(mm, low))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a + b;\\n            success = c >= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a - b;\\n            success = c <= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a * b;\\n            assembly (\\\"memory-safe\\\") {\\n                // Only true when the multiplication doesn't overflow\\n                // (c / a == b) || (a == 0)\\n                success := or(eq(div(c, a), b), iszero(a))\\n            }\\n            // equivalent to: success ? c : 0\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b > 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `DIV` opcode returns zero when the denominator is 0.\\n                result := div(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b > 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `MOD` opcode returns zero when the denominator is 0.\\n                result := mod(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\\n     */\\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryAdd(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\\n     */\\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (, uint256 result) = trySub(a, b);\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\\n     */\\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryMul(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\\n     *\\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\\n     * one branch when needed, making this function more expensive.\\n     */\\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            // branchless ternary works because:\\n            // b ^ (a ^ b) == a\\n            // b ^ 0 == b\\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a > b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a < b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n\\n        // The following calculation ensures accurate ceiling division without overflow.\\n        // Since a is non-zero, (a - 1) / b will not overflow.\\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\\n        // when a = type(uint256).max and b = 1.\\n        unchecked {\\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     *\\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (high == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return low / denominator;\\n            }\\n\\n            // Make sure the result is less than 2. Also prevents denominator == 0.\\n            if (denominator <= high) {\\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [high low].\\n            uint256 remainder;\\n            assembly (\\\"memory-safe\\\") {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                high := sub(high, gt(remainder, low))\\n                low := sub(low, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly (\\\"memory-safe\\\") {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [high low] by twos.\\n                low := div(low, twos)\\n\\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from high into low.\\n            low |= high * twos;\\n\\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv  1 mod 2.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\\n            // is no longer required.\\n            result = low * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n            if (high >= 1 << n) {\\n                Panic.panic(Panic.UNDER_OVERFLOW);\\n            }\\n            return (high << (256 - n)) | (low >> n);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\\n    }\\n\\n    /**\\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\\n     *\\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\\n     *\\n     * If the input value is not inversible, 0 is returned.\\n     *\\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\\n     */\\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\\n        unchecked {\\n            if (n == 0) return 0;\\n\\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\\n            // ax + ny = 1\\n            // ax = 1 + (-y)n\\n            // ax  1 (mod n) # x is the inverse of a modulo n\\n\\n            // If the remainder is 0 the gcd is n right away.\\n            uint256 remainder = a % n;\\n            uint256 gcd = n;\\n\\n            // Therefore the initial coefficients are:\\n            // ax + ny = gcd(a, n) = n\\n            // 0a + 1n = n\\n            int256 x = 0;\\n            int256 y = 1;\\n\\n            while (remainder != 0) {\\n                uint256 quotient = gcd / remainder;\\n\\n                (gcd, remainder) = (\\n                    // The old remainder is the next gcd to try.\\n                    remainder,\\n                    // Compute the next remainder.\\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\\n                    // where gcd is at most n (capped to type(uint256).max)\\n                    gcd - remainder * quotient\\n                );\\n\\n                (x, y) = (\\n                    // Increment the coefficient of a.\\n                    y,\\n                    // Decrement the coefficient of n.\\n                    // Can overflow, but the result is casted to uint256 so that the\\n                    // next value of y is \\\"wrapped around\\\" to a value between 0 and n - 1.\\n                    x - y * int256(quotient)\\n                );\\n            }\\n\\n            if (gcd != 1) return 0; // No inverse exists.\\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\\n     *\\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\\n     *\\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\\n     */\\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\\n        unchecked {\\n            return Math.modExp(a, p - 2, p);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\\n     *\\n     * Requirements:\\n     * - modulus can't be zero\\n     * - underlying staticcall to precompile must succeed\\n     *\\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\\n     * interpreted as 0.\\n     */\\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\\n        (bool success, uint256 result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\\n     * to operate modulo 0 or if the underlying precompile reverted.\\n     *\\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\\n     * of a revert, but the result may be incorrectly interpreted as 0.\\n     */\\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\\n        if (m == 0) return (false, 0);\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            // | Offset    | Content    | Content (Hex)                                                      |\\n            // |-----------|------------|--------------------------------------------------------------------|\\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\\n            mstore(ptr, 0x20)\\n            mstore(add(ptr, 0x20), 0x20)\\n            mstore(add(ptr, 0x40), 0x20)\\n            mstore(add(ptr, 0x60), b)\\n            mstore(add(ptr, 0x80), e)\\n            mstore(add(ptr, 0xa0), m)\\n\\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\\n            // so we can use the memory scratch space located at offset 0.\\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\\n     */\\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\\n        (bool success, bytes memory result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\\n     */\\n    function tryModExp(\\n        bytes memory b,\\n        bytes memory e,\\n        bytes memory m\\n    ) internal view returns (bool success, bytes memory result) {\\n        if (_zeroBytes(m)) return (false, new bytes(0));\\n\\n        uint256 mLen = m.length;\\n\\n        // Encode call args in result and move the free memory pointer\\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPtr := add(result, 0x20)\\n            // Write result on top of args to avoid allocating extra memory.\\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\\n            // Overwrite the length.\\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\\n            mstore(result, mLen)\\n            // Set the memory pointer after the returned data.\\n            mstore(0x40, add(dataPtr, mLen))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether the provided byte array is zero.\\n     */\\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\\n        for (uint256 i = 0; i < byteArray.length; ++i) {\\n            if (byteArray[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\\n     * using integer operations.\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        unchecked {\\n            // Take care of easy edge cases when a == 0 or a == 1\\n            if (a <= 1) {\\n                return a;\\n            }\\n\\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\\n            // the current value as `_n = | x_n - sqrt(a) |`.\\n            //\\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\\n            // bigger than any uint256.\\n            //\\n            // By noticing that\\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\\n            // to the msb function.\\n            uint256 aa = a;\\n            uint256 xn = 1;\\n\\n            if (aa >= (1 << 128)) {\\n                aa >>= 128;\\n                xn <<= 64;\\n            }\\n            if (aa >= (1 << 64)) {\\n                aa >>= 64;\\n                xn <<= 32;\\n            }\\n            if (aa >= (1 << 32)) {\\n                aa >>= 32;\\n                xn <<= 16;\\n            }\\n            if (aa >= (1 << 16)) {\\n                aa >>= 16;\\n                xn <<= 8;\\n            }\\n            if (aa >= (1 << 8)) {\\n                aa >>= 8;\\n                xn <<= 4;\\n            }\\n            if (aa >= (1 << 4)) {\\n                aa >>= 4;\\n                xn <<= 2;\\n            }\\n            if (aa >= (1 << 2)) {\\n                xn <<= 1;\\n            }\\n\\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\\n            //\\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\\n            // This is going to be our x_0 (and _0)\\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\\n\\n            // From here, Newton's method give us:\\n            // x_{n+1} = (x_n + a / x_n) / 2\\n            //\\n            // One should note that:\\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\\n            //              = ((x_n + a) / (2 * x_n)) - a\\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\\n            //              = (x_n - a) / (2 * x_n)\\n            //              = ((x_n - a) / (2 * x_n))\\n            //               0\\n            // Which proves that for all n  1, sqrt(a)  x_n\\n            //\\n            // This gives us the proof of quadratic convergence of the sequence:\\n            // _{n+1} = | x_{n+1} - sqrt(a) |\\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\\n            //         = | _n / (2 * x_n) |\\n            //         = _n / | (2 * x_n) |\\n            //\\n            // For the first iteration, we have a special case where x_0 is known:\\n            // _1 = _0 / | (2 * x_0) |\\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\\n            //      2**(2*e-4) / (3 * 2**(e-1))\\n            //      2**(e-3) / 3\\n            //      2**(e-3-log2(3))\\n            //      2**(e-4.5)\\n            //\\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\\n            // _{n+1} = _n / | (2 * x_n) |\\n            //          (2**(e-k)) / (2 * 2**(e-1))\\n            //          2**(2*e-2*k) / 2**e\\n            //          2**(e-2*k)\\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\\n\\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\\n            // sqrt(a) or sqrt(a) + 1.\\n            return xn - SafeCast.toUint(xn > a / xn);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\\n        // If upper 8 bits of 16-bit half set, add 8 to result\\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\\n        // If upper 4 bits of 8-bit half set, add 4 to result\\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\\n\\n        // Shifts value right by the current result and use it as an index into this lookup table:\\n        //\\n        // | x (4 bits) |  index  | table[index] = MSB position |\\n        // |------------|---------|-----------------------------|\\n        // |    0000    |    0    |        table[0] = 0         |\\n        // |    0001    |    1    |        table[1] = 0         |\\n        // |    0010    |    2    |        table[2] = 1         |\\n        // |    0011    |    3    |        table[3] = 1         |\\n        // |    0100    |    4    |        table[4] = 2         |\\n        // |    0101    |    5    |        table[5] = 2         |\\n        // |    0110    |    6    |        table[6] = 2         |\\n        // |    0111    |    7    |        table[7] = 2         |\\n        // |    1000    |    8    |        table[8] = 3         |\\n        // |    1001    |    9    |        table[9] = 3         |\\n        // |    1010    |   10    |        table[10] = 3        |\\n        // |    1011    |   11    |        table[11] = 3        |\\n        // |    1100    |   12    |        table[12] = 3        |\\n        // |    1101    |   13    |        table[13] = 3        |\\n        // |    1110    |   14    |        table[14] = 3        |\\n        // |    1111    |   15    |        table[15] = 3        |\\n        //\\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\\n        assembly (\\\"memory-safe\\\") {\\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\\n     *\\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\\n     * one branch when needed, making this function more expensive.\\n     */\\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\\n        unchecked {\\n            // branchless ternary works because:\\n            // b ^ (a ^ b) == a\\n            // b ^ 0 == b\\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return ternary(a > b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return ternary(a < b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // Formula from the \\\"Bit Twiddling Hacks\\\" by Sean Eron Anderson.\\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\\n            // taking advantage of the most significant (or \\\"sign\\\" bit) in two's complement representation.\\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\\n            int256 mask = n >> 255;\\n\\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\\n            return uint256((n + mask) ^ mask);\\n        }\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SafeCast} from \\\"./math/SafeCast.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    using SafeCast for *;\\n\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\\n        (1 << 0x08) | // backspace\\n            (1 << 0x09) | // tab\\n            (1 << 0x0a) | // newline\\n            (1 << 0x0c) | // form feed\\n            (1 << 0x0d) | // carriage return\\n            (1 << 0x22) | // double quote\\n            (1 << 0x5c); // backslash\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev The string being parsed contains characters that are not in scope of the given base.\\n     */\\n    error StringsInvalidChar();\\n\\n    /**\\n     * @dev The string being parsed is not a properly formatted address.\\n     */\\n    error StringsInvalidAddressFormat();\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            assembly (\\\"memory-safe\\\") {\\n                ptr := add(add(buffer, 0x20), length)\\n            }\\n            while (true) {\\n                ptr--;\\n                assembly (\\\"memory-safe\\\") {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\\n     * representation, according to EIP-55.\\n     */\\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\\n        bytes memory buffer = bytes(toHexString(addr));\\n\\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\\n        uint256 hashValue;\\n        assembly (\\\"memory-safe\\\") {\\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\\n        }\\n\\n        for (uint256 i = 41; i > 1; --i) {\\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\\n                // case shift by xoring with 0x20\\n                buffer[i] ^= 0x20;\\n            }\\n            hashValue >>= 4;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n\\n    /**\\n     * @dev Parse a decimal string and returns the value as a `uint256`.\\n     *\\n     * Requirements:\\n     * - The string must be formatted as `[0-9]*`\\n     * - The result must fit into an `uint256` type\\n     */\\n    function parseUint(string memory input) internal pure returns (uint256) {\\n        return parseUint(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\\n     * `end` (excluded).\\n     *\\n     * Requirements:\\n     * - The substring must be formatted as `[0-9]*`\\n     * - The result must fit into an `uint256` type\\n     */\\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\\n        if (!success) revert StringsInvalidChar();\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\\n     *\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\n     */\\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\\n     * character.\\n     *\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\n     */\\n    function tryParseUint(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) internal pure returns (bool success, uint256 value) {\\n        if (end > bytes(input).length || begin > end) return (false, 0);\\n        return _tryParseUintUncheckedBounds(input, begin, end);\\n    }\\n\\n    /**\\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\\n     */\\n    function _tryParseUintUncheckedBounds(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) private pure returns (bool success, uint256 value) {\\n        bytes memory buffer = bytes(input);\\n\\n        uint256 result = 0;\\n        for (uint256 i = begin; i < end; ++i) {\\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\\n            if (chr > 9) return (false, 0);\\n            result *= 10;\\n            result += chr;\\n        }\\n        return (true, result);\\n    }\\n\\n    /**\\n     * @dev Parse a decimal string and returns the value as a `int256`.\\n     *\\n     * Requirements:\\n     * - The string must be formatted as `[-+]?[0-9]*`\\n     * - The result must fit in an `int256` type.\\n     */\\n    function parseInt(string memory input) internal pure returns (int256) {\\n        return parseInt(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\\n     * `end` (excluded).\\n     *\\n     * Requirements:\\n     * - The substring must be formatted as `[-+]?[0-9]*`\\n     * - The result must fit in an `int256` type.\\n     */\\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\\n        (bool success, int256 value) = tryParseInt(input, begin, end);\\n        if (!success) revert StringsInvalidChar();\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\\n     * the result does not fit in a `int256`.\\n     *\\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\\n     */\\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\\n    }\\n\\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\\n\\n    /**\\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\\n     * character or if the result does not fit in a `int256`.\\n     *\\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\\n     */\\n    function tryParseInt(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) internal pure returns (bool success, int256 value) {\\n        if (end > bytes(input).length || begin > end) return (false, 0);\\n        return _tryParseIntUncheckedBounds(input, begin, end);\\n    }\\n\\n    /**\\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\\n     */\\n    function _tryParseIntUncheckedBounds(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) private pure returns (bool success, int256 value) {\\n        bytes memory buffer = bytes(input);\\n\\n        // Check presence of a negative sign.\\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\\n        bool positiveSign = sign == bytes1(\\\"+\\\");\\n        bool negativeSign = sign == bytes1(\\\"-\\\");\\n        uint256 offset = (positiveSign || negativeSign).toUint();\\n\\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\\n\\n        if (absSuccess && absValue < ABS_MIN_INT256) {\\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\\n            return (true, type(int256).min);\\n        } else return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Parse a hexadecimal string (with or without \\\"0x\\\" prefix), and returns the value as a `uint256`.\\n     *\\n     * Requirements:\\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\\n     * - The result must fit in an `uint256` type.\\n     */\\n    function parseHexUint(string memory input) internal pure returns (uint256) {\\n        return parseHexUint(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\\n     * `end` (excluded).\\n     *\\n     * Requirements:\\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\\n     * - The result must fit in an `uint256` type.\\n     */\\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\\n        if (!success) revert StringsInvalidChar();\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\\n     *\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\n     */\\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\\n     * invalid character.\\n     *\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\n     */\\n    function tryParseHexUint(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) internal pure returns (bool success, uint256 value) {\\n        if (end > bytes(input).length || begin > end) return (false, 0);\\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\\n    }\\n\\n    /**\\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\\n     */\\n    function _tryParseHexUintUncheckedBounds(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) private pure returns (bool success, uint256 value) {\\n        bytes memory buffer = bytes(input);\\n\\n        // skip 0x prefix if present\\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\\\"0x\\\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\\n        uint256 offset = hasPrefix.toUint() * 2;\\n\\n        uint256 result = 0;\\n        for (uint256 i = begin + offset; i < end; ++i) {\\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\\n            if (chr > 15) return (false, 0);\\n            result *= 16;\\n            unchecked {\\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\\n                result += chr;\\n            }\\n        }\\n        return (true, result);\\n    }\\n\\n    /**\\n     * @dev Parse a hexadecimal string (with or without \\\"0x\\\" prefix), and returns the value as an `address`.\\n     *\\n     * Requirements:\\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\\n     */\\n    function parseAddress(string memory input) internal pure returns (address) {\\n        return parseAddress(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\\n     * `end` (excluded).\\n     *\\n     * Requirements:\\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\\n     */\\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\\n        (bool success, address value) = tryParseAddress(input, begin, end);\\n        if (!success) revert StringsInvalidAddressFormat();\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\\n     * formatted address. See {parseAddress-string} requirements.\\n     */\\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\\n        return tryParseAddress(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\\n     */\\n    function tryParseAddress(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) internal pure returns (bool success, address value) {\\n        if (end > bytes(input).length || begin > end) return (false, address(0));\\n\\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\\\"0x\\\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\\n\\n        // check that input is the correct length\\n        if (end - begin == expectedLength) {\\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\\n            return (s, address(uint160(v)));\\n        } else {\\n            return (false, address(0));\\n        }\\n    }\\n\\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\\n        uint8 value = uint8(chr);\\n\\n        // Try to parse `chr`:\\n        // - Case 1: [0-9]\\n        // - Case 2: [a-f]\\n        // - Case 3: [A-F]\\n        // - otherwise not supported\\n        unchecked {\\n            if (value > 47 && value < 58) value -= 48;\\n            else if (value > 96 && value < 103) value -= 87;\\n            else if (value > 64 && value < 71) value -= 55;\\n            else return type(uint8).max;\\n        }\\n\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\\n     *\\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\\n     *\\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\\n     * characters that are not in this range, but other tooling may provide different results.\\n     */\\n    function escapeJSON(string memory input) internal pure returns (string memory) {\\n        bytes memory buffer = bytes(input);\\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\\n        uint256 outputLength = 0;\\n\\n        for (uint256 i; i < buffer.length; ++i) {\\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\\n                output[outputLength++] = \\\"\\\\\\\\\\\";\\n                if (char == 0x08) output[outputLength++] = \\\"b\\\";\\n                else if (char == 0x09) output[outputLength++] = \\\"t\\\";\\n                else if (char == 0x0a) output[outputLength++] = \\\"n\\\";\\n                else if (char == 0x0c) output[outputLength++] = \\\"f\\\";\\n                else if (char == 0x0d) output[outputLength++] = \\\"r\\\";\\n                else if (char == 0x5c) output[outputLength++] = \\\"\\\\\\\\\\\";\\n                else if (char == 0x22) {\\n                    // solhint-disable-next-line quotes\\n                    output[outputLength++] = '\\\"';\\n                }\\n            } else {\\n                output[outputLength++] = char;\\n            }\\n        }\\n        // write the actual length and deallocate unused memory\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(output, outputLength)\\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\\n        }\\n\\n        return string(output);\\n    }\\n\\n    /**\\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\\n     *\\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\\n     * assembly block as such would prevent some optimizations.\\n     */\\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\\n        assembly (\\\"memory-safe\\\") {\\n            value := mload(add(add(buffer, 0x20), offset))\\n        }\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\\npragma solidity >=0.8.4;\\n\\n/**\\n * @dev Standard ERC-20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC-721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC-1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\",\"versionPragma\":\">=0.8.4\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity >=0.6.2;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"versionPragma\":\">=0.6.2\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity >=0.6.2;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"versionPragma\":\">=0.6.2\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title ERC-721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC-721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"versionPragma\":\">=0.5.0\"},\"@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/utils/ERC721Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721Receiver} from \\\"../IERC721Receiver.sol\\\";\\nimport {IERC721Errors} from \\\"../../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Library that provide common ERC-721 utility functions.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-721[ERC-721].\\n *\\n * _Available since v5.1._\\n */\\nlibrary ERC721Utils {\\n    /**\\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC721Receiver-onERC721Received}\\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\\n     *\\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\\n     * Otherwise, the recipient must implement {IERC721Receiver-onERC721Received} and return the acceptance magic value to accept\\n     * the transfer.\\n     */\\n    function checkOnERC721Received(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length > 0) {\\n            try IERC721Receiver(to).onERC721Received(operator, from, tokenId, data) returns (bytes4 retval) {\\n                if (retval != IERC721Receiver.onERC721Received.selector) {\\n                    // Token rejected\\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    // non-IERC721Receiver implementer\\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\\n                } else {\\n                    assembly (\\\"memory-safe\\\") {\\n                        revert(add(reason, 0x20), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/token/ERC721/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"./IERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"./extensions/IERC721Metadata.sol\\\";\\nimport {ERC721Utils} from \\\"./utils/ERC721Utils.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {Strings} from \\\"../../utils/Strings.sol\\\";\\nimport {IERC165, ERC165} from \\\"../../utils/introspection/ERC165.sol\\\";\\nimport {IERC721Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    mapping(uint256 tokenId => address) private _owners;\\n\\n    mapping(address owner => uint256) private _balances;\\n\\n    mapping(uint256 tokenId => address) private _tokenApprovals;\\n\\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) {\\n            revert ERC721InvalidOwner(address(0));\\n        }\\n        return _balances[owner];\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        return _requireOwned(tokenId);\\n    }\\n\\n    /// @inheritdoc IERC721Metadata\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /// @inheritdoc IERC721Metadata\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\\n        _requireOwned(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function approve(address to, uint256 tokenId) public virtual {\\n        _approve(to, tokenId, _msgSender());\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\\n        _requireOwned(tokenId);\\n\\n        return _getApproved(tokenId);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        // Setting an \\\"auth\\\" arguments enables the `_isAuthorized` check which verifies that the token exists\\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\\n        address previousOwner = _update(to, tokenId, _msgSender());\\n        if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\\n        transferFrom(from, to, tokenId);\\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     *\\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\\n     */\\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\\n     * particular (ignoring whether it is owned by `owner`).\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            spender != address(0) &&\\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\\n     * Reverts if:\\n     * - `spender` does not have approval from `owner` for `tokenId`.\\n     * - `spender` does not have approval to manage all of `owner`'s assets.\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\\n        if (!_isAuthorized(owner, spender, tokenId)) {\\n            if (owner == address(0)) {\\n                revert ERC721NonexistentToken(tokenId);\\n            } else {\\n                revert ERC721InsufficientApproval(spender, tokenId);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\\n     *\\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\\n     * remain consistent with one another.\\n     */\\n    function _increaseBalance(address account, uint128 value) internal virtual {\\n        unchecked {\\n            _balances[account] += value;\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\\n     */\\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\\n        address from = _ownerOf(tokenId);\\n\\n        // Perform (optional) operator check\\n        if (auth != address(0)) {\\n            _checkAuthorized(from, auth, tokenId);\\n        }\\n\\n        // Execute the update\\n        if (from != address(0)) {\\n            // Clear approval. No need to re-authorize or emit the Approval event\\n            _approve(address(0), tokenId, address(0), false);\\n\\n            unchecked {\\n                _balances[from] -= 1;\\n            }\\n        }\\n\\n        if (to != address(0)) {\\n            unchecked {\\n                _balances[to] += 1;\\n            }\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        return from;\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner != address(0)) {\\n            revert ERC721InvalidSender(address(0));\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal {\\n        address previousOwner = _update(address(0), tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        } else if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - `to` cannot be the zero address.\\n     * - `from` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\\n        _safeTransfer(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth) internal {\\n        _approve(to, tokenId, auth, true);\\n    }\\n\\n    /**\\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\\n     * emitted in the context of transfers.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\\n        // Avoid reading the owner unless necessary\\n        if (emitEvent || auth != address(0)) {\\n            address owner = _requireOwned(tokenId);\\n\\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\\n                revert ERC721InvalidApprover(auth);\\n            }\\n\\n            if (emitEvent) {\\n                emit Approval(owner, to, tokenId);\\n            }\\n        }\\n\\n        _tokenApprovals[tokenId] = to;\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Requirements:\\n     * - operator can't be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        if (operator == address(0)) {\\n            revert ERC721InvalidOperator(operator);\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\\n     * Returns the owner.\\n     *\\n     * Overrides to ownership logic should be done to {_ownerOf}.\\n     */\\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        if (owner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n        return owner;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/FlareHelp/BadgeNft.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract BadgeNFT is ERC721, AccessControl {\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    uint256 private _tokenIds;\\n\\n    constructor(address initialOwner) ERC721(\\\"HelperBadge\\\", \\\"HBD\\\") {\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialOwner);\\n        _grantRole(MINTER_ROLE, initialOwner);\\n    }\\n\\n    function mintBadge(address to) external onlyRole(MINTER_ROLE) returns (uint256) {\\n        _tokenIds++;\\n        _mint(to, _tokenIds);\\n        return _tokenIds;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, AccessControl) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@flarenetwork/flare-periphery-contracts/coston2/RandomNumberV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Random number V2 long term support interface.\\n */\\ninterface RandomNumberV2Interface {\\n    /**\\n     * Returns the current random number, its timestamp and the flag indicating if it is secure.\\n     * @return _randomNumber The current random number.\\n     * @return _isSecureRandom The flag indicating if the random number is secure.\\n     * @return _randomTimestamp The timestamp of the random number.\\n     */\\n    function getRandomNumber()\\n        external\\n        view\\n        returns (\\n            uint256 _randomNumber,\\n            bool _isSecureRandom,\\n            uint256 _randomTimestamp\\n        );\\n\\n    /**\\n     * Returns the historical random number for a given _votingRoundId,\\n     * its timestamp and the flag indicating if it is secure.\\n     * If no finalization in the _votingRoundId, the function reverts.\\n     * @param _votingRoundId The voting round id.\\n     * @return _randomNumber The current random number.\\n     * @return _isSecureRandom The flag indicating if the random number is secure.\\n     * @return _randomTimestamp The timestamp of the random number.\\n     */\\n    function getRandomNumberHistorical(\\n        uint256 _votingRoundId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 _randomNumber,\\n            bool _isSecureRandom,\\n            uint256 _randomTimestamp\\n        );\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRelay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./RandomNumberV2Interface.sol\\\";\\n\\n/**\\n * Relay interface.\\n */\\ninterface IRelay is RandomNumberV2Interface {\\n    struct FeeConfig {\\n        uint8 protocolId; // Protocol id for which the fee is set\\n        uint256 feeInWei; // Fee in wei\\n    }\\n\\n    struct RelayInitialConfig {\\n        uint32 initialRewardEpochId; // The initial reward epoch id.\\n        uint32 startingVotingRoundIdForInitialRewardEpochId; // The starting voting round id for the initial\\n        // reward epoch.\\n        bytes32 initialSigningPolicyHash; // The initial signing policy hash.\\n        uint8 randomNumberProtocolId; // The protocol id of the random number protocol.\\n        uint32 firstVotingRoundStartTs; // The timestamp of the first voting round start.\\n        uint8 votingEpochDurationSeconds; // The duration of a voting epoch in seconds.\\n        uint32 firstRewardEpochStartVotingRoundId; // The start voting round id of the first reward epoch.\\n        uint16 rewardEpochDurationInVotingEpochs; // The duration of a reward epoch in voting epochs.\\n        uint16 thresholdIncreaseBIPS; // The threshold increase in BIPS for signing with\\n        // old signing policy.\\n        uint32 messageFinalizationWindowInRewardEpochs; // The window of reward epochs for finalizing\\n        // the protocol messages.\\n        address payable feeCollectionAddress; // Fee collection address\\n        FeeConfig[] feeConfigs; // Fee configurations\\n    }\\n\\n    struct RelayGovernanceConfig {\\n        bytes32 descriptionHash; // Description hash (should be keccak256(\\\"RelayGovernance\\\")\\n        uint256 chainId; // Chain id on which is the relay is deployed\\n        FeeConfig[] newFeeConfigs; // Fee configurations\\n    }\\n\\n    // Event is emitted when a new signing policy is initialized by the signing policy setter.\\n    event SigningPolicyInitialized(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint32 startVotingRoundId, // First voting round id of validity.\\n        // Usually it is the first voting round of reward epoch rewardEpochId.\\n        // It can be later,\\n        // if the confirmation of the signing policy on Flare blockchain gets delayed.\\n        uint16 threshold, // Confirmation threshold (absolute value of noramalised weights).\\n        uint256 seed, // Random seed.\\n        address[] voters, // The list of eligible voters in the canonical order.\\n        uint16[] weights, // The corresponding list of normalised signing weights of eligible voters.\\n        // Normalisation is done by compressing the weights from 32-byte values to\\n        // 2 bytes, while approximately keeping the weight relations.\\n        bytes signingPolicyBytes, // The full signing policy byte encoded.\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    // Event is emitted when a signing policy is relayed.\\n    // It contains minimalistic data in order to save gas. Data about the signing policy are\\n    // extractable from the calldata, assuming prefered usage of direct top-level call to relay().\\n    event SigningPolicyRelayed(\\n        uint256 indexed rewardEpochId // Reward epoch id\\n    );\\n\\n    // Event is emitted when a protocol message is relayed.\\n    event ProtocolMessageRelayed(\\n        uint8 indexed protocolId, // Protocol id\\n        uint32 indexed votingRoundId, // Voting round id\\n        bool isSecureRandom, // Secure random flag\\n        bytes32 merkleRoot // Merkle root of the protocol message\\n    );\\n\\n    /**\\n     * Checks the relay message for sufficient weight of signatures for the _messageHash\\n     * signed for protocol message Merkle root of the form (1, 0, 0, _messageHash).\\n     * If the check is successful, reward epoch id of the signing policy is returned.\\n     * Otherwise the function reverts.\\n     * @param _relayMessage The relay message.\\n     * @param _messageHash The hash of the message.\\n     * @return _rewardEpochId The reward epoch id of the signing policy.\\n     */\\n    function verifyCustomSignature(\\n        bytes calldata _relayMessage,\\n        bytes32 _messageHash\\n    ) external returns (uint256 _rewardEpochId);\\n\\n    /**\\n     * Checks the relay message for sufficient weight of signatures of the hash of the _config data.\\n     * If the check is successful, the relay contract is configured with the new _config data, which\\n     * in particular means that fee configurations are updated.\\n     * Otherwise the function reverts.\\n     * @param _relayMessage The relay message.\\n     * @param _config The new relay configuration.\\n     */\\n    function governanceFeeSetup(\\n        bytes calldata _relayMessage,\\n        RelayGovernanceConfig calldata _config\\n    ) external;\\n\\n    /**\\n     * Finalization function for new signing policies and protocol messages.\\n     * It can be used as finalization contract on Flare chain or as relay contract on other EVM chain.\\n     * Can be called in two modes. It expects calldata that is parsed in a custom manner.\\n     * Hence the transaction calls should assemble relevant calldata in the 'data' field.\\n     * Depending on the data provided, the contract operations in essentially two modes:\\n     * (1) Relaying signing policy. The structure of the calldata is:\\n     *        function signature (4 bytes) + active signing policy\\n     *             + 0 (1 byte) + new signing policy,\\n     *     total of exactly 4423 bytes.\\n     * (2) Relaying signed message. The structure of the calldata is:\\n     *        function signature (4 bytes) + signing policy\\n     *           + signed message (38 bytes) + ECDSA signatures with indices (67 bytes each)\\n     *     This case splits into two subcases:\\n     *     - protocolMessageId = 1: Message id must be of the form (protocolMessageId, 0, 0, merkleRoot).\\n     *       The validity of the signatures of sufficient weight is checked and if\\n     *       successful, the merkleRoot from the message is returned (32 bytes) and the\\n     *       reward epoch id of the signing policy as well (additional 3 bytes)\\n     *     - protocolMessageId > 1: The validity of the signatures of sufficient weight is checked and if\\n     *       it is valid, the merkleRoot is published for protocolId and votingRoundId.\\n     * Reverts if relaying is not successful.\\n     */\\n    function relay() external returns (bytes memory);\\n\\n    /**\\n     * Verifies the leaf (or intermediate node) with the Merkle proof against the Merkle root\\n     * for given protocol id and voting round id.\\n     * A fee may need to be paid. It is protocol specific.\\n     * **NOTE:** Overpayment is not refunded.\\n     * @param _protocolId The protocol id.\\n     * @param _votingRoundId The voting round id.\\n     * @param _leaf The leaf (or intermediate node) to verify.\\n     * @param _proof The Merkle proof.\\n     * @return True if the verification is successful.\\n     */\\n    function verify(\\n        uint256 _protocolId,\\n        uint256 _votingRoundId,\\n        bytes32 _leaf,\\n        bytes32[] calldata _proof\\n    ) external payable returns (bool);\\n\\n    /**\\n     * Returns the signing policy hash for given reward epoch id.\\n     * The function is reverted if signingPolicySetter is set, hence on all\\n     * deployments where the contract is used as a pure relay.\\n     * @param _rewardEpochId The reward epoch id.\\n     * @return _signingPolicyHash The signing policy hash.\\n     */\\n    function toSigningPolicyHash(\\n        uint256 _rewardEpochId\\n    ) external view returns (bytes32 _signingPolicyHash);\\n\\n    /**\\n     * Returns true if there is finalization for a given protocol id and voting round id.\\n     * @param _protocolId The protocol id.\\n     * @param _votingRoundId The voting round id.\\n     */\\n    function isFinalized(\\n        uint256 _protocolId,\\n        uint256 _votingRoundId\\n    ) external view returns (bool);\\n\\n    /**\\n     * Returns the Merkle root for given protocol id and voting round id.\\n     * The function is reverted if signingPolicySetter is set, hence on all\\n     * deployments where the contract is used as a pure relay.\\n     * @param _protocolId The protocol id.\\n     * @param _votingRoundId The voting round id.\\n     * @return _merkleRoot The Merkle root.\\n     */\\n    function merkleRoots(\\n        uint256 _protocolId,\\n        uint256 _votingRoundId\\n    ) external view returns (bytes32 _merkleRoot);\\n\\n    /**\\n     * Returns the start voting round id for given reward epoch id.\\n     * @param _rewardEpochId The reward epoch id.\\n     * @return _startingVotingRoundId The start voting round id.\\n     */\\n    function startingVotingRoundIds(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256 _startingVotingRoundId);\\n\\n    /**\\n     * Returns the voting round id for given timestamp.\\n     * @param _timestamp The timestamp.\\n     * @return _votingRoundId The voting round id.\\n     */\\n    function getVotingRoundId(\\n        uint256 _timestamp\\n    ) external view returns (uint256 _votingRoundId);\\n\\n    /**\\n     * Returns last initialized reward epoch data.\\n     * @return _lastInitializedRewardEpoch Last initialized reward epoch.\\n     * @return _startingVotingRoundIdForLastInitializedRewardEpoch Starting voting round id for it.\\n     */\\n    function lastInitializedRewardEpochData()\\n        external\\n        view\\n        returns (\\n            uint32 _lastInitializedRewardEpoch,\\n            uint32 _startingVotingRoundIdForLastInitializedRewardEpoch\\n        );\\n\\n    /**\\n     * Returns fee collection address.\\n     */\\n    function feeCollectionAddress() external view returns (address payable);\\n\\n    /**\\n     * Returns fee in wei for one verification of a given protocol id.\\n     * @param _protocolId The protocol id.\\n     */\\n    function protocolFeeInWei(\\n        uint256 _protocolId\\n    ) external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IBalanceDecreasingTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IBalanceDecreasingTransaction\\n * @custom:id 0x02\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice A detection of a transaction that either decreases the balance for some address or is\\n * signed by the source address.\\n * Such an attestation could prove a violation of an agreement and therefore provides grounds to liquidate\\n * some funds locked by a smart contract on Flare.\\n *\\n * A transaction is considered balance decreasing for the address, if the balance after the\\n * transaction is lower than before or the address is among the signers of the transaction\\n * (even if its balance is greater than before the transaction).\\n * @custom:verification The transaction with `transactionId` is fetched from the API of the\\n * source blockchain node or relevant indexer.\\n * If the transaction cannot be fetched or the transaction is in a block that does not have a\\n * sufficient number of confirmations, the attestation request is rejected.\\n *\\n * Once the transaction is received, the response fields are extracted if the transaction is balance\\n * decreasing for the indicated address.\\n * Some of the request and response fields are chain specific as described below.\\n * The fields can be computed with the help of a balance decreasing summary.\\n *\\n * ### UTXO (Bitcoin and Dogecoin)\\n *\\n * - `sourceAddressIndicator` is the the index of the transaction input in hex padded to a 0x prefixed 32-byte string.\\n * If the indicated input does not exist or the indicated input does not have the address,\\n * the attestation request is rejected.\\n * The `sourceAddress` is the address of the indicated transaction input.\\n * - `spentAmount` is the sum of values of all inputs with sourceAddress minus the sum of\\n * all outputs with `sourceAddress`.\\n * Can be negative.\\n * - `blockTimestamp` is the mediantime of a block.\\n *\\n * ### XRPL\\n *\\n * - `sourceAddressIndicator` is the standard address hash of the address whose balance has been decreased.\\n * If the address indicated by `sourceAddressIndicator` is not among the signers of the transaction and the balance\\n * of the address was not lowered in the transaction, the attestation request is rejected.\\n *\\n * - `spentAmount` is the difference between the balance of the indicated address after and before the transaction.\\n * Can be negative.\\n * - `blockTimestamp` is the close_time of a ledger converted to unix time.\\n *\\n * @custom:lut `blockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IBalanceDecreasingTransaction {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * This is a security measure to prevent a collision of attestation hashes.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the\\n     * response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for IBalanceDecreasingTransaction attestation type\\n     * @param transactionId ID of the payment transaction.\\n     * @param sourceAddressIndicator The indicator of the address whose balance has been decreased.\\n     */\\n    struct RequestBody {\\n        bytes32 transactionId;\\n        bytes32 sourceAddressIndicator;\\n    }\\n\\n    /**\\n     * @notice Response body for IBalanceDecreasingTransaction attestation type.\\n     * @param blockNumber The number of the block in which the transaction is included.\\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\\n     * @param sourceAddressHash Standard address hash of the address indicated by the `sourceAddressIndicator`.\\n     * @param spentAmount Amount spent by the source address in minimal units.\\n     * @param standardPaymentReference Standard payment reference of the transaction.\\n     */\\n    struct ResponseBody {\\n        uint64 blockNumber;\\n        uint64 blockTimestamp;\\n        bytes32 sourceAddressHash;\\n        int256 spentAmount;\\n        bytes32 standardPaymentReference;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IBalanceDecreasingTransactionVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IBalanceDecreasingTransaction.sol\\\";\\n\\ninterface IBalanceDecreasingTransactionVerification {\\n    function verifyBalanceDecreasingTransaction(\\n        IBalanceDecreasingTransaction.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IConfirmedBlockHeightExists.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IConfirmedBlockHeightExists\\n * @custom:id 0x02\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice An assertion that a block with `blockNumber` is confirmed.\\n * It also provides data to compute the block production rate in the given time range.\\n * @custom:verification It is checked that the block with `blockNumber` is confirmed by at\\n * least `numberOfConfirmations`.\\n * If it is not, the request is rejected. We note a block on the tip of the chain is confirmed by 1 block.\\n * Then `lowestQueryWindowBlock` is determined and its number and timestamp are extracted.\\n *\\n *\\n * Current confirmation heights consensus:\\n *\\n *\\n * | `Chain` | `chainId` | `numberOfConfirmations` | `timestamp ` |\\n * | ------- | --------- | ----------------------- | ------------ |\\n * | `BTC`   | 0         | 6                       | mediantime   |\\n * | `DOGE`  | 2         | 60                      | mediantime   |\\n * | `XRP`   | 3         | 3                       | close_time   |\\n *\\n *\\n * @custom:lut `lowestQueryWindowBlockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IConfirmedBlockHeightExists {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the\\n     * response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for ConfirmedBlockHeightExistsType attestation type\\n     * @param blockNumber The number of the block the request wants a confirmation of.\\n     * @param queryWindow The length of the period in which the block production rate is to be computed.\\n     */\\n    struct RequestBody {\\n        uint64 blockNumber;\\n        uint64 queryWindow;\\n    }\\n\\n    /**\\n     * @notice Response body for ConfirmedBlockHeightExistsType attestation type\\n     * @custom:below `blockNumber`, `lowestQueryWindowBlockNumber`, `blockTimestamp`, `lowestQueryWindowBlockTimestamp`\\n     * can be used to compute the average block production time in the specified block range.\\n     * @param blockTimestamp The timestamp of the block with `blockNumber`.\\n     * @param numberOfConfirmations The depth at which a block is considered confirmed depending on the chain.\\n     * All attestation providers must agree on this number.\\n     * @param lowestQueryWindowBlockNumber The block number of the latest block that has a timestamp strictly smaller\\n     * than `blockTimestamp` - `queryWindow`.\\n     * @param lowestQueryWindowBlockTimestamp The timestamp of the block at height `lowestQueryWindowBlockNumber`.\\n     */\\n    struct ResponseBody {\\n        uint64 blockTimestamp;\\n        uint64 numberOfConfirmations;\\n        uint64 lowestQueryWindowBlockNumber;\\n        uint64 lowestQueryWindowBlockTimestamp;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IConfirmedBlockHeightExistsVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IConfirmedBlockHeightExists.sol\\\";\\n\\ninterface IConfirmedBlockHeightExistsVerification {\\n    function verifyConfirmedBlockHeightExists(\\n        IConfirmedBlockHeightExists.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPayment.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IPayment\\n * @custom:id 0x01\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice A relay of a transaction on an external chain that is considered a payment in a native currency.\\n * Various blockchains support different types of native payments. For each blockchain, it is specified how a payment\\n * transaction should be formed to be provable by this attestation type.\\n * The provable payments emulate traditional banking payments from entity A to entity B in native currency with an\\n * optional payment reference.\\n * @custom:verification The transaction with `transactionId` is fetched from the API of the blockchain node or\\n * relevant indexer.\\n * If the transaction cannot be fetched or the transaction is in a block that does not have a sufficient\\n * [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.\\n *\\n * Once the transaction is received, the payment summary is computed according to the rules for the source chain.\\n * If the summary is successfully calculated, the response is assembled from the summary.\\n * `blockNumber` and `blockTimestamp` are retrieved from the block if they are not included in the transaction data.\\n * For Bitcoin and Dogecoin, `blockTimestamp` is mediantime of the block.\\n * For XRPL, `blockTimestamp` is close time of the ledger converted to UNIX time.\\n *\\n * If the summary is not successfully calculated, the attestation request is rejected.\\n * @custom:lut `blockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IPayment {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\\n     * by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for Payment attestation type\\n     * @param transactionId ID of the payment transaction.\\n     * @param inUtxo For UTXO chains, this is the index of the transaction input with source address.\\n     * Always 0 for the non-utxo chains.\\n     * @param utxo For UTXO chains, this is the index of the transaction output with receiving address.\\n     * Always 0 for the non-utxo chains.\\n     */\\n    struct RequestBody {\\n        bytes32 transactionId;\\n        uint256 inUtxo;\\n        uint256 utxo;\\n    }\\n\\n    /**\\n     * @notice Response body for Payment attestation type\\n     * @param blockNumber Number of the block in which the transaction is included.\\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\\n     * @param sourceAddressHash Standard address hash of the source address.\\n     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.\\n     * @param receivingAddressHash Standard address hash of the receiving address.\\n     * The zero 32-byte string if there is no receivingAddress (if `status` is not success).\\n     * @param intendedReceivingAddressHash Standard address hash of the intended receiving address.\\n     * Relevant if the transaction is unsuccessful.\\n     * @param spentAmount Amount in minimal units spent by the source address.\\n     * @param intendedSpentAmount Amount in minimal units to be spent by the source address.\\n     * Relevant if the transaction status is unsuccessful.\\n     * @param receivedAmount Amount in minimal units received by the receiving address.\\n     * @param intendedReceivedAmount Amount in minimal units intended to be received by the receiving address.\\n     * Relevant if the transaction is unsuccessful.\\n     * @param standardPaymentReference Standard payment reference of the transaction.\\n     * @param oneToOne Indicator whether only one source and one receiver are involved in the transaction.\\n     * @param status Succes status of the transaction: 0 - success, 1 - failed by sender's fault,\\n     * 2 - failed by receiver's fault.\\n     */\\n    struct ResponseBody {\\n        uint64 blockNumber;\\n        uint64 blockTimestamp;\\n        bytes32 sourceAddressHash;\\n        bytes32 sourceAddressesRoot;\\n        bytes32 receivingAddressHash;\\n        bytes32 intendedReceivingAddressHash;\\n        int256 spentAmount;\\n        int256 intendedSpentAmount;\\n        int256 receivedAmount;\\n        int256 intendedReceivedAmount;\\n        bytes32 standardPaymentReference;\\n        bool oneToOne;\\n        uint8 status;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPaymentVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IPayment.sol\\\";\\n\\ninterface IPaymentVerification {\\n    function verifyPayment(\\n        IPayment.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAddressValidity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IAddressValidity\\n * @custom:id 0x05\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice An assertion whether a string represents a valid address on an external chain.\\n * @custom:verification The address is checked against all validity criteria of the chain with `sourceId`.\\n * Indicator of validity is provided.\\n * If the address is valid, its standard form and standard hash are computed.\\n * Validity criteria for each supported chain:\\n * - [BTC](/specs/attestations/external-chains/address-validity/BTC.md)\\n * - [DOGE](/specs/attestations/external-chains/address-validity/DOGE.md)\\n * - [XRPL](/specs/attestations/external-chains/address-validity/XRPL.md)\\n * @custom:lut `0xffffffffffffffff` ($2^{64}-1$ in hex)\\n * @custom:lutlimit `0xffffffffffffffff`, `0xffffffffffffffff`, `0xffffffffffffffff`\\n */\\ninterface IAddressValidity {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId Id of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the\\n     * response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for IAddressValidity attestation type\\n     * @param addressStr Address to be verified.\\n     */\\n    struct RequestBody {\\n        string addressStr;\\n    }\\n\\n    /**\\n     * @notice Response body for IAddressValidity attestation type\\n     * @param isValid Boolean indicator of the address validity.\\n     * @param standardAddress If `isValid`, standard form of the validated address. Otherwise an empty string.\\n     * @param standardAddressHash If `isValid`, standard address hash of the validated address.\\n     * Otherwise a zero bytes32 string.\\n     */\\n    struct ResponseBody {\\n        bool isValid;\\n        string standardAddress;\\n        bytes32 standardAddressHash;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAddressValidityVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IAddressValidity.sol\\\";\\n\\ninterface IAddressValidityVerification {\\n    function verifyAddressValidity(\\n        IAddressValidity.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IEVMTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IEVMTransaction\\n * @custom:id 0x06\\n * @custom:supported ETH, FLR, SGB\\n * @author Flare\\n * @notice A relay of a transaction from an EVM chain.\\n * This type is only relevant for EVM-compatible chains.\\n * @custom:verification If a transaction with the `transactionId` is in a block on the main branch with\\n * at least `requiredConfirmations`, the specified data is relayed.\\n * If an indicated event does not exist, the request is rejected.\\n * @custom:lut `timestamp`\\n * @custom:lutlimit `0x41eb00`, `0x41eb00`, `0x41eb00`\\n */\\ninterface IEVMTransaction {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is\\n     * determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for EVM transaction attestation type\\n     * @custom:below Note that events (logs) are indexed in block not in each transaction.\\n     * The contract that uses the attestation should specify the order of event logs as needed and the requestor should\\n     * sort `logIndices` with respect to the set specifications.\\n     * If possible, the contact should require one `logIndex`.\\n     * @param transactionHash Hash of the transaction(transactionHash).\\n     * @param requiredConfirmations The height at which a block is considered confirmed by the requestor.\\n     * @param provideInput If true, \\\"input\\\" field is included in the response.\\n     * @param listEvents If true, events indicated by `logIndices` are included in the response.\\n     * Otherwise, no events are included in the response.\\n     * @param logIndices If `listEvents` is `false`, this should be an empty list, otherwise,\\n     * the request is rejected. If `listEvents` is `true`, this is the list of indices (logIndex)\\n     * of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices.\\n     * If empty, it indicates all events in order capped by 50.\\n     */\\n    struct RequestBody {\\n        bytes32 transactionHash;\\n        uint16 requiredConfirmations;\\n        bool provideInput;\\n        bool listEvents;\\n        uint32[] logIndices;\\n    }\\n\\n    /**\\n     * @notice Response body for EVM transaction attestation type\\n     * @custom:below The fields are in line with transaction provided by EVM node.\\n     * @param blockNumber Number of the block in which the transaction is included.\\n     * @param timestamp Timestamp of the block in which the transaction is included.\\n     * @param sourceAddress The address (from) that signed the transaction.\\n     * @param isDeployment Indicate whether it is a contract creation transaction.\\n     * @param receivingAddress The address (to) of the receiver of the initial transaction.\\n     * Zero address if `isDeployment` is `true`.\\n     * @param value The value transferred by the initial transaction in wei.\\n     * @param input If `provideInput`, this is the data send along with the initial transaction.\\n     * Otherwise it is the default value `0x00`.\\n     * @param status Status of the transaction 1 - success, 0 - failure.\\n     * @param events If `listEvents` is `true`, an array of the requested events.\\n     * Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.\\n     */\\n    struct ResponseBody {\\n        uint64 blockNumber;\\n        uint64 timestamp;\\n        address sourceAddress;\\n        bool isDeployment;\\n        address receivingAddress;\\n        uint256 value;\\n        bytes input;\\n        uint8 status;\\n        Event[] events;\\n    }\\n\\n    /**\\n     * @notice Event log record\\n     * @custom:above An `Event` is a struct with the following fields:\\n     * @custom:below The fields are in line with EVM event logs.\\n     * @param logIndex The consecutive number of the event in block.\\n     * @param emitterAddress The address of the contract that emitted the event.\\n     * @param topics An array of up to four 32-byte strings of indexed log arguments.\\n     * @param data Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.\\n     * @param removed It is `true` if the log was removed due to a chain reorganization\\n     * and `false` if it is a valid log.\\n     */\\n    struct Event {\\n        uint32 logIndex;\\n        address emitterAddress;\\n        bytes32[] topics;\\n        bytes data;\\n        bool removed;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IEVMTransactionVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IEVMTransaction.sol\\\";\\n\\ninterface IEVMTransactionVerification {\\n    function verifyEVMTransaction(\\n        IEVMTransaction.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWeb2Json.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IWeb2Json\\n * @custom:supported WEB2\\n * @author Flare\\n * @notice An attestation request that fetches JSON data from the given URL,\\n * applies a jq filter to transform the returned result, and returns the structured data as ABI encoded data.\\n * @custom:verification  Data is fetched from an URL `url`. The received data is then processed with jq as\\n * the `postProcessJq` states. The structure of the final JSON is written in the `abiSignature`.\\n *\\n * The response contains an abi encoding of the final data.\\n * @custom:lut `0xffffffffffffffff`\\n * @custom:lut-limit `0xffffffffffffffff`\\n */\\ninterface IWeb2Json {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\\n     * by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for Web2Json attestation type\\n     * @param url URL of the data source\\n     * @param httpMethod HTTP method to be used to fetch from URL source.\\n     * Supported methods: GET, POST, PUT, PATCH, DELETE.\\n     * @param headers Headers to be included to fetch from URL source. Use `{}` if no headers are needed.\\n     * @param queryParams Query parameters to be included to fetch from URL source.\\n     * Use `{}` if no query parameters are needed.\\n     * @param body Request body to be included to fetch from URL source. Use '{}' if no request body is required.\\n     * @param postProcessJq jq filter used to post-process the JSON response from the URL.\\n     * @param abiSignature ABI signature of the struct used to encode the data after jq post-processing.\\n     */\\n    struct RequestBody {\\n        string url;\\n        string httpMethod;\\n        string headers;\\n        string queryParams;\\n        string body;\\n        string postProcessJq;\\n        string abiSignature;\\n    }\\n\\n    /**\\n     * @notice Response body for Web2Json attestation type\\n     * @param abiEncodedData Raw binary data encoded to match the function parameters in ABI.\\n     */\\n    struct ResponseBody {\\n        bytes abiEncodedData;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWeb2JsonVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IWeb2Json.sol\\\";\\n\\ninterface IWeb2JsonVerification {\\n    function verifyWeb2Json(\\n        IWeb2Json.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IReferencedPaymentNonexistence.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IReferencedPaymentNonexistence\\n * @custom:id 0x04\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice Assertion that an agreed-upon payment has not been made by a certain deadline.\\n * A confirmed request shows that a transaction meeting certain criteria (address, amount, reference)\\n * did not appear in the specified block range.\\n *\\n *\\n * This type of attestation can be used to e.g. provide grounds to liquidate funds locked by a smart\\n * contract on Flare when a payment is missed.\\n *\\n * @custom:verification If `firstOverflowBlock` cannot be determined or does not have a sufficient\\n * number of confirmations, the attestation request is rejected.\\n * If `firstOverflowBlockNumber` is higher or equal to `minimalBlockNumber`, the request is rejected.\\n * The search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.\\n * If the verifier does not have a view of all blocks from `minimalBlockNumber` to `firstOverflowBlockNumber`,\\n * the attestation request is rejected.\\n *\\n * The request is confirmed if no transaction meeting the specified criteria is found in the search range.\\n * The criteria and timestamp are chain specific.\\n * ### UTXO (Bitcoin and Dogecoin)\\n *\\n *\\n * Criteria for the transaction:\\n *\\n *\\n * - It is not coinbase transaction.\\n * - The transaction has the specified standardPaymentReference.\\n * - The sum of values of all outputs with the specified address minus the sum of values of all inputs with\\n * the specified address is greater than `amount` (in practice the sum of all values of the inputs with the\\n * specified address is zero).\\n *\\n *\\n * Timestamp is `mediantime`.\\n * ### XRPL\\n *\\n *\\n *\\n * Criteria for the transaction:\\n * - The transaction is of type payment.\\n * - The transaction has the specified standardPaymentReference,\\n * - One of the following is true:\\n *   - Transaction status is `SUCCESS` and the amount received by the specified destination address is\\n * greater than the specified `value`.\\n *   - Transaction status is `RECEIVER_FAILURE` and the specified destination address would receive an\\n * amount greater than the specified `value` had the transaction been successful.\\n *\\n *\\n * Timestamp is `close_time` converted to UNIX time.\\n *\\n * @custom:lut `minimalBlockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IReferencedPaymentNonexistence {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the response\\n     * body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for ReferencePaymentNonexistence attestation type\\n     * @param minimalBlockNumber The start block of the search range.\\n     * @param deadlineBlockNumber The blockNumber to be included in the search range.\\n     * @param deadlineTimestamp The timestamp to be included in the search range.\\n     * @param destinationAddressHash The standard address hash of the address to which the payment had to be done.\\n     * @param amount The requested amount in minimal units that had to be payed.\\n     * @param standardPaymentReference The requested standard payment reference.\\n     * @param checkSourceAddresses If true, the source address root is checked (only full match).\\n     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.\\n     * @custom:below The `standardPaymentReference` should not be zero (as a 32-byte sequence).\\n     */\\n    struct RequestBody {\\n        uint64 minimalBlockNumber;\\n        uint64 deadlineBlockNumber;\\n        uint64 deadlineTimestamp;\\n        bytes32 destinationAddressHash;\\n        uint256 amount;\\n        bytes32 standardPaymentReference;\\n        bool checkSourceAddresses;\\n        bytes32 sourceAddressesRoot;\\n    }\\n\\n    /**\\n     * @notice Response body for ReferencePaymentNonexistence attestation type.\\n     * @param minimalBlockTimestamp The timestamp of the minimalBlock.\\n     * @param firstOverflowBlockNumber The height of the firstOverflowBlock.\\n     * @param firstOverflowBlockTimestamp The timestamp of the firstOverflowBlock.\\n     * @custom:below `firstOverflowBlock` is the first block that has block number higher than\\n     * `deadlineBlockNumber` and timestamp later than `deadlineTimestamp`.\\n     * The specified search range are blocks between heights including `minimalBlockNumber`\\n     * and excluding `firstOverflowBlockNumber`.\\n     */\\n    struct ResponseBody {\\n        uint64 minimalBlockTimestamp;\\n        uint64 firstOverflowBlockNumber;\\n        uint64 firstOverflowBlockTimestamp;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IReferencedPaymentNonexistenceVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IReferencedPaymentNonexistence.sol\\\";\\n\\ninterface IReferencedPaymentNonexistenceVerification {\\n    function verifyReferencedPaymentNonexistence(\\n        IReferencedPaymentNonexistence.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IRelay.sol\\\";\\nimport \\\"./IAddressValidityVerification.sol\\\";\\nimport \\\"./IBalanceDecreasingTransactionVerification.sol\\\";\\nimport \\\"./IConfirmedBlockHeightExistsVerification.sol\\\";\\nimport \\\"./IEVMTransactionVerification.sol\\\";\\nimport \\\"./IPaymentVerification.sol\\\";\\nimport \\\"./IReferencedPaymentNonexistenceVerification.sol\\\";\\nimport \\\"./IWeb2JsonVerification.sol\\\";\\n\\n/**\\n * FdcVerification interface.\\n */\\ninterface IFdcVerification is\\n    IAddressValidityVerification,\\n    IBalanceDecreasingTransactionVerification,\\n    IConfirmedBlockHeightExistsVerification,\\n    IEVMTransactionVerification,\\n    IPaymentVerification,\\n    IReferencedPaymentNonexistenceVerification,\\n    IWeb2JsonVerification\\n{\\n    /**\\n     * The FDC protocol id.\\n     */\\n    function fdcProtocolId() external view returns (uint8 _fdcProtocolId);\\n\\n    /**\\n     * Relay contract address.\\n     */\\n    function relay() external view returns (IRelay);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IGovernanceSettings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * A special contract that holds Flare governance address.\\n * This contract enables updating governance address and timelock only by hard forking the network,\\n * meaning only by updating validator code.\\n */\\ninterface IGovernanceSettings {\\n    /**\\n     * Get the governance account address.\\n     * The governance address can only be changed by a hardfork.\\n     */\\n    function getGovernanceAddress() external view returns (address);\\n\\n    /**\\n     * Get the time in seconds that must pass between a governance call and execution.\\n     * The timelock value can only be changed by a hardfork.\\n     */\\n    function getTimelock() external view returns (uint256);\\n\\n    /**\\n     * Get the addresses of the accounts that are allowed to execute the timelocked governance calls\\n     * once the timelock period expires.\\n     * Executors can be changed without a hardfork, via a normal governance call.\\n     */\\n    function getExecutors() external view returns (address[] memory);\\n\\n    /**\\n     * Check whether an address is one of the executors.\\n     */\\n    function isExecutor(address _address) external view returns (bool);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedIdConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * IFtsoFeedIdConverter interface.\\n */\\ninterface IFtsoFeedIdConverter {\\n    /**\\n     * Returns the feed id for given category and name.\\n     * @param _category Feed category.\\n     * @param _name Feed name.\\n     * @return Feed id.\\n     */\\n    function getFeedId(\\n        uint8 _category,\\n        string memory _name\\n    ) external view returns (bytes21);\\n\\n    /**\\n     * Returns the feed category and name for given feed id.\\n     * @param _feedId Feed id.\\n     * @return _category Feed category.\\n     * @return _name Feed name.\\n     */\\n    function getFeedCategoryAndName(\\n        bytes21 _feedId\\n    ) external pure returns (uint8 _category, string memory _name);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFeeCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FeeCalculator interface.\\n */\\ninterface IFeeCalculator {\\n    /**\\n     * Calculates a fee that needs to be paid to fetch feeds' data.\\n     * @param _feedIds List of feed ids.\\n     */\\n    function calculateFeeByIds(\\n        bytes21[] memory _feedIds\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Calculates a fee that needs to be paid to fetch feeds' data.\\n     * @param _indices Indices of the feeds, corresponding to feed ids in\\n     * the FastUpdatesConfiguration contract.\\n     */\\n    function calculateFeeByIndices(\\n        uint256[] memory _indices\\n    ) external view returns (uint256 _fee);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/TestFtsoV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoV2 long term support interface.\\n */\\ninterface TestFtsoV2Interface {\\n    /// Feed data structure\\n    struct FeedData {\\n        uint32 votingRoundId;\\n        bytes21 id;\\n        int32 value;\\n        uint16 turnoutBIPS;\\n        int8 decimals;\\n    }\\n\\n    /// Feed data with proof structure\\n    struct FeedDataWithProof {\\n        bytes32[] proof;\\n        FeedData body;\\n    }\\n\\n    /// Feed id change structure\\n    struct FeedIdChange {\\n        bytes21 oldFeedId;\\n        bytes21 newFeedId;\\n    }\\n\\n    /// Event emitted when a feed id is changed (e.g. feed renamed).\\n    event FeedIdChanged(bytes21 indexed oldFeedId, bytes21 indexed newFeedId);\\n\\n    /**\\n     * Returns the FTSO protocol id.\\n     */\\n    function getFtsoProtocolId() external view returns (uint256);\\n\\n    /**\\n     * Returns the list of supported feed ids (currently active feed ids).\\n     * To get the list of all available feed ids, combine with `getFeedIdChanges()`.\\n     * @return _feedIds The list of supported feed ids.\\n     */\\n    function getSupportedFeedIds()\\n        external\\n        view\\n        returns (bytes21[] memory _feedIds);\\n\\n    /**\\n     * Returns the list of feed id changes.\\n     * @return _feedIdChanges The list of changed feed id pairs (old and new feed id).\\n     */\\n    function getFeedIdChanges()\\n        external\\n        view\\n        returns (FeedIdChange[] memory _feedIdChanges);\\n\\n    /**\\n     * Calculates the fee for fetching a feed.\\n     * @param _feedId The id of the feed.\\n     * @return _fee The fee for fetching the feed.\\n     */\\n    function calculateFeeById(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Calculates the fee for fetching feeds.\\n     * @param _feedIds The list of feed ids.\\n     * @return _fee The fee for fetching the feeds.\\n     */\\n    function calculateFeeByIds(\\n        bytes21[] memory _feedIds\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Returns stored data of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed.\\n     * @return _decimals The decimal places for the requested feed.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedById(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _value, int8 _decimals, uint64 _timestamp);\\n\\n    /**\\n     * Returns stored data of each feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds The list of feed ids.\\n     * @return _values The list of values for the requested feeds.\\n     * @return _decimals The list of decimal places for the requested feeds.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsById(\\n        bytes21[] memory _feedIds\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _values,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Returns value in wei and timestamp of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedByIdInWei(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _value, uint64 _timestamp);\\n\\n    /** Returns value of each feed and a timestamp.\\n     * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds Ids of the feeds.\\n     * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsByIdInWei(\\n        bytes21[] memory _feedIds\\n    ) external view returns (uint256[] memory _values, uint64 _timestamp);\\n\\n    /**\\n     * Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).\\n     * @param _feedData Structure containing data about the feed (FeedData structure) and Merkle proof.\\n     * @return true if the feed data is valid.\\n     */\\n    function verifyFeedData(\\n        FeedDataWithProof calldata _feedData\\n    ) external view returns (bool);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/FtsoV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoV2 long term support interface.\\n */\\ninterface FtsoV2Interface {\\n    /// Feed data structure\\n    struct FeedData {\\n        uint32 votingRoundId;\\n        bytes21 id;\\n        int32 value;\\n        uint16 turnoutBIPS;\\n        int8 decimals;\\n    }\\n\\n    /// Feed data with proof structure\\n    struct FeedDataWithProof {\\n        bytes32[] proof;\\n        FeedData body;\\n    }\\n\\n    /// Feed id change structure\\n    struct FeedIdChange {\\n        bytes21 oldFeedId;\\n        bytes21 newFeedId;\\n    }\\n\\n    /// Event emitted when a feed id is changed (e.g. feed renamed).\\n    event FeedIdChanged(bytes21 indexed oldFeedId, bytes21 indexed newFeedId);\\n\\n    /**\\n     * Returns the FTSO protocol id.\\n     */\\n    function getFtsoProtocolId() external view returns (uint256);\\n\\n    /**\\n     * Returns the list of supported feed ids (currently active feed ids).\\n     * To get the list of all available feed ids, combine with `getFeedIdChanges()`.\\n     * @return _feedIds The list of supported feed ids.\\n     */\\n    function getSupportedFeedIds()\\n        external\\n        view\\n        returns (bytes21[] memory _feedIds);\\n\\n    /**\\n     * Returns the list of feed id changes.\\n     * @return _feedIdChanges The list of changed feed id pairs (old and new feed id).\\n     */\\n    function getFeedIdChanges()\\n        external\\n        view\\n        returns (FeedIdChange[] memory _feedIdChanges);\\n\\n    /**\\n     * Calculates the fee for fetching a feed.\\n     * @param _feedId The id of the feed.\\n     * @return _fee The fee for fetching the feed.\\n     */\\n    function calculateFeeById(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Calculates the fee for fetching feeds.\\n     * @param _feedIds The list of feed ids.\\n     * @return _fee The fee for fetching the feeds.\\n     */\\n    function calculateFeeByIds(\\n        bytes21[] memory _feedIds\\n    ) external view returns (uint256 _fee);\\n\\n    /**\\n     * Returns stored data of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed.\\n     * @return _decimals The decimal places for the requested feed.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedById(\\n        bytes21 _feedId\\n    )\\n        external\\n        payable\\n        returns (uint256 _value, int8 _decimals, uint64 _timestamp);\\n\\n    /**\\n     * Returns stored data of each feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds The list of feed ids.\\n     * @return _values The list of values for the requested feeds.\\n     * @return _decimals The list of decimal places for the requested feeds.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsById(\\n        bytes21[] memory _feedIds\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256[] memory _values,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Returns value in wei and timestamp of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedByIdInWei(\\n        bytes21 _feedId\\n    ) external payable returns (uint256 _value, uint64 _timestamp);\\n\\n    /** Returns value of each feed and a timestamp.\\n     * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds Ids of the feeds.\\n     * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsByIdInWei(\\n        bytes21[] memory _feedIds\\n    ) external payable returns (uint256[] memory _values, uint64 _timestamp);\\n\\n    /**\\n     * Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).\\n     * @param _feedData Structure containing data about the feed (FeedData structure) and Merkle proof.\\n     * @return true if the feed data is valid.\\n     */\\n    function verifyFeedData(\\n        FeedDataWithProof calldata _feedData\\n    ) external view returns (bool);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/AssetManagerSettings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nlibrary AssetManagerSettings {\\n    struct Data {\\n        // Required contracts.\\n        // Only used to verify that calls come from assetManagerController.\\n        // Type: AssetManagerController\\n        // changed via address updater\\n        address assetManagerController;\\n        // The f-asset contract managed by this asset manager.\\n        // Type: IIFAsset\\n        // immutable\\n        address fAsset;\\n        // Factory for creating new agent vaults.\\n        // Type: IIAgentVaultFactory\\n        // timelocked\\n        address agentVaultFactory;\\n        // Factory for creating new agent collateral pools.\\n        // Type: IICollateralPoolFactory\\n        // timelocked\\n        address collateralPoolFactory;\\n        // Factory for creating new agent collateral pool tokens.\\n        // Type: IICollateralPoolTokenFactory\\n        // timelocked\\n        address collateralPoolTokenFactory;\\n        // The suffix to pool token name and symbol that identifies new vault's collateral pool token.\\n        // When vault is created, the owner passes own suffix which will be appended to this.\\n        string poolTokenSuffix;\\n        // If set, the whitelist contains a list of accounts that can call public methods\\n        // (minting, redeeming, challenging, etc.)\\n        // This can be `address(0)`, in which case no whitelist checks are done.\\n        // Type: IWhitelist\\n        // timelocked\\n        address __whitelist; // only storage placeholder\\n        // If set, the owner address registry contains a list of allowed agent owner's\\n        // management addresses and mappings from management to work address.\\n        // Type: IAgentOwnerRegistry\\n        // timelocked\\n        address agentOwnerRegistry;\\n        // Attestation client verifies and decodes attestation proofs.\\n        // Type: IFdcVerification\\n        // changed via address updater\\n        address fdcVerification;\\n        // The address where burned NAT is sent.\\n        // immutable\\n        address payable burnAddress;\\n        // The contract that reads prices from FTSO system in an FTSO version independent way.\\n        // Type: IPriceReader\\n        // timelocked\\n        address priceReader;\\n        // Same as assetToken.decimals()\\n        // immutable\\n        uint8 assetDecimals;\\n        // Number of decimals of precision of minted amounts.\\n        // assetMintingGranularityUBA = 10 ** (assetDecimals - assetMintingDecimals)\\n        // immutable\\n        uint8 assetMintingDecimals;\\n        // Must match attestation data chainId.\\n        // immutable\\n        bytes32 chainId;\\n        // Average time between two successive blocks on the underlying chain, in milliseconds.\\n        // rate-limited\\n        uint32 averageBlockTimeMS;\\n        // The minimum amount of pool tokens the agent must hold to be able to mint.\\n        // To be able to mint, the NAT value of all backed fassets together with new ones times this percentage\\n        // must be smaller than the agent's pool tokens' amount converted to NAT.\\n        // rate-limited\\n        uint32 mintingPoolHoldingsRequiredBIPS;\\n        // Collateral reservation fee that must be paid by the minter.\\n        // Payment is in NAT, but is proportional to the value of assets to be minted.\\n        // rate-limited\\n        uint16 collateralReservationFeeBIPS;\\n        // Asset unit value (e.g. 1 BTC or 1 ETH) in UBA = 10 ** assetToken.decimals()\\n        // immutable\\n        uint64 assetUnitUBA;\\n        // The granularity in which lots are measured = the value of AMG (asset minting granularity) in UBA.\\n        // Can only be changed via redeploy of AssetManager.\\n        // AMG is used internally instead of UBA so that minted quantities fit into 64bits to reduce storage.\\n        // So assetMintingGranularityUBA should be set so that the max supply in AMG of this currency\\n        // in foreseeable time (say 100yr) cannot overflow 64 bits.\\n        // immutable\\n        uint64 assetMintingGranularityUBA;\\n        // Lot size in asset minting granularity. May change, which affects subsequent mintings and redemptions.\\n        // timelocked\\n        uint64 lotSizeAMG;\\n        // The percentage of minted f-assets that the agent must hold in his underlying address.\\n        uint16 __minUnderlyingBackingBIPS; // only storage placeholder\\n        // for some chains (e.g. Ethereum) we require that agent proves that underlying address is an EOA address\\n        // this must be done by presenting a payment proof from that address\\n        // immutable\\n        bool __requireEOAAddressProof; // only storage placeholder\\n        // Maximum minted amount of the f-asset.\\n        // rate-limited\\n        uint64 mintingCapAMG;\\n        // Number of underlying blocks that the minter or agent is allowed to pay underlying value.\\n        // If payment not reported in that time, minting/redemption can be challenged and default action triggered.\\n        // CAREFUL: Count starts from the current proved block height, so the minters and agents should\\n        // make sure that current block height is fresh, otherwise they might not have enough time for payment.\\n        // timelocked\\n        uint64 underlyingBlocksForPayment;\\n        // Minimum time to allow agent to pay for redemption or minter to pay for minting.\\n        // This is useful for fast chains, when there can be more than one block per second.\\n        // Redemption/minting payment failure can be called only after underlyingSecondsForPayment have elapsed\\n        // on underlying chain.\\n        // CAREFUL: Count starts from the current proved block timestamp, so the minters and agents should\\n        // make sure that current block timestamp is fresh, otherwise they might not have enough time for payment.\\n        // This is partially mitigated by adding local duration since the last block height update to\\n        // the current underlying block timestamp.\\n        // timelocked\\n        uint64 underlyingSecondsForPayment;\\n        // Redemption fee in underlying currency base amount (UBA).\\n        // rate-limited\\n        uint16 redemptionFeeBIPS;\\n        // On redemption underlying payment failure, redeemer is compensated with\\n        // redemption value recalculated in flare/sgb times redemption failure factor.\\n        // Expressed in BIPS, e.g. 12000 for factor of 1.2.\\n        // This is the part of factor paid from agent's vault collateral.\\n        // rate-limited\\n        uint32 redemptionDefaultFactorVaultCollateralBIPS;\\n        // This is the part of redemption factor paid from agent's pool collateral.\\n        // rate-limited\\n        uint32 __redemptionDefaultFactorPoolBIPS; // only storage placeholder\\n        // If the agent or redeemer becomes unresponsive, we still need payment or non-payment confirmations\\n        // to be presented eventually to properly track agent's underlying balance.\\n        // Therefore we allow anybody to confirm payments/non-payments this many seconds after request was made.\\n        // rate-limited\\n        uint64 confirmationByOthersAfterSeconds;\\n        // The user who makes abandoned redemption confirmations gets rewarded by the following amount.\\n        // rate-limited\\n        uint128 confirmationByOthersRewardUSD5;\\n        // To prevent unbounded work, the number of tickets redeemed in a single request is limited.\\n        // rate-limited\\n        // >= 1\\n        uint16 maxRedeemedTickets;\\n        // Challenge reward can be composed of two part - fixed and proportional (any of them can be zero).\\n        // This is the proportional part (in BIPS).\\n        // rate-limited\\n        uint16 paymentChallengeRewardBIPS;\\n        // Challenge reward can be composed of two part - fixed and proportional (any of them can be zero).\\n        // This is the fixed part (in vault collateral token wei).\\n        // rate-limited\\n        uint128 paymentChallengeRewardUSD5;\\n        // Agent has to announce any collateral withdrawal ar vault destroy and then wait for at least\\n        // withdrawalWaitMinSeconds. This prevents challenged agent to remove all collateral before\\n        // challenge can be proved.\\n        // rate-limited\\n        uint64 withdrawalWaitMinSeconds;\\n        // Maximum age that trusted price feed is valid.\\n        // Otherwise (if there were no trusted votes for that long) just use generic ftso price feed.\\n        // rate-limited\\n        uint64 maxTrustedPriceAgeSeconds;\\n        // Agent can remain in CCB for this much time, after that liquidation starts automatically.\\n        // rate-limited\\n        uint64 __ccbTimeSeconds; // only storage placeholder\\n        // Amount of seconds (typically 1 day) that the payment/non-payment proofs must be available.\\n        // This setting is used in `unstickMinting` and `finishRedemptionWithoutPayment` to prove that the time when\\n        // payment/non-payment could be proved has already passed.\\n        // rate-limited\\n        uint64 attestationWindowSeconds;\\n        // Minimum time after an update of a setting before the same setting can be updated again.\\n        // timelocked\\n        uint64 minUpdateRepeatTimeSeconds;\\n        // Ratio at which the agents can buy back their collateral when f-asset is terminated.\\n        // Typically a bit more than 1 to incentivize agents to buy f-assets and self-close instead.\\n        // immutable\\n        uint64 __buybackCollateralFactorBIPS; // only storage placeholder\\n        // Minimum time that has to pass between underlying withdrawal announcement and the confirmation.\\n        // Any value is ok, but higher values give more security against multiple announcement attack by a miner.\\n        // Shouldn't be much bigger than Flare data connector response time, so that payments can be confirmed without\\n        // extra wait. Should be smaller than confirmationByOthersAfterSeconds (e.g. less than 1 hour).\\n        // rate-limited\\n        uint64 __announcedUnderlyingConfirmationMinSeconds;\\n        // Minimum time from the moment token is deprecated to when it becomes invalid and agents still using\\n        // it as vault collateral get liquidated.\\n        // timelocked\\n        uint64 tokenInvalidationTimeMinSeconds;\\n        // On some rare occasions (stuck minting), the agent has to unlock collateral.\\n        // For this, part of collateral corresponding to FTSO asset value is burned and the rest is released.\\n        // However, we cannot burn typical vault collateral (stablecoins), so the agent must buy them for NAT\\n        // at FTSO price multiplied with this factor (should be a bit above 1) and then we burn the NATs.\\n        // timelocked\\n        uint32 vaultCollateralBuyForFlareFactorBIPS;\\n        // Amount of seconds that have to pass between available list exit announcement and execution.\\n        // rate-limited\\n        uint64 agentExitAvailableTimelockSeconds;\\n        // Amount of seconds that have to pass between agent fee and pool fee share change announcement and execution.\\n        // rate-limited\\n        uint64 agentFeeChangeTimelockSeconds;\\n        // Amount of seconds that have to pass between agent-set minting collateral ratio (vault or pool)\\n        // change announcement and execution.\\n        // rate-limited\\n        uint64 agentMintingCRChangeTimelockSeconds;\\n        // Amount of seconds that have to pass between agent-set settings for pool exit collateral ratio\\n        // change announcement and execution.\\n        // rate-limited\\n        uint64 poolExitCRChangeTimelockSeconds;\\n        // Amount of seconds that an agent is allowed to execute an update once it is allowed.\\n        // rate-limited\\n        uint64 agentTimelockedOperationWindowSeconds;\\n        // duration of the timelock for collateral pool tokens after minting\\n        uint32 collateralPoolTokenTimelockSeconds;\\n        // If there was no liquidator for the current liquidation offer,\\n        // go to the next step of liquidation after a certain period of time.\\n        // rate-limited\\n        uint64 liquidationStepSeconds;\\n        // Factor with which to multiply the asset price in native currency to obtain the payment\\n        // to the liquidator.\\n        // Expressed in BIPS, e.g. [12000, 16000, 20000] means that the liquidator will be paid 1.2, 1.6 and 2.0\\n        // times the market price of the liquidated assets after each `liquidationStepSeconds`.\\n        // Values in the array must increase and be greater than 100%.\\n        // rate-limited\\n        uint256[] liquidationCollateralFactorBIPS;\\n        // How much of the liquidation is paid in vault collateral.\\n        // The remainder will be paid in pool NAT collateral.\\n        uint256[] liquidationFactorVaultCollateralBIPS;\\n        // Minimum time that the system must wait before performing diamond cut.\\n        // The actual timelock is the maximum of this setting and GovernanceSettings.timelock.\\n        uint64 diamondCutMinTimelockSeconds;\\n        // The maximum total pause that can be triggered by non-governance (but governance allowed) caller.\\n        // The duration count can be reset by the governance.\\n        uint64 maxEmergencyPauseDurationSeconds;\\n        // The amount of time since last emergency pause after which the total pause duration counter\\n        // will reset automatically.\\n        uint64 emergencyPauseDurationResetAfterSeconds;\\n        // The amount of time after which the collateral reservation can be cancelled if the\\n        // handshake is not completed.\\n        // rate-limited\\n        uint64 __cancelCollateralReservationAfterSeconds; // only storage placeholder\\n        // The amount of collateral reservation fee returned to the minter in case of rejection or cancellation.\\n        // Expressed in BIPS, e.g. 9500 for factor of 0.95, max 10000 for factor of 1.0.\\n        // rate-limited\\n        uint16 __rejectOrCancelCollateralReservationReturnFactorBIPS; // only storage placeholder\\n        // Time window inside which the agent can reject the redemption request.\\n        // rate-limited\\n        uint64 __rejectRedemptionRequestWindowSeconds; // only storage placeholder\\n        // Time window inside which the agent can take over the redemption request from another agent\\n        // that has rejected it.\\n        // rate-limited\\n        uint64 __takeOverRedemptionRequestWindowSeconds; // only storage placeholder\\n        // On redemption rejection, without take over, redeemer is compensated with\\n        // redemption value recalculated in flare/sgb times redemption failure factor.\\n        // Expressed in BIPS, e.g. 12000 for factor of 1.2.\\n        // This is the part of factor paid from agent's vault collateral.\\n        // rate-limited\\n        uint32 __rejectedRedemptionDefaultFactorVaultCollateralBIPS; // only storage placeholder\\n        // This is the part of rejected redemption factor paid from agent's pool collateral.\\n        // rate-limited\\n        uint32 __rejectedRedemptionDefaultFactorPoolBIPS; // only storage placeholder\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/RedemptionTicketInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nlibrary RedemptionTicketInfo {\\n    struct Data {\\n        // The id of the ticket, same as returned in RedemptionTicketCreated/Updated/Deleted events.\\n        uint256 redemptionTicketId;\\n        // Backing agent vault address.\\n        address agentVault;\\n        // The amount of FAsset on the ticket.\\n        uint256 ticketValueUBA;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/RedemptionRequestInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nlibrary RedemptionRequestInfo {\\n    enum Status {\\n        ACTIVE, // waiting for confirmation/default\\n        DEFAULTED_UNCONFIRMED, // default called, failed or late payment can still be confirmed\\n        // final statuses - there can be no valid payment for this redemption anymore\\n        SUCCESSFUL, // successful payment confirmed\\n        DEFAULTED_FAILED, // payment failed   (default was paid)\\n        BLOCKED, // payment blocked\\n        REJECTED // redemption request rejected due to invalid redeemer's address\\n    }\\n\\n    struct Data {\\n        // The id used for confirming or defaulting the request.\\n        uint64 redemptionRequestId;\\n        // Redemption status. Note that on payment confirmation the request is deleted, so there is no success status.\\n        RedemptionRequestInfo.Status status;\\n        // The redeemed agent vault.\\n        address agentVault;\\n        // Native redeemer address - the address that receives collateral in case of default.\\n        address redeemer;\\n        // The underlying address to which the redeemed assets should be paid by the agent.\\n        string paymentAddress;\\n        // Payment reference that must be part of the agent's redemption payment.\\n        bytes32 paymentReference;\\n        // The amount of the FAsset the redeemer has burned. Note that this is not the amount of underlying\\n        // the redeemer will receive - the redemption payment amount is this minus the underlyingFeeUBA.\\n        uint128 valueUBA;\\n        // The redemption fee that remain on agent's underlying address.\\n        // Part of it will be reminted as pool fee share and the rest becomes the agent's free underlying.\\n        uint128 feeUBA;\\n        // Proportional part of the underlyingFeeUBA that is re-minted on successful redemption\\n        // and goes to the collateral pool.\\n        uint16 poolFeeShareBIPS;\\n        // The underlying block (approximate - as known by the asset manager) when the request occurred.\\n        uint64 firstUnderlyingBlock;\\n        // The last underlying block and timestamp for redemption payment. Redemption is defaulted if\\n        // there is no payment by the time BOTH lastUnderlyingBlock and lastUnderlyingTimestamp have passed.\\n        uint64 lastUnderlyingBlock;\\n        uint64 lastUnderlyingTimestamp;\\n        // The native (Flare/Songbird) chain timestamp when the request occurred.\\n        uint64 timestamp;\\n        // True if redemption was created by a selfCloseExit on the collateral pool.\\n        bool poolSelfClose;\\n        // True if redemption was initiated by an agent for transfer to core vault.\\n        bool transferToCoreVault;\\n        // The executor, optionally assigned by the redeemer to execute the default if needed.\\n        // (Only redeemer, agent or executor may execute the default.)\\n        address executor;\\n        // The fee in NAT that the executor receives if they successfully call default.\\n        uint256 executorFeeNatWei;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"versionPragma\":\">=0.4.16\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAssetManagerEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * All asset manager events.\\n */\\ninterface IAssetManagerEvents {\\n    struct AgentVaultCreationData {\\n        address collateralPool;\\n        address collateralPoolToken;\\n        string underlyingAddress;\\n        address vaultCollateralToken;\\n        address poolWNatToken;\\n        uint256 feeBIPS;\\n        uint256 poolFeeShareBIPS;\\n        uint256 mintingVaultCollateralRatioBIPS;\\n        uint256 mintingPoolCollateralRatioBIPS;\\n        uint256 buyFAssetByAgentFactorBIPS;\\n        uint256 poolExitCollateralRatioBIPS;\\n        uint256 redemptionPoolFeeShareBIPS;\\n    }\\n\\n    /**\\n     * A new agent vault was created.\\n     */\\n    event AgentVaultCreated(\\n        address indexed owner,\\n        address indexed agentVault,\\n        AgentVaultCreationData creationData\\n    );\\n\\n    /**\\n     * Agent has announced destroy (close) of agent vault and will be able to\\n     * perform destroy after the timestamp `destroyAllowedAt`.\\n     */\\n    event AgentDestroyAnnounced(\\n        address indexed agentVault,\\n        uint256 destroyAllowedAt\\n    );\\n\\n    /**\\n     * Agent has destroyed (closed) the agent vault.\\n     */\\n    event AgentDestroyed(address indexed agentVault);\\n\\n    /**\\n     * Agent has announced a withdrawal of collateral and will be able to\\n     * withdraw the announced amount after timestamp `withdrawalAllowedAt`.\\n     * If withdrawal was canceled (announced with amount 0), amountWei and withdrawalAllowedAt are zero.\\n     */\\n    event VaultCollateralWithdrawalAnnounced(\\n        address indexed agentVault,\\n        uint256 amountWei,\\n        uint256 withdrawalAllowedAt\\n    );\\n\\n    /**\\n     * Agent has announced a withdrawal of collateral and will be able to\\n     * redeem the announced amount of pool tokens after the timestamp `withdrawalAllowedAt`.\\n     * If withdrawal was canceled (announced with amount 0), amountWei and withdrawalAllowedAt are zero.\\n     */\\n    event PoolTokenRedemptionAnnounced(\\n        address indexed agentVault,\\n        uint256 amountWei,\\n        uint256 withdrawalAllowedAt\\n    );\\n\\n    /**\\n     * Agent was added to the list of available agents and can accept collateral reservation requests.\\n     */\\n    event AgentAvailable(\\n        address indexed agentVault,\\n        uint256 feeBIPS,\\n        uint256 mintingVaultCollateralRatioBIPS,\\n        uint256 mintingPoolCollateralRatioBIPS,\\n        uint256 freeCollateralLots\\n    );\\n\\n    /**\\n     * Agent exited from available agents list.\\n     * The agent can exit the available list after the timestamp `exitAllowedAt`.\\n     */\\n    event AvailableAgentExitAnnounced(\\n        address indexed agentVault,\\n        uint256 exitAllowedAt\\n    );\\n\\n    /**\\n     * Agent exited from available agents list.\\n     */\\n    event AvailableAgentExited(address indexed agentVault);\\n\\n    /**\\n     * Agent has initiated setting change (fee or some agent collateral ratio change).\\n     * The setting change can be executed after the timestamp `validAt`.\\n     */\\n    event AgentSettingChangeAnnounced(\\n        address indexed agentVault,\\n        string name,\\n        uint256 value,\\n        uint256 validAt\\n    );\\n\\n    /**\\n     * Agent has executed setting change (fee or some agent collateral ratio change).\\n     */\\n    event AgentSettingChanged(\\n        address indexed agentVault,\\n        string name,\\n        uint256 value\\n    );\\n\\n    /**\\n     * Agent or agent's collateral pool has changed token contract.\\n     */\\n    event AgentCollateralTypeChanged(\\n        address indexed agentVault,\\n        uint8 collateralClass,\\n        address token\\n    );\\n\\n    /**\\n     * Minter reserved collateral, paid the reservation fee, and is expected to pay the underlying funds.\\n     * Agent's collateral was reserved.\\n     */\\n    event CollateralReserved(\\n        address indexed agentVault,\\n        address indexed minter,\\n        uint256 indexed collateralReservationId,\\n        uint256 valueUBA,\\n        uint256 feeUBA,\\n        uint256 firstUnderlyingBlock,\\n        uint256 lastUnderlyingBlock,\\n        uint256 lastUnderlyingTimestamp,\\n        string paymentAddress,\\n        bytes32 paymentReference,\\n        address executor,\\n        uint256 executorFeeNatWei\\n    );\\n\\n    /**\\n     * Minter paid underlying funds in time and received the fassets.\\n     * The agent's collateral is locked.\\n     */\\n    event MintingExecuted(\\n        address indexed agentVault,\\n        uint256 indexed collateralReservationId,\\n        uint256 mintedAmountUBA,\\n        uint256 agentFeeUBA,\\n        uint256 poolFeeUBA\\n    );\\n\\n    /**\\n     * Minter failed to pay underlying funds in time. Collateral reservation fee was paid to the agent.\\n     * Reserved collateral was released.\\n     */\\n    event MintingPaymentDefault(\\n        address indexed agentVault,\\n        address indexed minter,\\n        uint256 indexed collateralReservationId,\\n        uint256 reservedAmountUBA\\n    );\\n\\n    /**\\n     * Both minter and agent failed to present any proof within attestation time window, so\\n     * the agent called `unstickMinting` to release reserved collateral.\\n     */\\n    event CollateralReservationDeleted(\\n        address indexed agentVault,\\n        address indexed minter,\\n        uint256 indexed collateralReservationId,\\n        uint256 reservedAmountUBA\\n    );\\n\\n    /**\\n     * Agent performed self minting, either by executing selfMint with underlying deposit or\\n     * by executing mintFromFreeUnderlying (in this case, `mintFromFreeUnderlying` is true and\\n     * `depositedAmountUBA` is zero).\\n     */\\n    event SelfMint(\\n        address indexed agentVault,\\n        bool mintFromFreeUnderlying,\\n        uint256 mintedAmountUBA,\\n        uint256 depositedAmountUBA,\\n        uint256 poolFeeUBA\\n    );\\n\\n    /**\\n     * Redeemer started the redemption process and provided fassets.\\n     * The amount of fassets corresponding to valueUBA was burned.\\n     * Several RedemptionRequested events are emitted, one for every agent redeemed against\\n     * (but multiple tickets for the same agent are combined).\\n     * The agent's collateral is still locked.\\n     */\\n    event RedemptionRequested(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        string paymentAddress,\\n        uint256 valueUBA,\\n        uint256 feeUBA,\\n        uint256 firstUnderlyingBlock,\\n        uint256 lastUnderlyingBlock,\\n        uint256 lastUnderlyingTimestamp,\\n        bytes32 paymentReference,\\n        address executor,\\n        uint256 executorFeeNatWei\\n    );\\n\\n    /**\\n     * Agent rejected the redemption payment because the redeemer's address is invalid.\\n     */\\n    event RedemptionRejected(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        uint256 redemptionAmountUBA\\n    );\\n\\n    /**\\n     * In case there were not enough tickets or more than allowed number would have to be redeemed,\\n     * only partial redemption is done and the `remainingLots` lots of the fassets are returned to\\n     * the redeemer.\\n     */\\n    event RedemptionRequestIncomplete(\\n        address indexed redeemer,\\n        uint256 remainingLots\\n    );\\n\\n    /**\\n     * Agent provided proof of redemption payment.\\n     * Agent's collateral is released.\\n     */\\n    event RedemptionPerformed(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        bytes32 transactionHash,\\n        uint256 redemptionAmountUBA,\\n        int256 spentUnderlyingUBA\\n    );\\n\\n    /**\\n     * The time for redemption payment is over and payment proof was not provided.\\n     * Redeemer was paid in the collateral (with extra).\\n     * The rest of the agent's collateral is released.\\n     * The corresponding amount of underlying currency, held by the agent, is released\\n     * and the agent can withdraw it (after underlying withdrawal announcement).\\n     */\\n    event RedemptionDefault(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        uint256 redemptionAmountUBA,\\n        uint256 redeemedVaultCollateralWei,\\n        uint256 redeemedPoolCollateralWei\\n    );\\n\\n    /**\\n     * Agent provided the proof that redemption payment was attempted, but failed due to\\n     * the redeemer's address being blocked (or burning more than allowed amount of gas).\\n     * Redeemer is not paid and all of the agent's collateral is released.\\n     * The underlying currency is also released to the agent.\\n     */\\n    event RedemptionPaymentBlocked(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        bytes32 transactionHash,\\n        uint256 redemptionAmountUBA,\\n        int256 spentUnderlyingUBA\\n    );\\n\\n    /**\\n     * Agent provided the proof that redemption payment was attempted, but failed due to\\n     * his own error. Also triggers payment default, unless the redeemer has done it already.\\n     */\\n    event RedemptionPaymentFailed(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 indexed requestId,\\n        bytes32 transactionHash,\\n        int256 spentUnderlyingUBA,\\n        string failureReason\\n    );\\n\\n    /**\\n     * At the end of a successful redemption, part of the redemption fee is re-minted as FAssets\\n     * and paid to the agent's collateral pool as fee.\\n     */\\n    event RedemptionPoolFeeMinted(\\n        address indexed agentVault,\\n        uint256 indexed requestId,\\n        uint256 poolFeeUBA\\n    );\\n\\n    /**\\n     * Due to self-close exit, some of the agent's backed fAssets were redeemed,\\n     * but the redemption was immediately paid in collateral so no redemption process is started.\\n     */\\n    event RedeemedInCollateral(\\n        address indexed agentVault,\\n        address indexed redeemer,\\n        uint256 redemptionAmountUBA,\\n        uint256 paidVaultCollateralWei\\n    );\\n\\n    /**\\n     * Agent self-closed valueUBA of backing fassets.\\n     */\\n    event SelfClose(address indexed agentVault, uint256 valueUBA);\\n\\n    /**\\n     * Redemption ticket with given value was created (when minting was executed).\\n     */\\n    event RedemptionTicketCreated(\\n        address indexed agentVault,\\n        uint256 indexed redemptionTicketId,\\n        uint256 ticketValueUBA\\n    );\\n\\n    /**\\n     * Redemption ticket value was changed (partially redeemed).\\n     * @param ticketValueUBA the ticket value after update\\n     */\\n    event RedemptionTicketUpdated(\\n        address indexed agentVault,\\n        uint256 indexed redemptionTicketId,\\n        uint256 ticketValueUBA\\n    );\\n\\n    /**\\n     * Redemption ticket was deleted.\\n     */\\n    event RedemptionTicketDeleted(\\n        address indexed agentVault,\\n        uint256 indexed redemptionTicketId\\n    );\\n\\n    /**\\n     * Due to lot size change, some dust was created for this agent during\\n     * redemption. Value `dustUBA` is the new amount of dust. Dust cannot be directly redeemed,\\n     * but it can be self-closed or liquidated and if it accumulates to more than 1 lot,\\n     * it can be converted to a new redemption ticket.\\n     */\\n    event DustChanged(address indexed agentVault, uint256 dustUBA);\\n\\n    /**\\n     * Agent entered liquidation state due to unhealthy position.\\n     * The liquidation ends when the agent is again healthy or the agent's position is fully liquidated.\\n     */\\n    event LiquidationStarted(address indexed agentVault, uint256 timestamp);\\n\\n    /**\\n     * Agent entered liquidation state due to illegal payment.\\n     * Full liquidation will always liquidate the whole agent's position and\\n     * the agent can never use the same vault and underlying address for minting again.\\n     */\\n    event FullLiquidationStarted(address indexed agentVault, uint256 timestamp);\\n\\n    /**\\n     * Some of the agent's position was liquidated, by burning liquidator's fassets.\\n     * Liquidator was paid in collateral with extra.\\n     * The corresponding amount of underlying currency, held by the agent, is released\\n     * and the agent can withdraw it (after underlying withdrawal announcement).\\n     */\\n    event LiquidationPerformed(\\n        address indexed agentVault,\\n        address indexed liquidator,\\n        uint256 valueUBA,\\n        uint256 paidVaultCollateralWei,\\n        uint256 paidPoolCollateralWei\\n    );\\n\\n    /**\\n     * Agent exited liquidation state as agent's position was healthy again and not in full liquidation.\\n     */\\n    event LiquidationEnded(address indexed agentVault);\\n\\n    /**\\n     * Part of the balance in the agent's underlying address is \\\"free balance\\\" that the agent can withdraw.\\n     * It is obtained from minting / redemption fees and self-closed fassets.\\n     * Some of this amount should be left for paying redemption (and withdrawal) gas fees,\\n     * and the rest can be withdrawn by the agent.\\n     * However, withdrawal has to be announced, otherwise it can be challenged as illegal payment.\\n     * Only one announcement can exist per agent - agent has to present payment proof for withdrawal\\n     * before starting a new one.\\n     */\\n    event UnderlyingWithdrawalAnnounced(\\n        address indexed agentVault,\\n        uint256 indexed announcementId,\\n        bytes32 paymentReference\\n    );\\n\\n    /**\\n     * After announcing legal underlying withdrawal and creating transaction,\\n     * the agent must confirm the transaction. This frees the announcement so the agent can create another one.\\n     * If the agent doesn't confirm in time, anybody can confirm the transaction after several hours.\\n     * Failed payments must also be confirmed.\\n     */\\n    event UnderlyingWithdrawalConfirmed(\\n        address indexed agentVault,\\n        uint256 indexed announcementId,\\n        int256 spentUBA,\\n        bytes32 transactionHash\\n    );\\n\\n    /**\\n     * After announcing legal underlying withdrawal agent can cancel ongoing withdrawal.\\n     * The reason for doing that would be in resetting announcement timestamp due to any problems with underlying\\n     * withdrawal - in order to prevent others to confirm withdrawal before agent and get some of his collateral.\\n     */\\n    event UnderlyingWithdrawalCancelled(\\n        address indexed agentVault,\\n        uint256 indexed announcementId\\n    );\\n\\n    /**\\n     * Emitted when the agent tops up the underlying address balance.\\n     */\\n    event UnderlyingBalanceToppedUp(\\n        address indexed agentVault,\\n        bytes32 transactionHash,\\n        uint256 depositedUBA\\n    );\\n\\n    /**\\n     * Emitted whenever the tracked underlying balance changes.\\n     */\\n    event UnderlyingBalanceChanged(\\n        address indexed agentVault,\\n        int256 underlyingBalanceUBA\\n    );\\n\\n    /**\\n     * An unexpected transaction from the agent's underlying address was proved.\\n     * Whole agent's position goes into liquidation.\\n     * The challenger is rewarded from the agent's collateral.\\n     */\\n    event IllegalPaymentConfirmed(\\n        address indexed agentVault,\\n        bytes32 transactionHash\\n    );\\n\\n    /**\\n     * Two transactions with the same payment reference, both from the agent's underlying address, were proved.\\n     * Whole agent's position goes into liquidation.\\n     * The challenger is rewarded from the agent's collateral.\\n     */\\n    event DuplicatePaymentConfirmed(\\n        address indexed agentVault,\\n        bytes32 transactionHash1,\\n        bytes32 transactionHash2\\n    );\\n\\n    /**\\n     * Agent's underlying balance became lower than required for backing f-assets (either through payment or via\\n     * a challenge. Agent goes to a full liquidation.\\n     * The challenger is rewarded from the agent's collateral.\\n     */\\n    event UnderlyingBalanceTooLow(\\n        address indexed agentVault,\\n        int256 balance,\\n        uint256 requiredBalance\\n    );\\n\\n    /**\\n     * A setting has changed.\\n     */\\n    event SettingChanged(string name, uint256 value);\\n\\n    /**\\n     * A setting has changed.\\n     */\\n    event SettingArrayChanged(string name, uint256[] value);\\n\\n    /**\\n     * A contract in the settings has changed.\\n     */\\n    event ContractChanged(string name, address value);\\n\\n    /**\\n     * Current underlying block number or timestamp has been updated.\\n     */\\n    event CurrentUnderlyingBlockUpdated(\\n        uint256 underlyingBlockNumber,\\n        uint256 underlyingBlockTimestamp,\\n        uint256 updatedAt\\n    );\\n\\n    /**\\n     * New collateral token has been added.\\n     */\\n    event CollateralTypeAdded(\\n        uint8 collateralClass,\\n        address token,\\n        uint256 decimals,\\n        bool directPricePair,\\n        string assetFtsoSymbol,\\n        string tokenFtsoSymbol,\\n        uint256 minCollateralRatioBIPS,\\n        uint256 safetyMinCollateralRatioBIPS\\n    );\\n\\n    /**\\n     * System defined collateral ratios for the token have changed (minimal and safety collateral ratio).\\n     */\\n    event CollateralRatiosChanged(\\n        uint8 collateralClass,\\n        address collateralToken,\\n        uint256 minCollateralRatioBIPS,\\n        uint256 safetyMinCollateralRatioBIPS\\n    );\\n\\n    /**\\n     * Collateral token has been marked as deprecated. After the timestamp `validUntil` passes, it will be\\n     * considered invalid and the agents who haven't switched their collateral before will be liquidated.\\n     */\\n    event CollateralTypeDeprecated(\\n        uint8 collateralClass,\\n        address collateralToken,\\n        uint256 validUntil\\n    );\\n\\n    /**\\n     * Emergency pause was triggered.\\n     */\\n    event EmergencyPauseTriggered(uint256 pausedUntil);\\n\\n    /**\\n     * Emergency pause was canceled.\\n     */\\n    event EmergencyPauseCanceled();\\n\\n    /**\\n     * Emergency pause transfers was triggered.\\n     */\\n    event EmergencyPauseTransfersTriggered(uint256 pausedUntil);\\n\\n    /**\\n     * Emergency pause transfers was canceled.\\n     */\\n    event EmergencyPauseTransfersCanceled();\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRedemptionTimeExtension.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IRedemptionTimeExtension {\\n    function setRedemptionPaymentExtensionSeconds(uint256 _value) external;\\n\\n    function redemptionPaymentExtensionSeconds()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAgentPing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IAgentPing {\\n    /**\\n     * Agent bot liveness check.\\n     * @param agentVault the agent vault whose owner bot to ping\\n     * @param sender the account that triggered ping; helps bot decide whether it is important to answer\\n     * @param query off-chain defined id of the query\\n     */\\n    event AgentPing(\\n        address indexed agentVault,\\n        address indexed sender,\\n        uint256 query\\n    );\\n\\n    /**\\n     * Response to agent bot liveness check.\\n     * @param agentVault the pinged agent vault\\n     * @param owner owner of the agent vault (management address)\\n     * @param query repeated `query` from the AgentPing event\\n     * @param response response data to the query\\n     */\\n    event AgentPingResponse(\\n        address indexed agentVault,\\n        address indexed owner,\\n        uint256 query,\\n        string response\\n    );\\n\\n    /**\\n     * Used for liveness checks, simply emits AgentPing event.\\n     * @param _agentVault the agent vault whose owner bot to ping\\n     * @param _query off-chain defined id of the query\\n     */\\n    function agentPing(address _agentVault, uint256 _query) external;\\n\\n    /**\\n     * Used for liveness checks, the bot's response to AgentPing event.\\n     * Simply emits AgentPingResponse event identifying the owner.\\n     * NOTE: may only be called by the agent vault owner\\n     * @param _agentVault the pinged agent vault\\n     * @param _query repeated `_query` from the agentPing\\n     * @param _response response data to the query\\n     */\\n    function agentPingResponse(\\n        address _agentVault,\\n        uint256 _query,\\n        string memory _response\\n    ) external;\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/ICoreVaultClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IPayment} from \\\".//IFdcVerification.sol\\\";\\n\\n/**\\n * Core vault\\n */\\ninterface ICoreVaultClient {\\n    /**\\n     * Agent has requested transfer of (some of) their backing to the core vault.\\n     */\\n    event TransferToCoreVaultStarted(\\n        address indexed agentVault,\\n        uint256 indexed transferRedemptionRequestId,\\n        uint256 valueUBA\\n    );\\n\\n    /**\\n     * Agent has cancelled transfer to the core vault without paying.\\n     * The amount of `valueUBA` has been re-minted./\\n     */\\n    event TransferToCoreVaultDefaulted(\\n        address indexed agentVault,\\n        uint256 indexed transferRedemptionRequestId,\\n        uint256 remintedUBA\\n    );\\n\\n    /**\\n     * The transfer of underlying to the core vault was successfully completed.\\n     */\\n    event TransferToCoreVaultSuccessful(\\n        address indexed agentVault,\\n        uint256 indexed transferRedemptionRequestId,\\n        uint256 valueUBA\\n    );\\n\\n    /**\\n     * The agent has requested return of some of the underlying from the core vault to the agent's underlying address.\\n     */\\n    event ReturnFromCoreVaultRequested(\\n        address indexed agentVault,\\n        uint256 indexed requestId,\\n        bytes32 paymentReference,\\n        uint256 valueUBA\\n    );\\n\\n    /**\\n     * The agent has cancelled the return request.\\n     */\\n    event ReturnFromCoreVaultCancelled(\\n        address indexed agentVault,\\n        uint256 indexed requestId\\n    );\\n\\n    /**\\n     * The payment from core vault to the agent's underlying address has been confirmed.\\n     */\\n    event ReturnFromCoreVaultConfirmed(\\n        address indexed agentVault,\\n        uint256 indexed requestId,\\n        uint256 receivedUnderlyingUBA,\\n        uint256 remintedUBA\\n    );\\n\\n    /**\\n     * Redemption was requested from a core vault.\\n     * Can only be redeemed to a payment address from to the `allowedDestinations` list in the core vault manager.\\n     */\\n    event CoreVaultRedemptionRequested(\\n        address indexed redeemer,\\n        string paymentAddress,\\n        bytes32 paymentReference,\\n        uint256 valueUBA,\\n        uint256 feeUBA\\n    );\\n\\n    /**\\n     * Agent can transfer their backing to core vault.\\n     * They then get a redemption requests which the owner pays just like any other redemption request.\\n     * After that, the agent's collateral is released.\\n     * NOTE: only agent vault owner can call\\n     * @param _agentVault the agent vault address\\n     * @param _amountUBA the amount to transfer to the core vault\\n     */\\n    function transferToCoreVault(\\n        address _agentVault,\\n        uint256 _amountUBA\\n    ) external;\\n\\n    /**\\n     * Request that core vault transfers funds to the agent's underlying address,\\n     * which makes them available for redemptions. This method reserves agent's collateral.\\n     * This may be sent by an agent when redemptions dominate mintings, so that the agents\\n     * are empty but want to earn from redemptions.\\n     * NOTE: only agent vault owner can call\\n     * NOTE: there can be only one active return request (until it is confirmed or cancelled).\\n     * @param _agentVault the agent vault address\\n     * @param _lots number of lots (same lots as for minting and redemptions)\\n     */\\n    function requestReturnFromCoreVault(\\n        address _agentVault,\\n        uint256 _lots\\n    ) external;\\n\\n    /**\\n     * Before the return request is processed, it can be cancelled, releasing the agent's reserved collateral.\\n     * @param _agentVault the agent vault address\\n     */\\n    function cancelReturnFromCoreVault(address _agentVault) external;\\n\\n    /**\\n     * Confirm the payment from core vault to the agent's underlying address.\\n     * This adds the reserved funds to the agent's backing.\\n     * @param _payment FDC payment proof\\n     * @param _agentVault the agent vault address\\n     */\\n    function confirmReturnFromCoreVault(\\n        IPayment.Proof calldata _payment,\\n        address _agentVault\\n    ) external;\\n\\n    /**\\n     * Directly redeem from core vault by a user holding FAssets.\\n     * This is like ordinary redemption, but the redemption time is much longer (a day or more)\\n     * and there is no possibility of redemption default.\\n     * @param _lots the number of lots, must be larger than `coreVaultMinimumRedeemLots` setting\\n     * @param _redeemerUnderlyingAddress the underlying address to which the assets will be redeemed;\\n     *      must have been added to the `allowedDestinations` list in the core vault manager by\\n     *      the governance before the redemption request.\\n     */\\n    function redeemFromCoreVault(\\n        uint256 _lots,\\n        string memory _redeemerUnderlyingAddress\\n    ) external;\\n\\n    /**\\n     * Return the maximum amount that can be transferred and the minimum amount that\\n     * has to remain on the agent vault's underlying address.\\n     * @param _agentVault the agent vault address\\n     * @return _maximumTransferUBA maximum amount that can be transferred\\n     * @return _minimumLeftAmountUBA the minimum amount that has to remain on the agent vault's underlying address\\n     *  after the transfer\\n     */\\n    function maximumTransferToCoreVault(\\n        address _agentVault\\n    )\\n        external\\n        view\\n        returns (uint256 _maximumTransferUBA, uint256 _minimumLeftAmountUBA);\\n\\n    /**\\n     * Returns the amount available on the core vault - this is the maximum amount that can be returned to agent or\\n     * redeemed directly from the core vault.\\n     * @return _immediatelyAvailableUBA the amount on the core vault operating account - returns and redemptions\\n     * within this amount will be paid out quickly\\n     * @return _totalAvailableUBA the total amount on the core vault, including all escrows\\n     */\\n    function coreVaultAvailableAmount()\\n        external\\n        view\\n        returns (uint256 _immediatelyAvailableUBA, uint256 _totalAvailableUBA);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAgentAlwaysAllowedMinters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IAgentAlwaysAllowedMinters {\\n    function addAlwaysAllowedMinterForAgent(\\n        address _agentVault,\\n        address _minter\\n    ) external;\\n\\n    function removeAlwaysAllowedMinterForAgent(\\n        address _agentVault,\\n        address _minter\\n    ) external;\\n\\n    function alwaysAllowedMintersForAgent(\\n        address _agentVault\\n    ) external view returns (address[] memory);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/CollateralType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary CollateralType {\\n    enum Class {\\n        NONE, // unused\\n        POOL, // pool collateral type\\n        VAULT // usable as vault collateral\\n    }\\n\\n    // Collateral token is uniquely identified by the pair (collateralClass, token).\\n    struct Data {\\n        // The kind of collateral for this token.\\n        CollateralType.Class collateralClass;\\n        // The ERC20 token contract for this collateral type.\\n        IERC20 token;\\n        // Same as token.decimals(), when that exists.\\n        uint256 decimals;\\n        // Token invalidation time. Must be 0 on creation.\\n        uint256 validUntil;\\n        // When `true`, the FTSO with symbol `assetFtsoSymbol` returns asset price relative to this token\\n        // (such FTSO's will probably exist for major stablecoins).\\n        // When `false`, the FTSOs with symbols `assetFtsoSymbol` and `tokenFtsoSymbol` give asset and token\\n        // price relative to the same reference currency and the asset/token price is calculated as their ratio.\\n        bool directPricePair;\\n        // FTSO symbol for the asset, relative to this token or a reference currency\\n        // (it depends on the value of `directPricePair`).\\n        string assetFtsoSymbol;\\n        // FTSO symbol for this token in reference currency.\\n        // Used for asset/token price calculation when `directPricePair` is `false`.\\n        // Otherwise it is irrelevant to asset/token price calculation, but if it is nonempty,\\n        // it is still used in calculation of challenger and confirmation rewards\\n        // (otherwise we assume it approximates the value of USD and pay directly the USD amount in vault collateral).\\n        string tokenFtsoSymbol;\\n        // Minimum collateral ratio for healthy agents.\\n        uint256 minCollateralRatioBIPS;\\n        // Minimum collateral ratio required to get agent out of liquidation.\\n        // Will always be greater than minCollateralRatioBIPS.\\n        uint256 safetyMinCollateralRatioBIPS;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/AgentInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary AgentInfo {\\n    enum Status {\\n        // agent is operating normally\\n        NORMAL,\\n        // liquidation due to collateral ratio - ends when agent is healthy\\n        LIQUIDATION,\\n        // illegal payment liquidation - always liquidates all and then agent must close vault\\n        FULL_LIQUIDATION,\\n        // agent announced destroy, cannot mint again; all existing mintings have been redeemed before\\n        DESTROYING,\\n        // agent has been destroyed, cannot do anything except return info\\n        // owner can still withdraw tokens from the vault\\n        DESTROYED\\n    }\\n\\n    struct Info {\\n        // Current agent's status.\\n        AgentInfo.Status status;\\n        // Agent vault owner's management address, used for occasional administration.\\n        // Immutable.\\n        address ownerManagementAddress;\\n        // Agent vault owner's work address, used for automatic operations.\\n        // Can be changed by a call from the owner's management address.\\n        address ownerWorkAddress;\\n        // Agent's collateral pool address\\n        address collateralPool;\\n        // Agent collateral pool's pool token address\\n        address collateralPoolToken;\\n        // Underlying address as string - to be used for minting payments.\\n        // For most other purposes, you use underlyingAddressHash, which is `keccak256(underlyingAddressString)`.\\n        string underlyingAddressString;\\n        // If true, anybody can mint against this agent.\\n        // If false, the agent can only self-mint.\\n        // Once minted, all redemption tickets go to the same (public) queue, regardless of this flag.\\n        bool publiclyAvailable;\\n        // Current fee the agent charges for minting (paid in underlying currency).\\n        uint256 feeBIPS;\\n        // Share of the minting fee that goes to the pool as percentage of the minting fee.\\n        // This share of fee is minted as f-assets and belongs to the pool.\\n        uint256 poolFeeShareBIPS;\\n        // The token identifier of the agent's current vault collateral.\\n        // Token identifier can be used to call AssetManager.getCollateralType().\\n        IERC20 vaultCollateralToken;\\n        // Amount, set by agent, at which locked and free collateral are calculated for new mintings.\\n        // For agent's vault collateral.\\n        uint256 mintingVaultCollateralRatioBIPS;\\n        // Amount, set by agent, at which locked and free collateral are calculated for new mintings.\\n        // For pool collateral.\\n        uint256 mintingPoolCollateralRatioBIPS;\\n        // The maximum number of lots that the agent can mint.\\n        // This can change any moment due to minting, redemption or price changes.\\n        uint256 freeCollateralLots;\\n        // Total amount of vault collateral in agent's vault.\\n        uint256 totalVaultCollateralWei;\\n        // Free collateral, available for new mintings.\\n        // Note: this value doesn't tell you anything about agent being near liquidation, since it is\\n        // calculated at agentMinCollateralRatio, not minCollateralRatio.\\n        // Use collateralRatioBIPS to see whether the agent is near liquidation.\\n        uint256 freeVaultCollateralWei;\\n        // The actual agent's collateral ratio, as it is used in liquidation.\\n        // For calculation, the system checks both FTSO prices and trusted provider's prices and uses\\n        // the ones that give higher ratio.\\n        uint256 vaultCollateralRatioBIPS;\\n        // The token identifier of the agent's current vault collateral.\\n        // Token identifier can be used to call AssetManager.getCollateralType().\\n        IERC20 poolWNatToken;\\n        // Total amount of NAT collateral in agent's pool.\\n        uint256 totalPoolCollateralNATWei;\\n        // Free NAT pool collateral (see vault collateral for details).\\n        uint256 freePoolCollateralNATWei;\\n        // The actual pool collateral ratio (see vault collateral for details).\\n        uint256 poolCollateralRatioBIPS;\\n        // The amount of pool tokens that belong to agent's vault. This limits the amount of possible\\n        // minting: to be able to mint, the NAT value of all backed fassets together with new ones, times\\n        // mintingPoolHoldingsRequiredBIPS, must be smaller than the agent's pool tokens amount converted to NAT.\\n        // Note: the amount of agent's pool tokens only affects minting, not liquidation.\\n        uint256 totalAgentPoolTokensWei;\\n        // The amount of vault collateral that will be withdrawn by the agent.\\n        uint256 announcedVaultCollateralWithdrawalWei;\\n        // The amount of pool tokens that will be withdrawn by the agent.\\n        uint256 announcedPoolTokensWithdrawalWei;\\n        // Free agent's pool tokens.\\n        uint256 freeAgentPoolTokensWei;\\n        // Total amount of minted f-assets.\\n        uint256 mintedUBA;\\n        // Total amount reserved for ongoing mintings.\\n        uint256 reservedUBA;\\n        // Total amount of ongoing redemptions.\\n        uint256 redeemingUBA;\\n        // Total amount of ongoing redemptions that lock the pool collateral.\\n        // (In pool self-close exits, pool collateral is not locked. So the amount of locked\\n        // collateral in the pool can be less than the amount of locked vault collateral.)\\n        uint256 poolRedeemingUBA;\\n        // Total amount of dust (unredeemable minted f-assets).\\n        // Note: dustUBA is part of mintedUBA, so the amount of redeemable f-assets is calculated as\\n        // `mintedUBA - dustUBA`\\n        uint256 dustUBA;\\n        // Liquidation info\\n        // If the agent is in LIQUIDATION or FULL_LIQUIDATION, the time agent entered liquidation.\\n        // If status is neither of that, returns 0.\\n        // Can be used for calculating current liquidation premium, which depends on time since liquidation started.\\n        uint256 liquidationStartTimestamp;\\n        // When agent is in liquidation, this is the amount o FAssets that need to be liquidated to bring the agent's\\n        // position to safety. When performing liquidation, only up to this amount of FAssets will be liquidated.\\n        // If not in liquidation, this value is 0.\\n        // Since the liquidation state may need to be upgraded by, call `startLiquidation` before\\n        // `getAgentInfo` to get the value that will actually be used in liquidation.\\n        uint256 maxLiquidationAmountUBA;\\n        // When agent is in liquidation, this is the factor (in BIPS) of the converted value of the liquidated\\n        // FAssets paid by the vault collateral. If not in liquidation, this value is 0.\\n        uint256 liquidationPaymentFactorVaultBIPS;\\n        // When agent is in liquidation, this is the factor (in BIPS) of the converted value of the liquidated\\n        // FAssets paid by the pool collateral. If not in liquidation, this value is 0.\\n        uint256 liquidationPaymentFactorPoolBIPS;\\n        // Total underlying balance (backing and free).\\n        int256 underlyingBalanceUBA;\\n        // The minimum underlying balance that has to be held by the agent. Below this, agent is liquidated.\\n        uint256 requiredUnderlyingBalanceUBA;\\n        // Underlying balance not backing anything (can be used for gas/fees or withdrawn after announcement).\\n        int256 freeUnderlyingBalanceUBA;\\n        // Current underlying withdrawal announcement (or 0 if no announcement was made).\\n        uint256 announcedUnderlyingWithdrawalId;\\n        // The factor set by the agent to multiply the price at which agent buys f-assets from pool\\n        // token holders on self-close exit (when requested or the redeemed amount is less than 1 lot).\\n        uint256 buyFAssetByAgentFactorBIPS;\\n        // The minimum collateral ratio above which a staker can exit the pool\\n        // (this is CR that must be left after exit).\\n        // Must be higher than system minimum collateral ratio for pool collateral.\\n        uint256 poolExitCollateralRatioBIPS;\\n        // The redemption fee share paid to the pool (as FAssets).\\n        // In redemption dominated situations (when agent requests return from core vault to earn\\n        // from redemption fees), pool can get some share to make it sustainable for pool users.\\n        // NOTE: the pool fee share is locked at the redemption request time, but is charged at the redemption\\n        // confirmation time. If agent uses all the redemption fee for transaction fees, this could make the\\n        // agent's free underlying balance negative.\\n        uint256 redemptionPoolFeeShareBIPS;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/AvailableAgentInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {AgentInfo} from \\\"./AgentInfo.sol\\\";\\n\\nlibrary AvailableAgentInfo {\\n    struct Data {\\n        // Agent vault address.\\n        address agentVault;\\n        // The management address of the agent vault's owner.\\n        address ownerManagementAddress;\\n        // Agent's minting fee in BIPS.\\n        uint256 feeBIPS;\\n        // Minimum agent vault collateral ratio needed for minting.\\n        uint256 mintingVaultCollateralRatioBIPS;\\n        // Minimum pool collateral ratio needed for minting.\\n        uint256 mintingPoolCollateralRatioBIPS;\\n        // The number of lots that can be minted by this agent.\\n        // Note: the value is only informative since it can can change at any time\\n        // due to price changes, reservation, minting, redemption, or even lot size change.\\n        uint256 freeCollateralLots;\\n        // The agent status, as for getAgentInfo().\\n        AgentInfo.Status status;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/ICoreVaultClientSettings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Core vault settings\\n */\\ninterface ICoreVaultClientSettings {\\n    function setCoreVaultManager(address _coreVaultManager) external;\\n\\n    function setCoreVaultNativeAddress(address payable _nativeAddress) external;\\n\\n    function setCoreVaultTransferTimeExtensionSeconds(\\n        uint256 _transferTimeExtensionSeconds\\n    ) external;\\n\\n    function setCoreVaultRedemptionFeeBIPS(uint256 _redemptionFeeBIPS) external;\\n\\n    function setCoreVaultMinimumAmountLeftBIPS(\\n        uint256 _minimumAmountLeftBIPS\\n    ) external;\\n\\n    function setCoreVaultMinimumRedeemLots(uint256 _minimumRedeemLots) external;\\n\\n    function getCoreVaultManager() external view returns (address);\\n\\n    function getCoreVaultNativeAddress() external view returns (address);\\n\\n    function getCoreVaultTransferTimeExtensionSeconds()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCoreVaultRedemptionFeeBIPS() external view returns (uint256);\\n\\n    function getCoreVaultMinimumAmountLeftBIPS()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCoreVaultMinimumRedeemLots() external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/AgentSettings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary AgentSettings {\\n    struct Data {\\n        // The token used as vault collateral. Must be one of the tokens obtained by `getCollateralTypes()`,\\n        // with class VAULT.\\n        IERC20 vaultCollateralToken;\\n        // The suffix to pool token name and symbol that identifies new vault's collateral pool token.\\n        // Must be unique within an asset manager.\\n        string poolTokenSuffix;\\n        // Minting fee. Normally charged to minters for publicly available agents, but must be set\\n        // also for self-minting agents to pay part of it to collateral pool.\\n        // Fee is paid in underlying currency along with backing assets.\\n        uint256 feeBIPS;\\n        // Share of the minting fee that goes to the pool as percentage of the minting fee.\\n        // This share of fee is minted as f-assets and belongs to the pool.\\n        uint256 poolFeeShareBIPS;\\n        // Collateral ratio at which we calculate locked collateral and collateral available for minting.\\n        // Agent may set own value for minting collateral ratio on creation.\\n        // The value must always be greater than system minimum collateral ratio for vault collateral.\\n        // Warning: having this value near global min collateral ratio can quickly lead to liquidation for public\\n        // agents, so it is advisable to set it significantly higher.\\n        uint256 mintingVaultCollateralRatioBIPS;\\n        // Collateral ratio at which we calculate locked collateral and collateral available for minting.\\n        // Agent may set own value for minting collateral ratio on creation.\\n        // The value must always be greater than system minimum collateral ratio for pool collateral.\\n        // Warning: having this value near global min collateral ratio can quickly lead to liquidation for public\\n        // agents, so it is advisable to set it significantly higher.\\n        uint256 mintingPoolCollateralRatioBIPS;\\n        // The factor set by the agent to multiply the price at which agent buys f-assets from pool\\n        // token holders on self-close exit (when requested or the redeemed amount is less than 1 lot).\\n        uint256 buyFAssetByAgentFactorBIPS;\\n        // The minimum collateral ratio above which a staker can exit the pool\\n        // (this is CR that must be left after exit).\\n        // Must be higher than system minimum collateral ratio for pool collateral.\\n        uint256 poolExitCollateralRatioBIPS;\\n        // The redemption fee share paid to the pool (as FAssets).\\n        // In redemption dominated situations (when agent requests return from core vault to earn\\n        // from redemption fees), pool can get some share to make it sustainable for pool users.\\n        // NOTE: the pool fee share is locked at the redemption request time, but is charged at the redemption\\n        // confirmation time. If agent uses all the redemption fee for transaction fees, this could make the\\n        // agent's free underlying balance negative.\\n        uint256 redemptionPoolFeeShareBIPS;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/data/CollateralReservationInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nlibrary CollateralReservationInfo {\\n    enum Status {\\n        ACTIVE, // the minting process hasn't finished yet\\n        SUCCESSFUL, // the payment has been confirmed and the FAssets minted\\n        DEFAULTED, // the payment has defaulted and the agent received the collateral reservation fee\\n        EXPIRED // the confirmation time has expired and the agent called unstickMinting\\n    }\\n\\n    struct Data {\\n        // The id used for executing or defaulting the minting.\\n        uint64 collateralReservationId;\\n        // The agent vault whose collateral is reserved.\\n        address agentVault;\\n        // The minter address - the address that will receive the minted FAssets.\\n        address minter;\\n        // The agent's underlying address to which the underlying assets should be paid by the minter.\\n        string paymentAddress;\\n        // Payment reference that must be part of the agent's redemption payment.\\n        bytes32 paymentReference;\\n        // The amount of FAssets that the minter will receive. Always a whole number of lots.\\n        uint256 valueUBA;\\n        // The underlying fee. The total amount the minter has to deposit is `valueUBA + mintingFeeUBA`.\\n        // Part of the fee is minted as pool fee share and the rest becomes agent's free underlying.\\n        uint128 mintingFeeUBA;\\n        // The fee that was paid at the collateral reservation time.\\n        // Part of the fee is goes to the pool and the rest to the agent vault as WNAT.\\n        uint128 reservationFeeNatWei;\\n        // Proportion of the mintingFeeUBA and reservationFeeNatWei that belongs to the collateral pool.\\n        uint16 poolFeeShareBIPS;\\n        // The underlying block (approximate - as known by the asset manager) when the reservation occurred.\\n        uint64 firstUnderlyingBlock;\\n        // The last underlying block and timestamp for redemption payment. Redemption is defaulted if\\n        // there is no payment by the time BOTH lastUnderlyingBlock and lastUnderlyingTimestamp have passed.\\n        uint64 lastUnderlyingBlock;\\n        uint64 lastUnderlyingTimestamp;\\n        // The executor, optionally assigned by the minter to execute the minting.\\n        // (Only minter, agent or executor may execute the minting.)\\n        address executor;\\n        // The fee in NAT that the executor receives if they successfully execute the minting.\\n        uint256 executorFeeNatWei;\\n        // If the minting process has finished, indication of success/default. Otherwise ACTIVE.\\n        CollateralReservationInfo.Status status;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/diamond/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(\\n        address _facet\\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(\\n        bytes4 _functionSelector\\n    ) external view returns (address facetAddress_);\\n}\\n\",\"versionPragma\":\"^0.8.0\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAssetManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IConfirmedBlockHeightExists, IPayment, IAddressValidity, IReferencedPaymentNonexistence, IBalanceDecreasingTransaction} from \\\".//IFdcVerification.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {IDiamondLoupe} from \\\"./diamond/interfaces/IDiamondLoupe.sol\\\";\\nimport {AssetManagerSettings} from \\\"./data/AssetManagerSettings.sol\\\";\\nimport {CollateralType} from \\\"./data/CollateralType.sol\\\";\\nimport {AgentInfo} from \\\"./data/AgentInfo.sol\\\";\\nimport {AgentSettings} from \\\"./data/AgentSettings.sol\\\";\\nimport {AvailableAgentInfo} from \\\"./data/AvailableAgentInfo.sol\\\";\\nimport {RedemptionTicketInfo} from \\\"./data/RedemptionTicketInfo.sol\\\";\\nimport {RedemptionRequestInfo} from \\\"./data/RedemptionRequestInfo.sol\\\";\\nimport {CollateralReservationInfo} from \\\"./data/CollateralReservationInfo.sol\\\";\\nimport {IAssetManagerEvents} from \\\"./IAssetManagerEvents.sol\\\";\\nimport {IAgentPing} from \\\"./IAgentPing.sol\\\";\\nimport {IRedemptionTimeExtension} from \\\"./IRedemptionTimeExtension.sol\\\";\\nimport {ICoreVaultClient} from \\\"./ICoreVaultClient.sol\\\";\\nimport {ICoreVaultClientSettings} from \\\"./ICoreVaultClientSettings.sol\\\";\\nimport {IAgentAlwaysAllowedMinters} from \\\"./IAgentAlwaysAllowedMinters.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * Asset manager publicly callable methods.\\n */\\ninterface IAssetManager is\\n    IERC165,\\n    IDiamondLoupe,\\n    IAssetManagerEvents,\\n    IAgentPing,\\n    IRedemptionTimeExtension,\\n    ICoreVaultClient,\\n    ICoreVaultClientSettings,\\n    IAgentAlwaysAllowedMinters\\n{\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Basic system information\\n\\n    /**\\n     * Get the asset manager controller, the only address that can change settings.\\n     * Asset manager must be attached to the asset manager controller in the system contract registry.\\n     */\\n    function assetManagerController() external view returns (address);\\n\\n    /**\\n     * Get the f-asset contract managed by this asset manager instance.\\n     */\\n    function fAsset() external view returns (IERC20);\\n\\n    /**\\n     * Get the price reader contract used by this asset manager instance.\\n     */\\n    function priceReader() external view returns (address);\\n\\n    /**\\n     * Return lot size in UBA (underlying base amount - smallest amount on underlying chain, e.g. satoshi).\\n     */\\n    function lotSize() external view returns (uint256 _lotSizeUBA);\\n\\n    /**\\n     * Return asset minting granularity - smallest unit of f-asset stored internally\\n     * within this asset manager instance.\\n     */\\n    function assetMintingGranularityUBA() external view returns (uint256);\\n\\n    /**\\n     * Return asset minting decimals - the number of decimals of precision for minting.\\n\\n     */\\n    function assetMintingDecimals() external view returns (uint256);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // System settings\\n\\n    /**\\n     * Get complete current settings.\\n     * @return the current settings\\n     */\\n    function getSettings()\\n        external\\n        view\\n        returns (AssetManagerSettings.Data memory);\\n\\n    /**\\n     * When `controllerAttached` is true, asset manager has been added to the asset manager controller.\\n     * This is required for the asset manager to be operational (create agent and minting don't work otherwise).\\n     */\\n    function controllerAttached() external view returns (bool);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Emergency pause\\n\\n    /**\\n     * If true, the system is in emergency pause mode and most operations (mint, redeem, liquidate) are disabled.\\n     */\\n    function emergencyPaused() external view returns (bool);\\n\\n    /**\\n     * The time when emergency pause mode will end automatically.\\n     */\\n    function emergencyPausedUntil() external view returns (uint256);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Emergency pause transfers\\n\\n    /**\\n     * If true, the system is in emergency pause mode and most operations (mint, redeem, liquidate) are disabled.\\n     */\\n    function transfersEmergencyPaused() external view returns (bool);\\n\\n    /**\\n     * The time when emergency pause mode will end automatically.\\n     */\\n    function transfersEmergencyPausedUntil() external view returns (uint256);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Asset manager upgrading state\\n\\n    /**\\n     * True if the asset manager is paused.\\n     * In the paused state, minting is disabled, but all other operations (e.g. redemptions, liquidation) still work.\\n     * Paused asset manager can be later unpaused.\\n     */\\n    function mintingPaused() external view returns (bool);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Timekeeping for underlying chain\\n\\n    /**\\n     * Prove that a block with given number and timestamp exists and\\n     * update the current underlying block info if the provided data is higher.\\n     * This method should be called by minters before minting and by agent's regularly\\n     * to prevent current block being too outdated, which gives too short time for\\n     * minting or redemption payment.\\n     * NOTE: anybody can call.\\n     * @param _proof proof that a block with given number and timestamp exists\\n     */\\n    function updateCurrentBlock(\\n        IConfirmedBlockHeightExists.Proof calldata _proof\\n    ) external;\\n\\n    /**\\n     * Get block number and timestamp of the current underlying block known to the f-asset system.\\n     * @return _blockNumber current underlying block number tracked by asset manager\\n     * @return _blockTimestamp current underlying block timestamp tracked by asset manager\\n     * @return _lastUpdateTs the timestamp on this chain when the current underlying block was last updated\\n     */\\n    function currentUnderlyingBlock()\\n        external\\n        view\\n        returns (\\n            uint256 _blockNumber,\\n            uint256 _blockTimestamp,\\n            uint256 _lastUpdateTs\\n        );\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Available collateral types\\n\\n    /**\\n     * Get collateral  information about a token.\\n     */\\n    function getCollateralType(\\n        CollateralType.Class _collateralClass,\\n        IERC20 _token\\n    ) external view returns (CollateralType.Data memory);\\n\\n    /**\\n     * Get the list of all available and deprecated tokens used for collateral.\\n     */\\n    function getCollateralTypes()\\n        external\\n        view\\n        returns (CollateralType.Data[] memory);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Agent create / destroy\\n\\n    /**\\n     * Create an agent vault.\\n     * The agent will always be identified by `_agentVault` address.\\n     * (Externally, one account may own several agent vaults,\\n     *  but in fasset system, each agent vault acts as an independent agent.)\\n     * NOTE: may only be called by an agent on the allowed agent list.\\n     * Can be called from the management or the work agent owner address.\\n     * @return _agentVault new agent vault address\\n     */\\n    function createAgentVault(\\n        IAddressValidity.Proof calldata _addressProof,\\n        AgentSettings.Data calldata _settings\\n    ) external returns (address _agentVault);\\n\\n    /**\\n     * Announce that the agent is going to be destroyed. At this time, the agent must not have any mintings\\n     * or collateral reservations and must not be on the available agents list.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @return _destroyAllowedAt the timestamp at which the destroy can be executed\\n     */\\n    function announceDestroyAgent(\\n        address _agentVault\\n    ) external returns (uint256 _destroyAllowedAt);\\n\\n    /**\\n     * Delete all agent data, self destruct agent vault and send remaining collateral to the `_recipient`.\\n     * Procedure for destroying agent:\\n     * - exit available agents list\\n     * - wait until all assets are redeemed or perform self-close\\n     * - announce destroy (and wait the required time)\\n     * - call destroyAgent()\\n     * NOTE: may only be called by the agent vault owner.\\n     * NOTE: the remaining funds from the vault will be transferred to the provided recipient.\\n     * @param _agentVault address of the agent's vault to destroy\\n     * @param _recipient address that receives the remaining funds and possible vault balance\\n     */\\n    function destroyAgent(\\n        address _agentVault,\\n        address payable _recipient\\n    ) external;\\n\\n    /**\\n     * When agent vault, collateral pool or collateral pool token factory is upgraded, new agent vaults\\n     * automatically get the new implementation from the factory. But the existing agent vaults must\\n     * be upgraded by their owners using this method.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault address of the agent's vault; both vault, its corresponding pool, and\\n     *  its pool token will be upgraded to the newest implementations\\n     */\\n    function upgradeAgentVaultAndPool(address _agentVault) external;\\n\\n    /**\\n     * Check if the collateral pool token has been used already by some vault.\\n     * @param _suffix the suffix to check\\n     */\\n    function isPoolTokenSuffixReserved(\\n        string memory _suffix\\n    ) external view returns (bool);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Agent settings update\\n\\n    /**\\n     * Due to the effect on the pool, all agent settings are timelocked.\\n     * This method announces a setting change. The change can be executed after the timelock expires.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _name setting name, same as for `getAgentSetting`\\n     * @return _updateAllowedAt the timestamp at which the update can be executed\\n     */\\n    function announceAgentSettingUpdate(\\n        address _agentVault,\\n        string memory _name,\\n        uint256 _value\\n    ) external returns (uint256 _updateAllowedAt);\\n\\n    /**\\n     * Due to the effect on the pool, all agent settings are timelocked.\\n     * This method executes a setting change after the timelock expires.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _name setting name, same as for `getAgentSetting`\\n     */\\n    function executeAgentSettingUpdate(\\n        address _agentVault,\\n        string memory _name\\n    ) external;\\n\\n    /**\\n     * If the current agent's vault collateral token gets deprecated, the agent must switch with this method.\\n     * NOTE: may only be called by the agent vault owner.\\n     * NOTE: at the time of switch, the agent must have enough of both collaterals in the vault.\\n     */\\n    function switchVaultCollateral(address _agentVault, IERC20 _token) external;\\n\\n    /**\\n     * When current pool collateral token contract (WNat) is replaced by the method setPoolWNatCollateralType,\\n     * pools don't switch automatically. Instead, the agent must call this method that swaps old WNat tokens for\\n     * new ones and sets it for use by the pool.\\n     * NOTE: may only be called by the agent vault owner.\\n     */\\n    function upgradeWNatContract(address _agentVault) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Collateral withdrawal announcement\\n\\n    /**\\n     * The agent is going to withdraw `_valueNATWei` amount of collateral from the agent vault.\\n     * This has to be announced and the agent must then wait `withdrawalWaitMinSeconds` time.\\n     * After that time, the agent can call `withdrawCollateral(_vaultCollateralToken, _valueNATWei)`\\n     * on the agent vault.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _valueNATWei the amount to be withdrawn\\n     * @return _withdrawalAllowedAt the timestamp when the withdrawal can be made\\n     */\\n    function announceVaultCollateralWithdrawal(\\n        address _agentVault,\\n        uint256 _valueNATWei\\n    ) external returns (uint256 _withdrawalAllowedAt);\\n\\n    /**\\n     * The agent is going to redeem `_valueWei` collateral pool tokens in the agent vault.\\n     * This has to be announced and the agent must then wait `withdrawalWaitMinSeconds` time.\\n     * After that time, the agent can call `redeemCollateralPoolTokens(_valueNATWei)` on the agent vault.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _valueNATWei the amount to be withdrawn\\n     * @return _redemptionAllowedAt the timestamp when the redemption can be made\\n     */\\n    function announceAgentPoolTokenRedemption(\\n        address _agentVault,\\n        uint256 _valueNATWei\\n    ) external returns (uint256 _redemptionAllowedAt);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Underlying balance topup\\n\\n    /**\\n     * When the agent tops up his underlying address, it has to be confirmed by calling this method,\\n     * which updates the underlying free balance value.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _payment proof of the underlying payment; must include payment\\n     *      reference of the form `0x4642505266410011000...0<agents_vault_address>`\\n     * @param _agentVault agent vault address\\n     */\\n    function confirmTopupPayment(\\n        IPayment.Proof calldata _payment,\\n        address _agentVault\\n    ) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Underlying withdrawal announcements\\n\\n    /**\\n     * Announce withdrawal of underlying currency.\\n     * In the event UnderlyingWithdrawalAnnounced the agent receives payment reference, which must be\\n     * added to the payment, otherwise it can be challenged as illegal.\\n     * Until the announced withdrawal is performed and confirmed or canceled, no other withdrawal can be announced.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     */\\n    function announceUnderlyingWithdrawal(address _agentVault) external;\\n\\n    /**\\n     * Agent must provide confirmation of performed underlying withdrawal, which updates free balance with used gas\\n     * and releases announcement so that a new one can be made.\\n     * If the agent doesn't call this method, anyone can call it after a time (`confirmationByOthersAfterSeconds`).\\n     * NOTE: may only be called by the owner of the agent vault\\n     *   except if enough time has passed without confirmation - then it can be called by anybody.\\n     * @param _payment proof of the underlying payment\\n     * @param _agentVault agent vault address\\n     */\\n    function confirmUnderlyingWithdrawal(\\n        IPayment.Proof calldata _payment,\\n        address _agentVault\\n    ) external;\\n\\n    /**\\n     * Cancel ongoing withdrawal of underlying currency.\\n     * Needed in order to reset announcement timestamp, so that others cannot front-run the agent at\\n     * `confirmUnderlyingWithdrawal` call. This could happen if withdrawal would be performed more\\n     * than `confirmationByOthersAfterSeconds` seconds after announcement.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     */\\n    function cancelUnderlyingWithdrawal(address _agentVault) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Agent information\\n\\n    /**\\n     * Get (a part of) the list of all agents.\\n     * The list must be retrieved in parts since retrieving the whole list can consume too much gas for one block.\\n     * @param _start first index to return from the available agent's list\\n     * @param _end end index (one above last) to return from the available agent's list\\n     */\\n    function getAllAgents(\\n        uint256 _start,\\n        uint256 _end\\n    )\\n        external\\n        view\\n        returns (address[] memory _agentVaults, uint256 _totalLength);\\n\\n    /**\\n     * Return detailed info about an agent, typically needed by a minter.\\n     * @param _agentVault agent vault address\\n     * @return structure containing agent's minting fee (BIPS), min collateral ratio (BIPS),\\n     *      and current free collateral (lots)\\n     */\\n    function getAgentInfo(\\n        address _agentVault\\n    ) external view returns (AgentInfo.Info memory);\\n\\n    /**\\n     * Get agent's setting by name.\\n     * This allows reading individual settings.\\n     * @param _agentVault agent vault address\\n     * @param _name setting name, one of: `feeBIPS`, `poolFeeShareBIPS`, `redemptionPoolFeeShareBIPS`,\\n     *  `mintingVaultCollateralRatioBIPS`, `mintingPoolCollateralRatioBIPS`,`buyFAssetByAgentFactorBIPS`,\\n     *  `poolExitCollateralRatioBIPS`\\n     */\\n    function getAgentSetting(\\n        address _agentVault,\\n        string memory _name\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Returns the collateral pool address of the agent identified by `_agentVault`.\\n     */\\n    function getCollateralPool(\\n        address _agentVault\\n    ) external view returns (address);\\n\\n    /**\\n     * Return the management address of the owner of the agent identified by `_agentVault`.\\n     */\\n    function getAgentVaultOwner(\\n        address _agentVault\\n    ) external view returns (address _ownerManagementAddress);\\n\\n    /**\\n     * Return vault collateral ERC20 token chosen by the agent identified by `_agentVault`.\\n     */\\n    function getAgentVaultCollateralToken(\\n        address _agentVault\\n    ) external view returns (IERC20);\\n\\n    /**\\n     * Return full vault collateral (free + locked) deposited in the vault `_agentVault`.\\n     */\\n    function getAgentFullVaultCollateral(\\n        address _agentVault\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return full pool NAT collateral (free + locked) deposited in the vault `_agentVault`.\\n     */\\n    function getAgentFullPoolCollateral(\\n        address _agentVault\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return the current liquidation factors and max liquidation amount of the agent\\n     * identified by `_agentVault`.\\n     */\\n    function getAgentLiquidationFactorsAndMaxAmount(\\n        address _agentVault\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liquidationPaymentFactorVaultBIPS,\\n            uint256 liquidationPaymentFactorPoolBIPS,\\n            uint256 maxLiquidationAmountUBA\\n        );\\n\\n    /**\\n     * Return the minimum collateral ratio of the pool collateral owned by vault `_agentVault`.\\n     */\\n    function getAgentMinPoolCollateralRatioBIPS(\\n        address _agentVault\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return the minimum collateral ratio of the vault collateral owned by vault `_agentVault`.\\n     */\\n    function getAgentMinVaultCollateralRatioBIPS(\\n        address _agentVault\\n    ) external view returns (uint256);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // List of available agents (i.e. publicly available for minting).\\n\\n    /**\\n     * Add the agent to the list of publicly available agents.\\n     * Other agents can only self-mint.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     */\\n    function makeAgentAvailable(address _agentVault) external;\\n\\n    /**\\n     * Announce exit from the publicly available agents list.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @return _exitAllowedAt the timestamp when the agent can exit\\n     */\\n    function announceExitAvailableAgentList(\\n        address _agentVault\\n    ) external returns (uint256 _exitAllowedAt);\\n\\n    /**\\n     * Exit the publicly available agents list.\\n     * NOTE: may only be called by the agent vault owner and after announcement.\\n     * @param _agentVault agent vault address\\n     */\\n    function exitAvailableAgentList(address _agentVault) external;\\n\\n    /**\\n     * Get (a part of) the list of available agents.\\n     * The list must be retrieved in parts since retrieving the whole list can consume too much gas for one block.\\n     * @param _start first index to return from the available agent's list\\n     * @param _end end index (one above last) to return from the available agent's list\\n     */\\n    function getAvailableAgentsList(\\n        uint256 _start,\\n        uint256 _end\\n    )\\n        external\\n        view\\n        returns (address[] memory _agentVaults, uint256 _totalLength);\\n\\n    /**\\n     * Get (a part of) the list of available agents with extra information about agents' fee, min collateral ratio\\n     * and available collateral (in lots).\\n     * The list must be retrieved in parts since retrieving the whole list can consume too much gas for one block.\\n     * NOTE: agent's available collateral can change anytime due to price changes, minting, or changes\\n     * in agent's min collateral ratio, so it is only to be used as an estimate.\\n     * @param _start first index to return from the available agent's list\\n     * @param _end end index (one above last) to return from the available agent's list\\n     */\\n    function getAvailableAgentsDetailedList(\\n        uint256 _start,\\n        uint256 _end\\n    )\\n        external\\n        view\\n        returns (\\n            AvailableAgentInfo.Data[] memory _agents,\\n            uint256 _totalLength\\n        );\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Minting\\n\\n    /**\\n     * Before paying underlying assets for minting, minter has to reserve collateral and\\n     * pay collateral reservation fee. Collateral is reserved at ratio of agent's agentMinCollateralRatio\\n     * to requested lots NAT market price.\\n     * The minter receives instructions for underlying payment\\n     * (value, fee and payment reference) in event CollateralReserved.\\n     * Then the minter has to pay `value + fee` on the underlying chain.\\n     * If the minter pays the underlying amount, minter obtains f-assets.\\n     * The collateral reservation fee is split between the agent and the collateral pool.\\n     * NOTE: the owner of the agent vault must be in the AgentOwnerRegistry.\\n     * @param _agentVault agent vault address\\n     * @param _lots the number of lots for which to reserve collateral\\n     * @param _maxMintingFeeBIPS maximum minting fee (BIPS) that can be charged by the agent - best is just to\\n     *      copy current agent's published fee; used to prevent agent from front-running reservation request\\n     *      and increasing fee (that would mean that the minter would have to pay raised fee or forfeit\\n     *      collateral reservation fee)\\n     * @param _executor the account that is allowed to execute minting (besides minter and agent)\\n     */\\n    function reserveCollateral(\\n        address _agentVault,\\n        uint256 _lots,\\n        uint256 _maxMintingFeeBIPS,\\n        address payable _executor\\n    ) external payable returns (uint256 _collateralReservationId);\\n\\n    /**\\n     * Return the collateral reservation fee amount that has to be passed to the `reserveCollateral` method.\\n     * NOTE: the amount paid may be larger than the required amount, but the difference is not returned.\\n     * It is advised that the minter pays the exact amount, but when the amount is so small that the revert\\n     * would cost more than the lost difference, the minter may want to send a slightly larger amount to compensate\\n     * for the possibility of a FTSO price change between obtaining this value and calling `reserveCollateral`.\\n     * @param _lots the number of lots for which to reserve collateral\\n     * @return _reservationFeeNATWei the amount of reservation fee in NAT wei\\n     */\\n    function collateralReservationFee(\\n        uint256 _lots\\n    ) external view returns (uint256 _reservationFeeNATWei);\\n\\n    /**\\n     * Returns the data about the collateral reservation for an ongoing minting.\\n     * Note: once the minting is executed or defaulted, the collateral reservation is deleted and this method fails.\\n     * @param _collateralReservationId the collateral reservation id, as used for executing or defaulting the minting\\n     */\\n    function collateralReservationInfo(\\n        uint256 _collateralReservationId\\n    ) external view returns (CollateralReservationInfo.Data memory);\\n\\n    /**\\n     * After obtaining proof of underlying payment, the minter calls this method to finish the minting\\n     * and collect the minted f-assets.\\n     * NOTE: may only be called by the minter (= creator of CR, the collateral reservation request),\\n     *   the executor appointed by the minter, or the agent owner (= owner of the agent vault in CR).\\n     * @param _payment proof of the underlying payment (must contain exact `value + fee` amount and correct\\n     *      payment reference)\\n     * @param _collateralReservationId collateral reservation id\\n     */\\n    function executeMinting(\\n        IPayment.Proof calldata _payment,\\n        uint256 _collateralReservationId\\n    ) external;\\n\\n    /**\\n     * When the time for the minter to pay the underlying amount is over (i.e. the last underlying block has passed),\\n     * the agent can declare payment default. Then the agent collects the collateral reservation fee\\n     * (it goes directly to the vault), and the reserved collateral is unlocked.\\n     * NOTE: The attestation request must be done with `checkSourceAddresses=false`.\\n     * NOTE: may only be called by the owner of the agent vault in the collateral reservation request.\\n     * @param _proof proof that the minter didn't pay with correct payment reference on the underlying chain\\n     * @param _collateralReservationId id of a collateral reservation created by the minter\\n     */\\n    function mintingPaymentDefault(\\n        IReferencedPaymentNonexistence.Proof calldata _proof,\\n        uint256 _collateralReservationId\\n    ) external;\\n\\n    /**\\n     * If a collateral reservation request exists for more than 24 hours, payment or non-payment proof are no longer\\n     * available. In this case the agent can call this method, which burns reserved collateral at market price\\n     * and releases the remaining collateral (CRF is also burned).\\n     * NOTE: may only be called by the owner of the agent vault in the collateral reservation request.\\n     * NOTE: the agent (management address) receives the vault collateral and NAT is burned instead. Therefore\\n     *      this method is `payable` and the caller must provide enough NAT to cover the received vault collateral\\n     *      amount multiplied by `vaultCollateralBuyForFlareFactorBIPS`.\\n     * @param _proof proof that the attestation query window can not not contain\\n     *      the payment/non-payment proof anymore\\n     * @param _collateralReservationId collateral reservation id\\n     */\\n    function unstickMinting(\\n        IConfirmedBlockHeightExists.Proof calldata _proof,\\n        uint256 _collateralReservationId\\n    ) external payable;\\n\\n    /**\\n     * Agent can mint against himself.\\n     * This is a one-step process, skipping collateral reservation and collateral reservation fee payment.\\n     * Moreover, the agent doesn't have to be on the publicly available agents list to self-mint.\\n     * NOTE: may only be called by the agent vault owner.\\n     * NOTE: the caller must be a whitelisted agent.\\n     * @param _payment proof of the underlying payment; must contain payment reference of the form\\n     *      `0x4642505266410012000...0<agent_vault_address>`\\n     * @param _agentVault agent vault address\\n     * @param _lots number of lots to mint\\n     */\\n    function selfMint(\\n        IPayment.Proof calldata _payment,\\n        address _agentVault,\\n        uint256 _lots\\n    ) external;\\n\\n    /**\\n     * If an agent has enough free underlying, they can mint immediately without any underlying payment.\\n     * This is a one-step process, skipping collateral reservation and collateral reservation fee payment.\\n     * Moreover, the agent doesn't have to be on the publicly available agents list to self-mint.\\n     * NOTE: may only be called by the agent vault owner.\\n     * NOTE: the caller must be a whitelisted agent.\\n     * @param _agentVault agent vault address\\n     * @param _lots number of lots to mint\\n     */\\n    function mintFromFreeUnderlying(address _agentVault, uint64 _lots) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Redemption\\n\\n    /**\\n     * Redeem (up to) `_lots` lots of f-assets. The corresponding amount of the f-assets belonging\\n     * to the redeemer will be burned and the redeemer will get paid by the agent in underlying currency\\n     * (or, in case of agent's payment default, by agent's collateral with a premium).\\n     * NOTE: in some cases not all sent f-assets can be redeemed (either there are not enough tickets or\\n     * more than a fixed limit of tickets should be redeemed). In this case only part of the approved assets\\n     * are burned and redeemed and the redeemer can execute this method again for the remaining lots.\\n     * In such a case the `RedemptionRequestIncomplete` event will be emitted, indicating the number\\n     * of remaining lots.\\n     * Agent receives redemption request id and instructions for underlying payment in\\n     * RedemptionRequested event and has to pay `value - fee` and use the provided payment reference.\\n     * @param _lots number of lots to redeem\\n     * @param _redeemerUnderlyingAddressString the address to which the agent must transfer underlying amount\\n     * @param _executor the account that is allowed to execute redemption default (besides redeemer and agent)\\n     * @return _redeemedAmountUBA the actual redeemed amount; may be less than requested if there are not enough\\n     *      redemption tickets available or the maximum redemption ticket limit is reached\\n     */\\n    function redeem(\\n        uint256 _lots,\\n        string memory _redeemerUnderlyingAddressString,\\n        address payable _executor\\n    ) external payable returns (uint256 _redeemedAmountUBA);\\n\\n    /**\\n     * If the redeemer provides invalid address, the agent should provide the proof of address invalidity from the\\n     * Flare data connector. With this, the agent's obligations are fulfilled and they can keep the underlying.\\n     * NOTE: may only be called by the owner of the agent vault in the redemption request\\n     * NOTE: also checks that redeemer's address is normalized, so the redeemer must normalize their address,\\n     *   otherwise it will be rejected!\\n     * @param _proof proof that the address is invalid\\n     * @param _redemptionRequestId id of an existing redemption request\\n     */\\n    function rejectInvalidRedemption(\\n        IAddressValidity.Proof calldata _proof,\\n        uint256 _redemptionRequestId\\n    ) external;\\n\\n    /**\\n     * After paying to the redeemer, the agent must call this method to unlock the collateral\\n     * and to make sure that the redeemer cannot demand payment in collateral on timeout.\\n     * The same method must be called for any payment status (SUCCESS, FAILED, BLOCKED).\\n     * In case of FAILED, it just releases the agent's underlying funds and the redeemer gets paid in collateral\\n     * after calling redemptionPaymentDefault.\\n     * In case of SUCCESS or BLOCKED, remaining underlying funds and collateral are released to the agent.\\n     * If the agent doesn't confirm payment in enough time (several hours, setting\\n     * `confirmationByOthersAfterSeconds`), anybody can do it and get rewarded from the agent's vault.\\n     * NOTE: may only be called by the owner of the agent vault in the redemption request\\n     *   except if enough time has passed without confirmation - then it can be called by anybody\\n     * @param _payment proof of the underlying payment (must contain exact `value - fee` amount and correct\\n     *      payment reference)\\n     * @param _redemptionRequestId id of an existing redemption request\\n     */\\n    function confirmRedemptionPayment(\\n        IPayment.Proof calldata _payment,\\n        uint256 _redemptionRequestId\\n    ) external;\\n\\n    /**\\n     * If the agent doesn't transfer the redeemed underlying assets in time (until the last allowed block on\\n     * the underlying chain), the redeemer calls this method and receives payment in collateral (with some extra).\\n     * The agent can also call default if the redeemer is unresponsive, to payout the redeemer and free the\\n     * remaining collateral.\\n     * NOTE: The attestation request must be done with `checkSourceAddresses=false`.\\n     * NOTE: may only be called by the redeemer (= creator of the redemption request),\\n     *   the executor appointed by the redeemer,\\n     *   or the agent owner (= owner of the agent vault in the redemption request)\\n     * @param _proof proof that the agent didn't pay with correct payment reference on the underlying chain\\n     * @param _redemptionRequestId id of an existing redemption request\\n     */\\n    function redemptionPaymentDefault(\\n        IReferencedPaymentNonexistence.Proof calldata _proof,\\n        uint256 _redemptionRequestId\\n    ) external;\\n\\n    /**\\n     * If the agent hasn't performed the payment, the agent can close the redemption request to free underlying funds.\\n     * It can be done immediately after the redeemer or agent calls `redemptionPaymentDefault`,\\n     * or this method can trigger the default payment without proof, but only after enough time has passed so that\\n     * attestation proof of non-payment is not available any more.\\n     * NOTE: may only be called by the owner of the agent vault in the redemption request.\\n     * @param _proof proof that the attestation query window can not not contain\\n     *      the payment/non-payment proof anymore\\n     * @param _redemptionRequestId id of an existing, but already defaulted, redemption request\\n     */\\n    function finishRedemptionWithoutPayment(\\n        IConfirmedBlockHeightExists.Proof calldata _proof,\\n        uint256 _redemptionRequestId\\n    ) external;\\n\\n    /**\\n     * Returns the data about an ongoing redemption request.\\n     * Note: once the redemptions is confirmed, the request is deleted and this method fails.\\n     * However, if there is no payment and the redemption defaults, the method works and returns status DEFAULTED.\\n     * @param _redemptionRequestId the redemption request id, as used for confirming or defaulting the redemption\\n     */\\n    function redemptionRequestInfo(\\n        uint256 _redemptionRequestId\\n    ) external view returns (RedemptionRequestInfo.Data memory);\\n\\n    /**\\n     * Agent can \\\"redeem against himself\\\" by calling `selfClose`, which burns agent's own f-assets\\n     * and unlocks agent's collateral. The underlying funds backing the f-assets are released\\n     * as agent's free underlying funds and can be later withdrawn after announcement.\\n     * NOTE: may only be called by the agent vault owner.\\n     * @param _agentVault agent vault address\\n     * @param _amountUBA amount of f-assets to self-close\\n     * @return _closedAmountUBA the actual self-closed amount, may be less than requested if there are not enough\\n     *      redemption tickets available or the maximum redemption ticket limit is reached\\n     */\\n    function selfClose(\\n        address _agentVault,\\n        uint256 _amountUBA\\n    ) external returns (uint256 _closedAmountUBA);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Redemption queue info\\n\\n    /**\\n     * Return (part of) the redemption queue.\\n     * @param _firstRedemptionTicketId the ticket id to start listing from; if 0, starts from the beginning\\n     * @param _pageSize the maximum number of redemption tickets to return\\n     * @return _queue the (part of) the redemption queue; maximum length is _pageSize\\n     * @return _nextRedemptionTicketId works as a cursor - if the _pageSize is reached and there are more tickets,\\n     *  it is the first ticket id not returned; if the end is reached, it is 0\\n     */\\n    function redemptionQueue(\\n        uint256 _firstRedemptionTicketId,\\n        uint256 _pageSize\\n    )\\n        external\\n        view\\n        returns (\\n            RedemptionTicketInfo.Data[] memory _queue,\\n            uint256 _nextRedemptionTicketId\\n        );\\n\\n    /**\\n     * Return (part of) the redemption queue for a specific agent.\\n     * @param _agentVault the agent vault address of the queried agent\\n     * @param _firstRedemptionTicketId the ticket id to start listing from; if 0, starts from the beginning\\n     * @param _pageSize the maximum number of redemption tickets to return\\n     * @return _queue the (part of) the redemption queue; maximum length is _pageSize\\n     * @return _nextRedemptionTicketId works as a cursor - if the _pageSize is reached and there are more tickets,\\n     *  it is the first ticket id not returned; if the end is reached, it is 0\\n     */\\n    function agentRedemptionQueue(\\n        address _agentVault,\\n        uint256 _firstRedemptionTicketId,\\n        uint256 _pageSize\\n    )\\n        external\\n        view\\n        returns (\\n            RedemptionTicketInfo.Data[] memory _queue,\\n            uint256 _nextRedemptionTicketId\\n        );\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Dust\\n\\n    /**\\n     * Due to the minting pool fees or after a lot size change by the governance,\\n     * it may happen that less than one lot remains on a redemption ticket. This is named \\\"dust\\\" and\\n     * can be self closed or liquidated, but not redeemed. However, after several additions,\\n     * the total dust can amount to more than one lot. Using this method, the amount, rounded down\\n     * to a whole number of lots, can be converted to a new redemption ticket.\\n     * NOTE: we do NOT check that the caller is the agent vault owner, since we want to\\n     * allow anyone to convert dust to tickets to increase asset fungibility.\\n     * NOTE: dust above 1 lot is actually added to ticket at every minting, so this function need\\n     * only be called when the agent doesn't have any minting.\\n     * @param _agentVault agent vault address\\n     */\\n    function convertDustToTicket(address _agentVault) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Liquidation\\n\\n    /**\\n     * Checks that the agent's collateral is too low and if true, starts agent's liquidation.\\n     * If the agent is already in liquidation, returns the timestamp when liquidation started.\\n     * @param _agentVault agent vault address\\n     * @return _liquidationStartTs timestamp when liquidation started\\n     */\\n    function startLiquidation(\\n        address _agentVault\\n    ) external returns (uint256 _liquidationStartTs);\\n\\n    /**\\n     * Burns up to `_amountUBA` f-assets owned by the caller and pays\\n     * the caller the corresponding amount of native currency with premium\\n     * (premium depends on the liquidation state).\\n     * If the agent isn't in liquidation yet, but satisfies conditions,\\n     * automatically puts the agent in liquidation status.\\n     * @param _agentVault agent vault address\\n     * @param _amountUBA the amount of f-assets to liquidate\\n     * @return _liquidatedAmountUBA liquidated amount of f-asset\\n     * @return _amountPaidVault amount paid to liquidator (in agent's vault collateral)\\n     * @return _amountPaidPool amount paid to liquidator (in NAT from pool)\\n     */\\n    function liquidate(\\n        address _agentVault,\\n        uint256 _amountUBA\\n    )\\n        external\\n        returns (\\n            uint256 _liquidatedAmountUBA,\\n            uint256 _amountPaidVault,\\n            uint256 _amountPaidPool\\n        );\\n\\n    /**\\n     * When the agent's collateral reaches the safe level during liquidation, the liquidation\\n     * process can be stopped by calling this method.\\n     * Full liquidation (i.e. the liquidation triggered by illegal underlying payment)\\n     * cannot be stopped.\\n     * NOTE: anybody can call.\\n     * NOTE: if the method succeeds, the agent's liquidation has ended.\\n     * @param _agentVault agent vault address\\n     */\\n    function endLiquidation(address _agentVault) external;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    // Challenges\\n\\n    /**\\n     * Called with a proof of payment made from the agent's underlying address, for which\\n     * no valid payment reference exists (valid payment references are from redemption and\\n     * underlying withdrawal announcement calls).\\n     * On success, immediately triggers full agent liquidation and rewards the caller.\\n     * @param _payment proof of a transaction from the agent's underlying address\\n     * @param _agentVault agent vault address\\n     */\\n    function illegalPaymentChallenge(\\n        IBalanceDecreasingTransaction.Proof calldata _payment,\\n        address _agentVault\\n    ) external;\\n\\n    /**\\n     * Called with proofs of two payments made from the agent's underlying address\\n     * with the same payment reference (each payment reference is valid for only one payment).\\n     * On success, immediately triggers full agent liquidation and rewards the caller.\\n     * @param _payment1 proof of first payment from the agent's underlying address\\n     * @param _payment2 proof of second payment from the agent's underlying address\\n     * @param _agentVault agent vault address\\n     */\\n    function doublePaymentChallenge(\\n        IBalanceDecreasingTransaction.Proof calldata _payment1,\\n        IBalanceDecreasingTransaction.Proof calldata _payment2,\\n        address _agentVault\\n    ) external;\\n\\n    /**\\n     * Called with proofs of several (otherwise legal) payments, which together make the agent's\\n     * underlying free balance negative (i.e. the underlying address balance is less than\\n     * the total amount of backed f-assets).\\n     * On success, immediately triggers full agent liquidation and rewards the caller.\\n     * @param _payments proofs of several distinct payments from the agent's underlying address\\n     * @param _agentVault agent vault address\\n     */\\n    function freeBalanceNegativeChallenge(\\n        IBalanceDecreasingTransaction.Proof[] calldata _payments,\\n        address _agentVault\\n    ) external;\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/genesis/interfaces/IFtsoGenesis.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtsoGenesis {\\n    /**\\n     * @notice Reveals submitted price during epoch reveal period - only price submitter\\n     * @param _voter                Voter address\\n     * @param _epochId              Id of the epoch in which the price hash was submitted\\n     * @param _price                Submitted price in USD\\n     * @notice The hash of _price and _random must be equal to the submitted hash\\n     * @notice Emits PriceRevealed event\\n     */\\n    function revealPriceSubmitter(\\n        address _voter,\\n        uint256 _epochId,\\n        uint256 _price,\\n        uint256 _wNatVP\\n    ) external;\\n\\n    /**\\n     * @notice Get (and cache) wNat vote power for specified voter and given epoch id\\n     * @param _voter                Voter address\\n     * @param _epochId              Id of the epoch in which the price hash was submitted\\n     * @return wNat vote power\\n     */\\n    function wNatVotePowerCached(\\n        address _voter,\\n        uint256 _epochId\\n    ) external returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/genesis/interfaces/IFtsoRegistryGenesis.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IFtsoGenesis.sol\\\";\\n\\ninterface IFtsoRegistryGenesis {\\n    function getFtsos(\\n        uint256[] memory _indices\\n    ) external view returns (IFtsoGenesis[] memory _ftsos);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/genesis/interfaces/IFtsoManagerGenesis.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtsoManagerGenesis {\\n    function getCurrentPriceEpochId()\\n        external\\n        view\\n        returns (uint256 _priceEpochId);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPriceSubmitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./genesis/interfaces/IFtsoGenesis.sol\\\";\\nimport \\\"./genesis/interfaces/IFtsoRegistryGenesis.sol\\\";\\nimport \\\"./genesis/interfaces/IFtsoManagerGenesis.sol\\\";\\n\\ninterface IPriceSubmitter {\\n    /**\\n     * Event emitted when hash was submitted through PriceSubmitter.\\n     * @param submitter the address of the sender\\n     * @param epochId current price epoch id\\n     * @param hash the submitted hash\\n     * @param timestamp current block timestamp\\n     */\\n    event HashSubmitted(\\n        address indexed submitter,\\n        uint256 indexed epochId,\\n        bytes32 hash,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * Event emitted when prices were revealed through PriceSubmitter.\\n     * @param voter the address of the sender\\n     * @param epochId id of the epoch in which the price hash was submitted\\n     * @param ftsos array of ftsos that correspond to the indexes in the call\\n     * @param prices the submitted prices\\n     * @param timestamp current block timestamp\\n     */\\n    event PricesRevealed(\\n        address indexed voter,\\n        uint256 indexed epochId,\\n        IFtsoGenesis[] ftsos,\\n        uint256[] prices,\\n        uint256 random,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Submits hash for current epoch\\n     * @param _epochId              Target epoch id to which hash is submitted\\n     * @param _hash                 Hash of ftso indices, prices, random number and voter address\\n     * @notice Emits HashSubmitted event\\n     */\\n    function submitHash(uint256 _epochId, bytes32 _hash) external;\\n\\n    /**\\n     * @notice Reveals submitted prices during epoch reveal period\\n     * @param _epochId              Id of the epoch in which the price hashes was submitted\\n     * @param _ftsoIndices          List of increasing ftso indices\\n     * @param _prices               List of submitted prices in USD\\n     * @param _random               Submitted random number\\n     * @notice The hash of ftso indices, prices, random number and voter address must be equal to the submitted hash\\n     * @notice Emits PricesRevealed event\\n     */\\n    function revealPrices(\\n        uint256 _epochId,\\n        uint256[] memory _ftsoIndices,\\n        uint256[] memory _prices,\\n        uint256 _random\\n    ) external;\\n\\n    /**\\n     * Returns bitmap of all ftso's for which `_voter` is allowed to submit prices/hashes.\\n     * If voter is allowed to vote for ftso at index (see *_FTSO_INDEX), the corrsponding\\n     * bit in the result will be 1.\\n     */\\n    function voterWhitelistBitmap(\\n        address _voter\\n    ) external view returns (uint256);\\n\\n    function getVoterWhitelister() external view returns (address);\\n    function getFtsoRegistry() external view returns (IFtsoRegistryGenesis);\\n    function getFtsoManager() external view returns (IFtsoManagerGenesis);\\n\\n    /**\\n     * @notice Returns current random number\\n     */\\n    function getCurrentRandom() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns random number of the specified epoch\\n     * @param _epochId              Id of the epoch\\n     */\\n    function getRandom(uint256 _epochId) external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtso.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtso {\\n    enum PriceFinalizationType {\\n        // initial state\\n        NOT_FINALIZED,\\n        // median calculation used to find price\\n        WEIGHTED_MEDIAN,\\n        // low turnout - price calculated from median of trusted addresses\\n        TRUSTED_ADDRESSES,\\n        // low turnout + no votes from trusted addresses - price copied from previous epoch\\n        PREVIOUS_PRICE_COPIED,\\n        // price calculated from median of trusted addresses - triggered due to an exception\\n        TRUSTED_ADDRESSES_EXCEPTION,\\n        // previous price copied - triggered due to an exception\\n        PREVIOUS_PRICE_COPIED_EXCEPTION\\n    }\\n\\n    event PriceRevealed(\\n        address indexed voter,\\n        uint256 indexed epochId,\\n        uint256 price,\\n        uint256 timestamp,\\n        uint256 votePowerNat,\\n        uint256 votePowerAsset\\n    );\\n\\n    event PriceFinalized(\\n        uint256 indexed epochId,\\n        uint256 price,\\n        bool rewardedFtso,\\n        uint256 lowIQRRewardPrice,\\n        uint256 highIQRRewardPrice,\\n        uint256 lowElasticBandRewardPrice,\\n        uint256 highElasticBandRewardPrice,\\n        PriceFinalizationType finalizationType,\\n        uint256 timestamp\\n    );\\n\\n    event PriceEpochInitializedOnFtso(\\n        uint256 indexed epochId,\\n        uint256 endTime,\\n        uint256 timestamp\\n    );\\n\\n    event LowTurnout(\\n        uint256 indexed epochId,\\n        uint256 natTurnout,\\n        uint256 lowNatTurnoutThresholdBIPS,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Returns if FTSO is active\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * @notice Returns the FTSO symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns current epoch id\\n     */\\n    function getCurrentEpochId() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns id of the epoch which was opened for price submission at the specified timestamp\\n     * @param _timestamp            Timestamp as seconds from unix epoch\\n     */\\n    function getEpochId(uint256 _timestamp) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns random number of the specified epoch\\n     * @param _epochId              Id of the epoch\\n     */\\n    function getRandom(uint256 _epochId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns asset price consented in specific epoch\\n     * @param _epochId              Id of the epoch\\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     */\\n    function getEpochPrice(uint256 _epochId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns current epoch data\\n     * @return _epochId                 Current epoch id\\n     * @return _epochSubmitEndTime      End time of the current epoch price submission as seconds from unix epoch\\n     * @return _epochRevealEndTime      End time of the current epoch price reveal as seconds from unix epoch\\n     * @return _votePowerBlock          Vote power block for the current epoch\\n     * @return _fallbackMode            Current epoch in fallback mode - only votes from trusted addresses will be used\\n     * @dev half-closed intervals - end time not included\\n     */\\n    function getPriceEpochData()\\n        external\\n        view\\n        returns (\\n            uint256 _epochId,\\n            uint256 _epochSubmitEndTime,\\n            uint256 _epochRevealEndTime,\\n            uint256 _votePowerBlock,\\n            bool _fallbackMode\\n        );\\n\\n    /**\\n     * @notice Returns current epoch data\\n     * @return _firstEpochStartTs           First epoch start timestamp\\n     * @return _submitPeriodSeconds         Submit period in seconds\\n     * @return _revealPeriodSeconds         Reveal period in seconds\\n     */\\n    function getPriceEpochConfiguration()\\n        external\\n        view\\n        returns (\\n            uint256 _firstEpochStartTs,\\n            uint256 _submitPeriodSeconds,\\n            uint256 _revealPeriodSeconds\\n        );\\n\\n    /**\\n     * @notice Returns asset price submitted by voter in specific epoch\\n     * @param _epochId              Id of the epoch\\n     * @param _voter                Address of the voter\\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     */\\n    function getEpochPriceForVoter(\\n        uint256 _epochId,\\n        address _voter\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns current asset price\\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp           Time when price was updated for the last time\\n     */\\n    function getCurrentPrice()\\n        external\\n        view\\n        returns (uint256 _price, uint256 _timestamp);\\n\\n    /**\\n     * @notice Returns current asset price and number of decimals\\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp               Time when price was updated for the last time\\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\\n     */\\n    function getCurrentPriceWithDecimals()\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _timestamp,\\n            uint256 _assetPriceUsdDecimals\\n        );\\n\\n    /**\\n     * @notice Returns current asset price calculated from trusted providers\\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp           Time when price was updated for the last time\\n     */\\n    function getCurrentPriceFromTrustedProviders()\\n        external\\n        view\\n        returns (uint256 _price, uint256 _timestamp);\\n\\n    /**\\n     * @notice Returns current asset price calculated from trusted providers and number of decimals\\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp               Time when price was updated for the last time\\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\\n     */\\n    function getCurrentPriceWithDecimalsFromTrustedProviders()\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _timestamp,\\n            uint256 _assetPriceUsdDecimals\\n        );\\n\\n    /**\\n     * @notice Returns current asset price details\\n     * @return _price                                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _priceTimestamp                          Time when price was updated for the last time\\n     * @return _priceFinalizationType                   Finalization type when price was updated for the last time\\n     * @return _lastPriceEpochFinalizationTimestamp     Time when last price epoch was finalized\\n     * @return _lastPriceEpochFinalizationType          Finalization type of last finalized price epoch\\n     */\\n    function getCurrentPriceDetails()\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _priceTimestamp,\\n            PriceFinalizationType _priceFinalizationType,\\n            uint256 _lastPriceEpochFinalizationTimestamp,\\n            PriceFinalizationType _lastPriceEpochFinalizationType\\n        );\\n\\n    /**\\n     * @notice Returns current random number\\n     */\\n    function getCurrentRandom() external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IGovernanceVotePower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Interface for contracts delegating their governance vote power.\\n */\\ninterface IGovernanceVotePower {\\n    /**\\n     * Delegates all governance vote power of `msg.sender` to address `_to`.\\n     * @param _to The address of the recipient.\\n     */\\n    function delegate(address _to) external;\\n\\n    /**\\n     * Undelegates all governance vote power of `msg.sender`.\\n     */\\n    function undelegate() external;\\n\\n    /**\\n     * Gets the governance vote power of an address at a given block number, including\\n     * all delegations made to it.\\n     * @param _who The address being queried.\\n     * @param _blockNumber The block number at which to fetch the vote power.\\n     * @return Governance vote power of `_who` at `_blockNumber`.\\n     */\\n    function votePowerOfAt(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Gets the governance vote power of an address at the latest block, including\\n     * all delegations made to it.\\n     * @param _who The address being queried.\\n     * @return Governance vote power of `account` at the lastest block.\\n     */\\n    function getVotes(address _who) external view returns (uint256);\\n\\n    /**\\n     * Gets the address an account is delegating its governance vote power to, at a given block number.\\n     * @param _who The address being queried.\\n     * @param _blockNumber The block number at which to fetch the address.\\n     * @return Address where `_who` was delegating its governance vote power at block `_blockNumber`.\\n     */\\n    function getDelegateOfAt(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external view returns (address);\\n\\n    /**\\n     * Gets the address an account is delegating its governance vote power to, at the latest block number.\\n     * @param _who The address being queried.\\n     * @return Address where `_who` is currently delegating its governance vote power.\\n     */\\n    function getDelegateOfAtNow(address _who) external view returns (address);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVPContractEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IVPContractEvents {\\n    /**\\n     * Event triggered when an account delegates or undelegates another account.\\n     * Definition: `votePowerFromTo(from, to)` is `changed` from `priorVotePower` to `newVotePower`.\\n     * For undelegation, `newVotePower` is 0.\\n     *\\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract`.\\n     */\\n    event Delegate(\\n        address indexed from,\\n        address indexed to,\\n        uint256 priorVotePower,\\n        uint256 newVotePower\\n    );\\n\\n    /**\\n     * Event triggered only when account `delegator` revokes delegation to `delegatee`\\n     * for a single block in the past (typically the current vote block).\\n     *\\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract` and/or `readVotePowerContract`.\\n     */\\n    event Revoke(\\n        address indexed delegator,\\n        address indexed delegatee,\\n        uint256 votePower,\\n        uint256 blockNumber\\n    );\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVPToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IGovernanceVotePower} from \\\"./IGovernanceVotePower.sol\\\";\\nimport {IVPContractEvents} from \\\"./IVPContractEvents.sol\\\";\\n\\ninterface IVPToken is IERC20 {\\n    /**\\n     * @notice Delegate by percentage `_bips` of voting power to `_to` from `msg.sender`.\\n     * @param _to The address of the recipient\\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\\n     **/\\n    function delegate(address _to, uint256 _bips) external;\\n\\n    /**\\n     * @notice Undelegate all percentage delegations from the sender and then delegate corresponding\\n     *   `_bips` percentage of voting power from the sender to each member of `_delegatees`.\\n     * @param _delegatees The addresses of the new recipients.\\n     * @param _bips The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Total of all `_bips` values must be at most 10000.\\n     **/\\n    function batchDelegate(\\n        address[] memory _delegatees,\\n        uint256[] memory _bips\\n    ) external;\\n\\n    /**\\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\\n     * @param _to The address of the recipient\\n     * @param _amount An explicit vote power amount to be delegated.\\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\\n     **/\\n    function delegateExplicit(address _to, uint _amount) external;\\n\\n    /**\\n     * @notice Revoke all delegation from sender to `_who` at given block.\\n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\\n     *    Block `_blockNumber` must be in the past.\\n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\\n     *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\\n     * @param _who Address of the delegatee\\n     * @param _blockNumber The block number at which to revoke delegation.\\n     */\\n    function revokeDelegationAt(address _who, uint _blockNumber) external;\\n\\n    /**\\n     * @notice Undelegate all voting power for delegates of `msg.sender`\\n     *    Can only be used with percentage delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     **/\\n    function undelegateAll() external;\\n\\n    /**\\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\\n     *    Can only be used with explicit delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses,\\n     *   so the caller must supply them.\\n     * @return The amount still delegated (in case the list of delegates was incomplete).\\n     */\\n    function undelegateAllExplicit(\\n        address[] memory _delegateAddresses\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Should be compatible with ERC20 method\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Should be compatible with ERC20 method\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Should be compatible with ERC20 method\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @notice Total amount of tokens at a specific `_blockNumber`.\\n     * @param _blockNumber The block number when the totalSupply is queried\\n     * @return The total amount of tokens at `_blockNumber`\\n     **/\\n    function totalSupplyAt(uint _blockNumber) external view returns (uint256);\\n\\n    /**\\n     * @dev Queries the token balance of `_owner` at a specific `_blockNumber`.\\n     * @param _owner The address from which the balance will be retrieved.\\n     * @param _blockNumber The block number when the balance is queried.\\n     * @return The balance at `_blockNumber`.\\n     **/\\n    function balanceOfAt(\\n        address _owner,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the current total vote power.\\n     * @return The current total vote power (sum of all accounts' vote powers).\\n     */\\n    function totalVotePower() external view returns (uint256);\\n\\n    /**\\n     * @notice Get the total vote power at block `_blockNumber`\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The total vote power at the block  (sum of all accounts' vote powers).\\n     */\\n    function totalVotePowerAt(\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the current vote power of `_owner`.\\n     * @param _owner The address to get voting power.\\n     * @return Current vote power of `_owner`.\\n     */\\n    function votePowerOf(address _owner) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_owner` at block `_blockNumber`\\n     * @param _owner The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_owner` at `_blockNumber`.\\n     */\\n    function votePowerOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_owner` at block `_blockNumber`, ignoring revocation information (and cache).\\n     * @param _owner The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_owner` at `_blockNumber`. Result doesn't change if vote power is revoked.\\n     */\\n    function votePowerOfAtIgnoringRevocation(\\n        address _owner,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\\n     *  allocated by percentage or by explicit value. Once the delegation mode is set,\\n     *  it never changes, even if all delegations are removed.\\n     * @param _who The address to get delegation mode.\\n     * @return delegation mode: 0 = NOTSET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)\\n     */\\n    function delegationModeOf(address _who) external view returns (uint256);\\n\\n    /**\\n     * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\\n     * @param _from Address of delegator\\n     * @param _to Address of delegatee\\n     * @return The delegated vote power.\\n     */\\n    function votePowerFromTo(\\n        address _from,\\n        address _to\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\\n     * @param _from Address of delegator\\n     * @param _to Address of delegatee\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The delegated vote power.\\n     */\\n    function votePowerFromToAt(\\n        address _from,\\n        address _to,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Compute the current undelegated vote power of `_owner`\\n     * @param _owner The address to get undelegated voting power.\\n     * @return The unallocated vote power of `_owner`\\n     */\\n    function undelegatedVotePowerOf(\\n        address _owner\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the undelegated vote power of `_owner` at given block.\\n     * @param _owner The address to get undelegated voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\\n     */\\n    function undelegatedVotePowerOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power delegation `delegationAddresses`\\n     *  and `_bips` of `_who`. Returned in two separate positional arrays.\\n     * @param _who The address to get delegations.\\n     * @return _delegateAddresses Positional array of delegation addresses.\\n     * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n     * @return _count The number of delegates.\\n     * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n     */\\n    function delegatesOf(\\n        address _who\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _delegateAddresses,\\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * @notice Get the vote power delegation `delegationAddresses`\\n     *  and `pcts` of `_who`. Returned in two separate positional arrays.\\n     * @param _who The address to get delegations.\\n     * @param _blockNumber The block for which we want to know the delegations.\\n     * @return _delegateAddresses Positional array of delegation addresses.\\n     * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n     * @return _count The number of delegates.\\n     * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n     */\\n    function delegatesOfAt(\\n        address _who,\\n        uint256 _blockNumber\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _delegateAddresses,\\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * Returns VPContract used for readonly operations (view methods).\\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\\n     *\\n     * @notice `readVotePowerContract` is almost always equal to `writeVotePowerContract`\\n     * except during upgrade from one VPContract to a new version (which should happen\\n     * rarely or never and will be anounced before).\\n     *\\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\\n     * via VPToken (and state changing methods are forbidden from direct calls).\\n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\\n     * for listening to events (`Revoke` only).\\n     */\\n    function readVotePowerContract() external view returns (IVPContractEvents);\\n\\n    /**\\n     * Returns VPContract used for state changing operations (non-view methods).\\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\\n     *\\n     * @notice `writeVotePowerContract` is almost always equal to `readVotePowerContract`\\n     * except during upgrade from one VPContract to a new version (which should happen\\n     * rarely or never and will be anounced before). In the case of upgrade,\\n     * `writeVotePowerContract` will be replaced first to establish delegations, and\\n     * after some perio (e.g. after a reward epoch ends) `readVotePowerContract` will be set equal to it.\\n     *\\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\\n     * via VPToken (and state changing methods are forbidden from direct calls).\\n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\\n     * for listening to events (`Delegate` and `Revoke` only).\\n     */\\n    function writeVotePowerContract() external view returns (IVPContractEvents);\\n\\n    /**\\n     * When set, allows token owners to participate in governance voting\\n     * and delegate governance vote power.\\n     */\\n    function governanceVotePower() external view returns (IGovernanceVotePower);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IICleanable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IICleanable {\\n    /**\\n     * Set the contract that is allowed to call history cleaning methods.\\n     */\\n    function setCleanerContract(address _cleanerContract) external;\\n\\n    /**\\n     * Set the cleanup block number.\\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased,\\n     * history before that block should never be used since it can be inconsistent.\\n     * In particular, cleanup block number must be before current vote power block.\\n     * @param _blockNumber The new cleanup block number.\\n     */\\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\\n\\n    /**\\n     * Get the current cleanup block number.\\n     */\\n    function cleanupBlockNumber() external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IIVPContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../IVPToken.sol\\\";\\nimport \\\"../../IVPContractEvents.sol\\\";\\nimport \\\"./IICleanable.sol\\\";\\n\\ninterface IIVPContract is IICleanable, IVPContractEvents {\\n    /**\\n     * Update vote powers when tokens are transfered.\\n     * Also update delegated vote powers for percentage delegation\\n     * and check for enough funds for explicit delegations.\\n     **/\\n    function updateAtTokenTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _fromBalance,\\n        uint256 _toBalance,\\n        uint256 _amount\\n    ) external;\\n\\n    /**\\n     * @notice Delegate `_bips` percentage of voting power to `_to` from `_from`\\n     * @param _from The address of the delegator\\n     * @param _to The address of the recipient\\n     * @param _balance The delegator's current balance\\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).\\n     **/\\n    function delegate(\\n        address _from,\\n        address _to,\\n        uint256 _balance,\\n        uint256 _bips\\n    ) external;\\n\\n    /**\\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\\n     * @param _from The address of the delegator\\n     * @param _to The address of the recipient\\n     * @param _balance The delegator's current balance\\n     * @param _amount An explicit vote power amount to be delegated.\\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\\n     **/\\n    function delegateExplicit(\\n        address _from,\\n        address _to,\\n        uint256 _balance,\\n        uint _amount\\n    ) external;\\n\\n    /**\\n     * @notice Revoke all delegation from sender to `_who` at given block.\\n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\\n     *    Block `_blockNumber` must be in the past.\\n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\\n     *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\\n     * @param _from The address of the delegator\\n     * @param _who Address of the delegatee\\n     * @param _balance The delegator's current balance\\n     * @param _blockNumber The block number at which to revoke delegation.\\n     **/\\n    function revokeDelegationAt(\\n        address _from,\\n        address _who,\\n        uint256 _balance,\\n        uint _blockNumber\\n    ) external;\\n\\n    /**\\n     * @notice Undelegate all voting power for delegates of `msg.sender`\\n     *    Can only be used with percentage delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     * @param _from The address of the delegator\\n     **/\\n    function undelegateAll(address _from, uint256 _balance) external;\\n\\n    /**\\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\\n     *    Can only be used with explicit delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     * @param _from The address of the delegator\\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses,\\n     *   so the caller must supply them.\\n     * @return The amount still delegated (in case the list of delegates was incomplete).\\n     */\\n    function undelegateAllExplicit(\\n        address _from,\\n        address[] memory _delegateAddresses\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_who` at block `_blockNumber`\\n     *   Reads/updates cache and upholds revocations.\\n     * @param _who The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_who` at `_blockNumber`.\\n     */\\n    function votePowerOfAtCached(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Get the current vote power of `_who`.\\n     * @param _who The address to get voting power.\\n     * @return Current vote power of `_who`.\\n     */\\n    function votePowerOf(address _who) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_who` at block `_blockNumber`\\n     * @param _who The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_who` at `_blockNumber`.\\n     */\\n    function votePowerOfAt(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_who` at block `_blockNumber`, ignoring revocation information (and cache).\\n     * @param _who The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_who` at `_blockNumber`. Result doesn't change if vote power is revoked.\\n     */\\n    function votePowerOfAtIgnoringRevocation(\\n        address _who,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return vote powers for several addresses in a batch.\\n     * @param _owners The list of addresses to fetch vote power of.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return A list of vote powers.\\n     */\\n    function batchVotePowerOfAt(\\n        address[] memory _owners,\\n        uint256 _blockNumber\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\\n     * @param _from Address of delegator\\n     * @param _to Address of delegatee\\n     * @param _balance The delegator's current balance\\n     * @return The delegated vote power.\\n     */\\n    function votePowerFromTo(\\n        address _from,\\n        address _to,\\n        uint256 _balance\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\\n     * @param _from Address of delegator\\n     * @param _to Address of delegatee\\n     * @param _balance The delegator's current balance\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The delegated vote power.\\n     */\\n    function votePowerFromToAt(\\n        address _from,\\n        address _to,\\n        uint256 _balance,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Compute the current undelegated vote power of `_owner`\\n     * @param _owner The address to get undelegated voting power.\\n     * @param _balance Owner's current balance\\n     * @return The unallocated vote power of `_owner`\\n     */\\n    function undelegatedVotePowerOf(\\n        address _owner,\\n        uint256 _balance\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the undelegated vote power of `_owner` at given block.\\n     * @param _owner The address to get undelegated voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\\n     */\\n    function undelegatedVotePowerOfAt(\\n        address _owner,\\n        uint256 _balance,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\\n     *  allocated by percentage or by explicit value.\\n     * @param _who The address to get delegation mode.\\n     * @return Delegation mode (NOTSET=0, PERCENTAGE=1, AMOUNT=2))\\n     */\\n    function delegationModeOf(address _who) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power delegation `_delegateAddresses`\\n     *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\\n     * @param _owner The address to get delegations.\\n     * @return _delegateAddresses Positional array of delegation addresses.\\n     * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n     * @return _count The number of delegates.\\n     * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n     */\\n    function delegatesOf(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _delegateAddresses,\\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * @notice Get the vote power delegation `delegationAddresses`\\n     *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\\n     * @param _owner The address to get delegations.\\n     * @param _blockNumber The block for which we want to know the delegations.\\n     * @return _delegateAddresses Positional array of delegation addresses.\\n     * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n     * @return _count The number of delegates.\\n     * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n     */\\n    function delegatesOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _delegateAddresses,\\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * The VPToken (or some other contract) that owns this VPContract.\\n     * All state changing methods may be called only from this address.\\n     * This is because original msg.sender is sent in `_from` parameter\\n     * and we must be sure that it cannot be faked by directly calling VPContract.\\n     * Owner token is also used in case of replacement to recover vote powers from balances.\\n     */\\n    function ownerToken() external view returns (IVPToken);\\n\\n    /**\\n     * Return true if this IIVPContract is configured to be used as a replacement for other contract.\\n     * It means that vote powers are not necessarily correct at the initialization, therefore\\n     * every method that reads vote power must check whether it is initialized for that address and block.\\n     */\\n    function isReplacement() external view returns (bool);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainVotePower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Interface for the vote power part of the `PChainStakeMirror` contract.\\n */\\ninterface IPChainVotePower {\\n    /**\\n     * Event triggered when a stake is confirmed or at the time it ends.\\n     * Definition: `votePowerFromTo(owner, nodeId)` is `changed` from `priorVotePower` to `newVotePower`.\\n     * @param owner The account that has changed the amount of vote power it is staking.\\n     * @param nodeId The node id whose received vote power has changed.\\n     * @param priorVotePower The vote power originally on that node id.\\n     * @param newVotePower The new vote power that triggered this event.\\n     */\\n    event VotePowerChanged(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        uint256 priorVotePower,\\n        uint256 newVotePower\\n    );\\n\\n    /**\\n     * Emitted when a vote power cache entry is created.\\n     * Allows history cleaners to track vote power cache cleanup opportunities off-chain.\\n     * @param nodeId The node id whose vote power has just been cached.\\n     * @param blockNumber The block number at which the vote power has been cached.\\n     */\\n    event VotePowerCacheCreated(bytes20 nodeId, uint256 blockNumber);\\n\\n    /**\\n     * Get the vote power of `_owner` at block `_blockNumber` using cache.\\n     *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n     *   Can only be used if _blockNumber is in the past, otherwise reverts.\\n     * @param _owner The node id to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_owner` at `_blockNumber`.\\n     */\\n    function votePowerOfAtCached(\\n        bytes20 _owner,\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * Get the total vote power at block `_blockNumber` using cache.\\n     *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n     *   Can only be used if `_blockNumber` is in the past, otherwise reverts.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The total vote power at the block (sum of all accounts' vote powers).\\n     */\\n    function totalVotePowerAtCached(\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * Get the current total vote power.\\n     * @return The current total vote power (sum of all accounts' vote powers).\\n     */\\n    function totalVotePower() external view returns (uint256);\\n\\n    /**\\n     * Get the total vote power at block `_blockNumber`\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The total vote power at the block  (sum of all accounts' vote powers).\\n     */\\n    function totalVotePowerAt(\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get the amounts and node ids being staked to by a vote power owner.\\n     * @param _owner The address being queried.\\n     * @return _nodeIds Array of node ids.\\n     * @return _amounts Array of staked amounts, for each node id.\\n     */\\n    function stakesOf(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (bytes20[] memory _nodeIds, uint256[] memory _amounts);\\n\\n    /**\\n     * Get the amounts and node ids being staked to by a vote power owner,\\n     * at a given block.\\n     * @param _owner The address being queried.\\n     * @param _blockNumber The block number being queried.\\n     * @return _nodeIds Array of node ids.\\n     * @return _amounts Array of staked amounts, for each node id.\\n     */\\n    function stakesOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    )\\n        external\\n        view\\n        returns (bytes20[] memory _nodeIds, uint256[] memory _amounts);\\n\\n    /**\\n     * Get the current vote power of `_nodeId`.\\n     * @param _nodeId The node id to get voting power.\\n     * @return Current vote power of `_nodeId`.\\n     */\\n    function votePowerOf(bytes20 _nodeId) external view returns (uint256);\\n\\n    /**\\n     * Get the vote power of `_nodeId` at block `_blockNumber`\\n     * @param _nodeId The node id to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_nodeId` at `_blockNumber`.\\n     */\\n    function votePowerOfAt(\\n        bytes20 _nodeId,\\n        uint256 _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get current staked vote power from `_owner` staked to `_nodeId`.\\n     * @param _owner Address of vote power owner.\\n     * @param _nodeId Node id.\\n     * @return The staked vote power.\\n     */\\n    function votePowerFromTo(\\n        address _owner,\\n        bytes20 _nodeId\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get current staked vote power from `_owner` staked to `_nodeId` at `_blockNumber`.\\n     * @param _owner Address of vote power owner.\\n     * @param _nodeId Node id.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The staked vote power.\\n     */\\n    function votePowerFromToAt(\\n        address _owner,\\n        bytes20 _nodeId,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Return vote powers for several node ids in a batch.\\n     * @param _nodeIds The list of node ids to fetch vote power of.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return A list of vote powers.\\n     */\\n    function batchVotePowerOfAt(\\n        bytes20[] memory _nodeIds,\\n        uint256 _blockNumber\\n    ) external view returns (uint256[] memory);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainStakeMirrorVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\n/**\\n * Interface with structure for P-chain stake mirror verifications.\\n */\\ninterface IPChainStakeMirrorVerifier {\\n    /**\\n     * Structure describing the P-chain stake.\\n     */\\n    struct PChainStake {\\n        // Hash of the transaction on the underlying chain.\\n        bytes32 txId;\\n        // Type of the staking/delegation transaction: '0' for 'ADD_VALIDATOR_TX' and '1' for 'ADD_DELEGATOR_TX'.\\n        uint8 stakingType;\\n        // Input address that triggered the staking or delegation transaction.\\n        // See https://support.avax.network/en/articles/4596397-what-is-an-address for address definition for P-chain.\\n        bytes20 inputAddress;\\n        // NodeID to which staking or delegation is done.\\n        // For definitions, see https://github.com/ava-labs/avalanchego/blob/master/ids/node_id.go.\\n        bytes20 nodeId;\\n        // Start time of the staking/delegation in seconds (Unix epoch).\\n        uint64 startTime;\\n        // End time of the staking/delegation in seconds (Unix epoch).\\n        uint64 endTime;\\n        // Staked or delegated amount in Gwei (nano FLR).\\n        uint64 weight;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainStakeMirror.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\nimport \\\"./IPChainVotePower.sol\\\";\\nimport \\\"./IPChainStakeMirrorVerifier.sol\\\";\\n\\n/**\\n * Interface for the `PChainStakeMirror` contract.\\n */\\ninterface IPChainStakeMirror is IPChainVotePower {\\n    /**\\n     * Event emitted when max updates per block is set.\\n     * @param maxUpdatesPerBlock new number of max updated per block\\n     */\\n    event MaxUpdatesPerBlockSet(uint256 maxUpdatesPerBlock);\\n\\n    /**\\n     * Event emitted when the stake is confirmed.\\n     * @param owner The address who opened the stake.\\n     * @param nodeId Node id to which the stake was added.\\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\\n     * @param amountWei Stake amount (in wei).\\n     * @param pChainTxId P-chain transaction id.\\n     */\\n    event StakeConfirmed(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        bytes32 indexed txHash,\\n        uint256 amountWei,\\n        bytes32 pChainTxId\\n    );\\n\\n    /**\\n     * Event emitted when the stake has ended.\\n     * @param owner The address whose stake has ended.\\n     * @param nodeId Node id from which the stake was removed.\\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\\n     * @param amountWei Stake amount (in wei).\\n     */\\n    event StakeEnded(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        bytes32 indexed txHash,\\n        uint256 amountWei\\n    );\\n\\n    /**\\n     * Event emitted when the stake was revoked.\\n     * @param owner The address whose stake has ended.\\n     * @param nodeId Node id from which the stake was removed.\\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\\n     * @param amountWei Stake amount (in wei).\\n     */\\n    event StakeRevoked(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        bytes32 indexed txHash,\\n        uint256 amountWei\\n    );\\n\\n    /**\\n     * Method for P-chain stake mirroring using `PChainStake` data and Merkle proof.\\n     * @param _stakeData Information about P-chain stake.\\n     * @param _merkleProof Merkle proof that should be used to prove the P-chain stake.\\n     */\\n    function mirrorStake(\\n        IPChainStakeMirrorVerifier.PChainStake calldata _stakeData,\\n        bytes32[] calldata _merkleProof\\n    ) external;\\n\\n    /**\\n     * Method for checking if active stake (stake start time <= block.timestamp < stake end time) was already mirrored.\\n     * @param _txId P-chain stake transaction id.\\n     * @param _inputAddress P-chain address that opened stake.\\n     * @return True if stake is active and mirrored.\\n     */\\n    function isActiveStakeMirrored(\\n        bytes32 _txId,\\n        bytes20 _inputAddress\\n    ) external view returns (bool);\\n\\n    /**\\n     * Total amount of tokens at current block.\\n     * @return The current total amount of tokens.\\n     **/\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * Total amount of tokens at a specific `_blockNumber`.\\n     * @param _blockNumber The block number when the totalSupply is queried.\\n     * @return The total amount of tokens at `_blockNumber`.\\n     **/\\n    function totalSupplyAt(uint _blockNumber) external view returns (uint256);\\n\\n    /**\\n     * Queries the token balance of `_owner` at current block.\\n     * @param _owner The address from which the balance will be retrieved.\\n     * @return The current balance.\\n     **/\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /**\\n     * Queries the token balance of `_owner` at a specific `_blockNumber`.\\n     * @param _owner The address from which the balance will be retrieved.\\n     * @param _blockNumber The block number when the balance is queried.\\n     * @return The balance at `_blockNumber`.\\n     **/\\n    function balanceOfAt(\\n        address _owner,\\n        uint _blockNumber\\n    ) external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IIGovernanceVotePower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../IVPToken.sol\\\";\\nimport \\\"../../IPChainStakeMirror.sol\\\";\\nimport \\\"../../IGovernanceVotePower.sol\\\";\\n\\n/**\\n * Internal interface for contracts delegating their governance vote power.\\n */\\ninterface IIGovernanceVotePower is IGovernanceVotePower {\\n    /**\\n     * Emitted when a delegate's vote power changes, as a result of a new delegation\\n     * or a token transfer, for example.\\n     *\\n     * The event is always emitted from a `GovernanceVotePower` contract.\\n     * @param delegate The account receiving the changing delegated vote power.\\n     * @param previousBalance Delegated vote power before the change.\\n     * @param newBalance Delegated vote power after the change.\\n     */\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * Emitted when an account starts delegating vote power or switches its delegation\\n     * to another address.\\n     *\\n     * The event is always emitted from a `GovernanceVotePower` contract.\\n     * @param delegator Account delegating its vote power.\\n     * @param fromDelegate Account receiving the delegation before the change.\\n     * Can be address(0) if there was no previous delegation.\\n     * @param toDelegate Account receiving the delegation after the change.\\n     * Can be address(0) if `delegator` just undelegated all its vote power.\\n     */\\n    event DelegateChanged(\\n        address indexed delegator,\\n        address indexed fromDelegate,\\n        address indexed toDelegate\\n    );\\n\\n    /**\\n     * Update governance vote power of all involved delegates after tokens are transferred.\\n     *\\n     * This function **MUST** be called after each governance token transfer for the\\n     * delegates to reflect the correct balance.\\n     * @param _from Source address of the transfer.\\n     * @param _to Destination address of the transfer.\\n     * @param _fromBalance _Ignored._\\n     * @param _toBalance _Ignored._\\n     * @param _amount Amount being transferred.\\n     */\\n    function updateAtTokenTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _fromBalance,\\n        uint256 _toBalance,\\n        uint256 _amount\\n    ) external;\\n\\n    /**\\n     * Set the cleanup block number.\\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased.\\n     * History before that block should never be used since it can be inconsistent.\\n     * In particular, cleanup block number must be lower than the current vote power block.\\n     * @param _blockNumber The new cleanup block number.\\n     */\\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\\n\\n    /**\\n     * Set the contract that is allowed to call history cleaning methods.\\n     * @param _cleanerContract Address of the cleanup contract.\\n     * Usually this will be an instance of `CleanupBlockNumberManager`.\\n     */\\n    function setCleanerContract(address _cleanerContract) external;\\n\\n    /**\\n     * Get the token that this governance vote power contract belongs to.\\n     * @return The IVPToken interface owning this contract.\\n     */\\n    function ownerToken() external view returns (IVPToken);\\n\\n    /**\\n     * Get the stake mirror contract that this governance vote power contract belongs to.\\n     * @return The IPChainStakeMirror interface owning this contract.\\n     */\\n    function pChainStakeMirror() external view returns (IPChainStakeMirror);\\n\\n    /**\\n     * Get the current cleanup block number set with `setCleanupBlockNumber()`.\\n     * @return The currently set cleanup block number.\\n     */\\n    function getCleanupBlockNumber() external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IIVPToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../IVPToken.sol\\\";\\nimport \\\"../../IGovernanceVotePower.sol\\\";\\nimport \\\"./IIVPContract.sol\\\";\\nimport \\\"./IIGovernanceVotePower.sol\\\";\\nimport \\\"./IICleanable.sol\\\";\\n\\ninterface IIVPToken is IVPToken, IICleanable {\\n    /**\\n     * Set the contract that is allowed to set cleanupBlockNumber.\\n     * Usually this will be an instance of CleanupBlockNumberManager.\\n     */\\n    function setCleanupBlockNumberManager(\\n        address _cleanupBlockNumberManager\\n    ) external;\\n\\n    /**\\n     * Sets new governance vote power contract that allows token owners to participate in governance voting\\n     * and delegate governance vote power.\\n     */\\n    function setGovernanceVotePower(\\n        IIGovernanceVotePower _governanceVotePower\\n    ) external;\\n\\n    /**\\n     * @notice Get the total vote power at block `_blockNumber` using cache.\\n     *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n     *   Can only be used if `_blockNumber` is in the past, otherwise reverts.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The total vote power at the block (sum of all accounts' vote powers).\\n     */\\n    function totalVotePowerAtCached(\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Get the vote power of `_owner` at block `_blockNumber` using cache.\\n     *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n     *   Can only be used if _blockNumber is in the past, otherwise reverts.\\n     * @param _owner The address to get voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return Vote power of `_owner` at `_blockNumber`.\\n     */\\n    function votePowerOfAtCached(\\n        address _owner,\\n        uint256 _blockNumber\\n    ) external returns (uint256);\\n\\n    /**\\n     * Return vote powers for several addresses in a batch.\\n     * @param _owners The list of addresses to fetch vote power of.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return A list of vote powers.\\n     */\\n    function batchVotePowerOfAt(\\n        address[] memory _owners,\\n        uint256 _blockNumber\\n    ) external view returns (uint256[] memory);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/ftso/interfaces/IIFtso.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../genesis/interfaces/IFtsoGenesis.sol\\\";\\nimport \\\"../../IFtso.sol\\\";\\nimport \\\"../../token/interfaces/IIVPToken.sol\\\";\\n\\ninterface IIFtso is IFtso, IFtsoGenesis {\\n    /// function finalizePriceReveal\\n    /// called by reward manager only on correct timing.\\n    /// if price reveal period for epoch x ended. finalize.\\n    /// iterate list of price submissions\\n    /// find weighted median\\n    /// find adjucant 50% of price submissions.\\n    /// Allocate reward for any price submission which is same as a \\\"winning\\\" submission\\n    function finalizePriceEpoch(\\n        uint256 _epochId,\\n        bool _returnRewardData\\n    )\\n        external\\n        returns (\\n            address[] memory _eligibleAddresses,\\n            uint256[] memory _natWeights,\\n            uint256 _totalNatWeight\\n        );\\n\\n    function fallbackFinalizePriceEpoch(uint256 _epochId) external;\\n\\n    function forceFinalizePriceEpoch(uint256 _epochId) external;\\n\\n    // activateFtso will be called by ftso manager once ftso is added\\n    // before this is done, FTSO can't run\\n    function activateFtso(\\n        uint256 _firstEpochStartTs,\\n        uint256 _submitPeriodSeconds,\\n        uint256 _revealPeriodSeconds\\n    ) external;\\n\\n    function deactivateFtso() external;\\n\\n    // update initial price and timestamp - only if not active\\n    function updateInitialPrice(\\n        uint256 _initialPriceUSD,\\n        uint256 _initialPriceTimestamp\\n    ) external;\\n\\n    function configureEpochs(\\n        uint256 _maxVotePowerNatThresholdFraction,\\n        uint256 _maxVotePowerAssetThresholdFraction,\\n        uint256 _lowAssetUSDThreshold,\\n        uint256 _highAssetUSDThreshold,\\n        uint256 _highAssetTurnoutThresholdBIPS,\\n        uint256 _lowNatTurnoutThresholdBIPS,\\n        uint256 _elasticBandRewardBIPS,\\n        uint256 _elasticBandWidthPPM,\\n        address[] memory _trustedAddresses\\n    ) external;\\n\\n    function setAsset(IIVPToken _asset) external;\\n\\n    function setAssetFtsos(IIFtso[] memory _assetFtsos) external;\\n\\n    // current vote power block will update per reward epoch.\\n    // the FTSO doesn't have notion of reward epochs.\\n    // reward manager only can set this data.\\n    function setVotePowerBlock(uint256 _blockNumber) external;\\n\\n    function initializeCurrentEpochStateForReveal(\\n        uint256 _circulatingSupplyNat,\\n        bool _fallbackMode\\n    ) external;\\n\\n    /**\\n     * @notice Returns ftso manager address\\n     */\\n    function ftsoManager() external view returns (address);\\n\\n    /**\\n     * @notice Returns the FTSO asset\\n     * @dev Asset is null in case of multi-asset FTSO\\n     */\\n    function getAsset() external view returns (IIVPToken);\\n\\n    /**\\n     * @notice Returns the Asset FTSOs\\n     * @dev AssetFtsos is not null only in case of multi-asset FTSO\\n     */\\n    function getAssetFtsos() external view returns (IIFtso[] memory);\\n\\n    /**\\n     * @notice Returns current configuration of epoch state\\n     * @return _maxVotePowerNatThresholdFraction        High threshold for native token vote power per voter\\n     * @return _maxVotePowerAssetThresholdFraction      High threshold for asset vote power per voter\\n     * @return _lowAssetUSDThreshold            Threshold for low asset vote power\\n     * @return _highAssetUSDThreshold           Threshold for high asset vote power\\n     * @return _highAssetTurnoutThresholdBIPS   Threshold for high asset turnout\\n     * @return _lowNatTurnoutThresholdBIPS      Threshold for low nat turnout\\n     * @return _elasticBandRewardBIPS           Hybrid reward band, where _elasticBandRewardBIPS goes to the \\n        elastic band (prices within _elasticBandWidthPPM of the median) \\n        and 10000 - elasticBandRewardBIPS to the IQR \\n     * @return _elasticBandWidthPPM             Prices within _elasticBandWidthPPM of median are rewarded\\n     * @return _trustedAddresses                Trusted addresses - use their prices if low nat turnout is not achieved\\n     */\\n    function epochsConfiguration()\\n        external\\n        view\\n        returns (\\n            uint256 _maxVotePowerNatThresholdFraction,\\n            uint256 _maxVotePowerAssetThresholdFraction,\\n            uint256 _lowAssetUSDThreshold,\\n            uint256 _highAssetUSDThreshold,\\n            uint256 _highAssetTurnoutThresholdBIPS,\\n            uint256 _lowNatTurnoutThresholdBIPS,\\n            uint256 _elasticBandRewardBIPS,\\n            uint256 _elasticBandWidthPPM,\\n            address[] memory _trustedAddresses\\n        );\\n\\n    /**\\n     * @notice Returns parameters necessary for approximately replicating vote weighting.\\n     * @return _assets                  the list of Assets that are accounted in vote\\n     * @return _assetMultipliers        weight of each asset in (multiasset) ftso, mutiplied by TERA\\n     * @return _totalVotePowerNat       total native token vote power at block\\n     * @return _totalVotePowerAsset     total combined asset vote power at block\\n     * @return _assetWeightRatio        ratio of combined asset vp vs. native token vp (in BIPS)\\n     * @return _votePowerBlock          vote powewr block for given epoch\\n     */\\n    function getVoteWeightingParameters()\\n        external\\n        view\\n        returns (\\n            IIVPToken[] memory _assets,\\n            uint256[] memory _assetMultipliers,\\n            uint256 _totalVotePowerNat,\\n            uint256 _totalVotePowerAsset,\\n            uint256 _assetWeightRatio,\\n            uint256 _votePowerBlock\\n        );\\n\\n    function wNat() external view returns (IIVPToken);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\nimport \\\"./ftso/interfaces/IIFtso.sol\\\";\\nimport \\\"./genesis/interfaces/IFtsoRegistryGenesis.sol\\\";\\n\\ninterface IFtsoRegistry is IFtsoRegistryGenesis {\\n    struct PriceInfo {\\n        uint256 ftsoIndex;\\n        uint256 price;\\n        uint256 decimals;\\n        uint256 timestamp;\\n    }\\n\\n    function getFtso(\\n        uint256 _ftsoIndex\\n    ) external view returns (IIFtso _activeFtsoAddress);\\n    function getFtsoBySymbol(\\n        string memory _symbol\\n    ) external view returns (IIFtso _activeFtsoAddress);\\n    function getSupportedIndices()\\n        external\\n        view\\n        returns (uint256[] memory _supportedIndices);\\n    function getSupportedSymbols()\\n        external\\n        view\\n        returns (string[] memory _supportedSymbols);\\n    function getSupportedFtsos() external view returns (IIFtso[] memory _ftsos);\\n    function getFtsoIndex(\\n        string memory _symbol\\n    ) external view returns (uint256 _assetIndex);\\n    function getFtsoSymbol(\\n        uint256 _ftsoIndex\\n    ) external view returns (string memory _symbol);\\n    function getCurrentPrice(\\n        uint256 _ftsoIndex\\n    ) external view returns (uint256 _price, uint256 _timestamp);\\n    function getCurrentPrice(\\n        string memory _symbol\\n    ) external view returns (uint256 _price, uint256 _timestamp);\\n    function getCurrentPriceWithDecimals(\\n        uint256 _assetIndex\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _timestamp,\\n            uint256 _assetPriceUsdDecimals\\n        );\\n    function getCurrentPriceWithDecimals(\\n        string memory _symbol\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 _price,\\n            uint256 _timestamp,\\n            uint256 _assetPriceUsdDecimals\\n        );\\n\\n    function getAllCurrentPrices() external view returns (PriceInfo[] memory);\\n    function getCurrentPricesByIndices(\\n        uint256[] memory _indices\\n    ) external view returns (PriceInfo[] memory);\\n    function getCurrentPricesBySymbols(\\n        string[] memory _symbols\\n    ) external view returns (PriceInfo[] memory);\\n\\n    function getSupportedIndicesAndFtsos()\\n        external\\n        view\\n        returns (uint256[] memory _supportedIndices, IIFtso[] memory _ftsos);\\n\\n    function getSupportedSymbolsAndFtsos()\\n        external\\n        view\\n        returns (string[] memory _supportedSymbols, IIFtso[] memory _ftsos);\\n\\n    function getSupportedIndicesAndSymbols()\\n        external\\n        view\\n        returns (\\n            uint256[] memory _supportedIndices,\\n            string[] memory _supportedSymbols\\n        );\\n\\n    function getSupportedIndicesSymbolsAndFtsos()\\n        external\\n        view\\n        returns (\\n            uint256[] memory _supportedIndices,\\n            string[] memory _supportedSymbols,\\n            IIFtso[] memory _ftsos\\n        );\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./ftso/interfaces/IIFtso.sol\\\";\\nimport \\\"./genesis/interfaces/IFtsoManagerGenesis.sol\\\";\\n\\ninterface IFtsoManager is IFtsoManagerGenesis {\\n    event FtsoAdded(IIFtso ftso, bool add);\\n    event FallbackMode(bool fallbackMode);\\n    event FtsoFallbackMode(IIFtso ftso, bool fallbackMode);\\n    event RewardEpochFinalized(uint256 votepowerBlock, uint256 startBlock);\\n    event PriceEpochFinalized(address chosenFtso, uint256 rewardEpochId);\\n    event InitializingCurrentEpochStateForRevealFailed(\\n        IIFtso ftso,\\n        uint256 epochId\\n    );\\n    event FinalizingPriceEpochFailed(\\n        IIFtso ftso,\\n        uint256 epochId,\\n        IFtso.PriceFinalizationType failingType\\n    );\\n    event DistributingRewardsFailed(address ftso, uint256 epochId);\\n    event AccruingUnearnedRewardsFailed(uint256 epochId);\\n    event UseGoodRandomSet(\\n        bool useGoodRandom,\\n        uint256 maxWaitForGoodRandomSeconds\\n    );\\n\\n    function active() external view returns (bool);\\n\\n    function getCurrentRewardEpoch() external view returns (uint256);\\n\\n    function getRewardEpochVotePowerBlock(\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256);\\n\\n    function getRewardEpochToExpireNext() external view returns (uint256);\\n\\n    function getCurrentPriceEpochData()\\n        external\\n        view\\n        returns (\\n            uint256 _priceEpochId,\\n            uint256 _priceEpochStartTimestamp,\\n            uint256 _priceEpochEndTimestamp,\\n            uint256 _priceEpochRevealEndTimestamp,\\n            uint256 _currentTimestamp\\n        );\\n\\n    function getFtsos() external view returns (IIFtso[] memory _ftsos);\\n\\n    function getPriceEpochConfiguration()\\n        external\\n        view\\n        returns (\\n            uint256 _firstPriceEpochStartTs,\\n            uint256 _priceEpochDurationSeconds,\\n            uint256 _revealEpochDurationSeconds\\n        );\\n\\n    function getRewardEpochConfiguration()\\n        external\\n        view\\n        returns (\\n            uint256 _firstRewardEpochStartTs,\\n            uint256 _rewardEpochDurationSeconds\\n        );\\n\\n    function getFallbackMode()\\n        external\\n        view\\n        returns (\\n            bool _fallbackMode,\\n            IIFtso[] memory _ftsos,\\n            bool[] memory _ftsoInFallbackMode\\n        );\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtsoRewardManager {\\n    event RewardClaimed(\\n        address indexed dataProvider,\\n        address indexed whoClaimed,\\n        address indexed sentTo,\\n        uint256 rewardEpoch,\\n        uint256 amount\\n    );\\n\\n    event UnearnedRewardsAccrued(uint256 epochId, uint256 reward);\\n\\n    event RewardsDistributed(\\n        address indexed ftso,\\n        uint256 epochId,\\n        address[] addresses,\\n        uint256[] rewards\\n    );\\n\\n    event RewardClaimsEnabled(uint256 rewardEpochId);\\n\\n    event FeePercentageChanged(\\n        address indexed dataProvider,\\n        uint256 value,\\n        uint256 validFromEpoch\\n    );\\n\\n    event RewardClaimsExpired(uint256 rewardEpochId);\\n\\n    event FtsoRewardManagerActivated(address ftsoRewardManager);\\n    event FtsoRewardManagerDeactivated(address ftsoRewardManager);\\n\\n    /**\\n     * @notice Allows a percentage delegator to claim rewards.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by percentage.\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Reverts if `msg.sender` is delegating by amount\\n     * @dev Claims for all unclaimed reward epochs to the 'max(_rewardEpochs)'.\\n     * @dev Retained for backward compatibility.\\n     * @dev This function is deprecated - use `claim` instead.\\n     */\\n    function claimReward(\\n        address payable _recipient,\\n        uint256[] calldata _rewardEpochs\\n    ) external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by percentage.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,\\n     *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpoch          last reward epoch to claim for\\n     * @param _wrap                 should reward be wrapped immediately\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Reverts if `msg.sender` is delegating by amount\\n     */\\n    function claim(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint256 _rewardEpoch,\\n        bool _wrap\\n    ) external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows the sender to claim rewards from specified data providers.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by amount.\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\\n     * @param _dataProviders        array of addresses representing data providers to claim the reward from\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Function can only be used for explicit delegations.\\n     * @dev This function is deprecated - use `claimFromDataProviders` instead.\\n     */\\n    function claimRewardFromDataProviders(\\n        address payable _recipient,\\n        uint256[] calldata _rewardEpochs,\\n        address[] calldata _dataProviders\\n    ) external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner from specified data providers.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by amount.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,\\n     *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\\n     * @param _dataProviders        array of addresses representing data providers to claim the reward from\\n     * @param _wrap                 should reward be wrapped immediately\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Function can only be used for explicit delegations.\\n     */\\n    function claimFromDataProviders(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint256[] calldata _rewardEpochs,\\n        address[] calldata _dataProviders,\\n        bool _wrap\\n    ) external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows batch claiming for the list of '_rewardOwners' and for all unclaimed epochs <= '_rewardEpoch'.\\n     * @notice If reward owner has enabled delegation account, rewards are also claimed for that delegation account and\\n     *   total claimed amount is sent to that delegation account, otherwise claimed amount is sent to owner's account.\\n     * @notice Claimed amount is automatically wrapped.\\n     * @notice Method can be used by reward owner or executor. If executor is registered with fee > 0,\\n     *   then fee is paid to executor for each claimed address from the list.\\n     * @param _rewardOwners         list of reward owners to claim for\\n     * @param _rewardEpoch          last reward epoch to claim for\\n     */\\n    function autoClaim(\\n        address[] calldata _rewardOwners,\\n        uint256 _rewardEpoch\\n    ) external;\\n\\n    /**\\n     * @notice Allows data provider to set (or update last) fee percentage.\\n     * @param _feePercentageBIPS    number representing fee percentage in BIPS\\n     * @return _validFromEpoch      reward epoch number when the setting becomes effective.\\n     */\\n    function setDataProviderFeePercentage(\\n        uint256 _feePercentageBIPS\\n    ) external returns (uint256 _validFromEpoch);\\n\\n    /**\\n     * @notice Allows reward claiming\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * @notice Returns the current fee percentage of `_dataProvider`\\n     * @param _dataProvider         address representing data provider\\n     */\\n    function getDataProviderCurrentFeePercentage(\\n        address _dataProvider\\n    ) external view returns (uint256 _feePercentageBIPS);\\n\\n    /**\\n     * @notice Returns the fee percentage of `_dataProvider` at `_rewardEpoch`\\n     * @param _dataProvider         address representing data provider\\n     * @param _rewardEpoch          reward epoch number\\n     */\\n    function getDataProviderFeePercentage(\\n        address _dataProvider,\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256 _feePercentageBIPS);\\n\\n    /**\\n     * @notice Returns the scheduled fee percentage changes of `_dataProvider`\\n     * @param _dataProvider         address representing data provider\\n     * @return _feePercentageBIPS   positional array of fee percentages in BIPS\\n     * @return _validFromEpoch      positional array of block numbers the fee settings are effective from\\n     * @return _fixed               positional array of boolean values indicating if settings are subjected to change\\n     */\\n    function getDataProviderScheduledFeePercentageChanges(\\n        address _dataProvider\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _feePercentageBIPS,\\n            uint256[] memory _validFromEpoch,\\n            bool[] memory _fixed\\n        );\\n\\n    /**\\n     * @notice Returns information on epoch reward\\n     * @param _rewardEpoch          reward epoch number\\n     * @return _totalReward         number representing the total epoch reward\\n     * @return _claimedReward       number representing the amount of total epoch reward that has been claimed\\n     */\\n    function getEpochReward(\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256 _totalReward, uint256 _claimedReward);\\n\\n    /**\\n     * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch`\\n     * @param _beneficiary          address of reward beneficiary\\n     * @param _rewardEpoch          reward epoch number\\n     * @return _dataProviders       positional array of addresses representing data providers\\n     * @return _rewardAmounts       positional array of reward amounts\\n     * @return _claimed             positional array of boolean values indicating if reward is claimed\\n     * @return _claimable           boolean value indicating if rewards are claimable\\n     * @dev Reverts when queried with `_beneficiary` delegating by amount\\n     */\\n    function getStateOfRewards(\\n        address _beneficiary,\\n        uint256 _rewardEpoch\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory _dataProviders,\\n            uint256[] memory _rewardAmounts,\\n            bool[] memory _claimed,\\n            bool _claimable\\n        );\\n\\n    /**\\n     * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch` from `_dataProviders`\\n     * @param _beneficiary          address of reward beneficiary\\n     * @param _rewardEpoch          reward epoch number\\n     * @param _dataProviders        positional array of addresses representing data providers\\n     * @return _rewardAmounts       positional array of reward amounts\\n     * @return _claimed             positional array of boolean values indicating if reward is claimed\\n     * @return _claimable           boolean value indicating if rewards are claimable\\n     */\\n    function getStateOfRewardsFromDataProviders(\\n        address _beneficiary,\\n        uint256 _rewardEpoch,\\n        address[] calldata _dataProviders\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _rewardAmounts,\\n            bool[] memory _claimed,\\n            bool _claimable\\n        );\\n\\n    /**\\n     * @notice Returns the start and the end of the reward epoch range for which the reward is claimable\\n     * @param _startEpochId         the oldest epoch id that allows reward claiming\\n     * @param _endEpochId           the newest epoch id that allows reward claiming\\n     */\\n    function getEpochsWithClaimableRewards()\\n        external\\n        view\\n        returns (uint256 _startEpochId, uint256 _endEpochId);\\n\\n    /**\\n     * @notice Returns the next claimable reward epoch for '_rewardOwner'.\\n     * @param _rewardOwner          address of the reward owner\\n     */\\n    function nextClaimableRewardEpoch(\\n        address _rewardOwner\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the array of claimable epoch ids for which the reward has not yet been claimed\\n     * @param _beneficiary          address of reward beneficiary\\n     * @return _epochIds            array of epoch ids\\n     * @dev Reverts when queried with `_beneficiary` delegating by amount\\n     */\\n    function getEpochsWithUnclaimedRewards(\\n        address _beneficiary\\n    ) external view returns (uint256[] memory _epochIds);\\n\\n    /**\\n     * @notice Returns the information on claimed reward of `_dataProvider` for `_rewardEpoch` by `_claimer`\\n     * @param _rewardEpoch          reward epoch number\\n     * @param _dataProvider         address representing the data provider\\n     * @param _claimer              address representing the claimer\\n     * @return _claimed             boolean indicating if reward has been claimed\\n     * @return _amount              number representing the claimed amount\\n     */\\n    function getClaimedReward(\\n        uint256 _rewardEpoch,\\n        address _dataProvider,\\n        address _claimer\\n    ) external view returns (bool _claimed, uint256 _amount);\\n\\n    /**\\n     * @notice Return reward epoch that will expire, when new reward epoch will start\\n     * @return Reward epoch id that will expire next\\n     */\\n    function getRewardEpochToExpireNext() external view returns (uint256);\\n\\n    /**\\n     * @notice Return reward epoch vote power block\\n     * @param _rewardEpoch          reward epoch number\\n     */\\n    function getRewardEpochVotePowerBlock(\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Return current reward epoch number\\n     */\\n    function getCurrentRewardEpoch() external view returns (uint256);\\n\\n    /**\\n     * @notice Return initial reward epoch number\\n     */\\n    function getInitialRewardEpoch() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the information on rewards and initial vote power of `_dataProvider` for `_rewardEpoch`\\n     * @param _rewardEpoch                      reward epoch number\\n     * @param _dataProvider                     address representing the data provider\\n     * @return _rewardAmount                    number representing the amount of rewards\\n     * @return _votePowerIgnoringRevocation     number representing the vote power ignoring revocations\\n     */\\n    function getDataProviderPerformanceInfo(\\n        uint256 _rewardEpoch,\\n        address _dataProvider\\n    )\\n        external\\n        view\\n        returns (uint256 _rewardAmount, uint256 _votePowerIgnoringRevocation);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareContractRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\ninterface IFlareContractRegistry {\\n    /**\\n     * @notice Returns contract address for the given name - might be address(0)\\n     * @param _name             name of the contract\\n     */\\n    function getContractAddressByName(\\n        string calldata _name\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Returns contract address for the given name hash - might be address(0)\\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressByHash(\\n        bytes32 _nameHash\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Returns contract addresses for the given names - might be address(0)\\n     * @param _names            names of the contracts\\n     */\\n    function getContractAddressesByName(\\n        string[] calldata _names\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressesByHash(\\n        bytes32[] calldata _nameHashes\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns all contract names and corresponding addresses\\n     */\\n    function getAllContracts()\\n        external\\n        view\\n        returns (string[] memory _names, address[] memory _addresses);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWNat.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IWNat {\\n    /**\\n     * @notice Deposit native token and mint WNAT ERC20.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @notice Withdraw native token and burn WNAT ERC20.\\n     * @param _amount The amount to withdraw.\\n     */\\n    function withdraw(uint256 _amount) external;\\n\\n    /**\\n     * @notice Deposit native token from msg.sender and mint WNAT ERC20.\\n     * @param _recipient An address to receive minted WNAT.\\n     */\\n    function depositTo(address _recipient) external payable;\\n\\n    /**\\n     * @notice Withdraw WNAT from an owner and send NAT to msg.sender given an allowance.\\n     * @param _owner An address spending the native tokens.\\n     * @param _amount The amount to spend.\\n     *\\n     * Requirements:\\n     *\\n     * - `_owner` must have a balance of at least `_amount`.\\n     * - the caller must have allowance for `_owners`'s tokens of at least\\n     * `_amount`.\\n     */\\n    function withdrawFrom(address _owner, uint256 _amount) external;\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVoterWhitelister.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IVoterWhitelister {\\n    /**\\n     * Raised when an account is removed from the voter whitelist.\\n     */\\n    event VoterWhitelisted(address voter, uint256 ftsoIndex);\\n\\n    /**\\n     * Raised when an account is removed from the voter whitelist.\\n     */\\n    event VoterRemovedFromWhitelist(address voter, uint256 ftsoIndex);\\n\\n    /**\\n     * Raised when an account is chilled from the voter whitelist.\\n     */\\n    event VoterChilled(address voter, uint256 untilRewardEpoch);\\n\\n    /**\\n     * Request to whitelist `_voter` account to ftso at `_ftsoIndex`. Will revert if vote power too low.\\n     * May be called by any address.\\n     */\\n    function requestWhitelistingVoter(\\n        address _voter,\\n        uint256 _ftsoIndex\\n    ) external;\\n\\n    /**\\n     * Request to whitelist `_voter` account to all active ftsos.\\n     * May be called by any address.\\n     * It returns an array of supported ftso indices and success flag per index.\\n     */\\n    function requestFullVoterWhitelisting(\\n        address _voter\\n    )\\n        external\\n        returns (uint256[] memory _supportedIndices, bool[] memory _success);\\n\\n    /**\\n     * Maximum number of voters in the whitelist for a new FTSO.\\n     */\\n    function defaultMaxVotersForFtso() external view returns (uint256);\\n\\n    /**\\n     * Maximum number of voters in the whitelist for FTSO at index `_ftsoIndex`.\\n     */\\n    function maxVotersForFtso(\\n        uint256 _ftsoIndex\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get whitelisted price providers for ftso with `_symbol`\\n     */\\n    function getFtsoWhitelistedPriceProvidersBySymbol(\\n        string memory _symbol\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * Get whitelisted price providers for ftso at `_ftsoIndex`\\n     */\\n    function getFtsoWhitelistedPriceProviders(\\n        uint256 _ftsoIndex\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * In case of providing bad prices (e.g. collusion), the voter can be chilled for a few reward epochs.\\n     * A voter can whitelist again from a returned reward epoch onwards.\\n     */\\n    function chilledUntilRewardEpoch(\\n        address _voter\\n    ) external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRandomProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Random provider interface.\\n */\\ninterface IRandomProvider {\\n    /**\\n     * Returns current random number. Method reverts if random number was not generated securely.\\n     * @return _randomNumber Current random number.\\n     */\\n    function getCurrentRandom() external view returns (uint256 _randomNumber);\\n\\n    /**\\n     * Returns current random number and a flag indicating if it was securely generated.\\n     * It is up to the caller to decide whether to use the returned random number or not.\\n     * @return _randomNumber Current random number.\\n     * @return _isSecureRandom Indicates if current random number is secure.\\n     */\\n    function getCurrentRandomWithQuality()\\n        external\\n        view\\n        returns (uint256 _randomNumber, bool _isSecureRandom);\\n\\n    /**\\n     * Returns current random number, a flag indicating if it was securely generated and its timestamp.\\n     * It is up to the caller to decide whether to use the returned random number or not.\\n     * @return _randomNumber Current random number.\\n     * @return _isSecureRandom Indicates if current random number is secure.\\n     * @return _randomTimestamp Random timestamp.\\n     */\\n    function getCurrentRandomWithQualityAndTimestamp()\\n        external\\n        view\\n        returns (\\n            uint256 _randomNumber,\\n            bool _isSecureRandom,\\n            uint256 _randomTimestamp\\n        );\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/ISubmission.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IRandomProvider.sol\\\";\\n\\n/**\\n * Submission interface.\\n */\\ninterface ISubmission is IRandomProvider {\\n    /// Event emitted when a new voting round is initiated.\\n    event NewVotingRoundInitiated();\\n\\n    /**\\n     * Submit1 method. Used in multiple protocols (i.e. as FTSO commit method).\\n     */\\n    function submit1() external returns (bool);\\n\\n    /**\\n     * Submit2 method. Used in multiple protocols (i.e. as FTSO reveal method).\\n     */\\n    function submit2() external returns (bool);\\n\\n    /**\\n     * Submit3 method. Future usage.\\n     */\\n    function submit3() external returns (bool);\\n\\n    /**\\n     * SubmitSignatures method. Used in multiple protocols (i.e. as FTSO submit signature method).\\n     */\\n    function submitSignatures() external returns (bool);\\n\\n    /**\\n     * SubmitAndPass method. Future usage.\\n     * @param _data The data to pass to the submitAndPassContract.\\n     */\\n    function submitAndPass(bytes calldata _data) external returns (bool);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareAssetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\ninterface IFlareAssetRegistry {\\n    /**\\n     * @notice Returns if the token is a Flare Asset\\n     * @dev All other methods that accept token address will fail if this method returns false\\n     * @param token The token to be checked\\n     */\\n    function isFlareAsset(address token) external view returns (bool);\\n\\n    /**\\n     * Return the asset type of the token. Asset type is a hash uniquely identifying the asset type.\\n     * For example, for wrapped native token, the type is `keccak256(\\\"wrapped native\\\")`,\\n     * and for all f-assets the type will be `keccak256(\\\"f-asset\\\")`.\\n     */\\n    function assetType(address _token) external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the address of the Flare Asset with the selected symbol\\n     * @param symbol The token's symbol\\n     */\\n    function assetBySymbol(\\n        string calldata symbol\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Returns if the Flare Asset supports delegation via IVPToken interface\\n     * @param token The token to be checked\\n     */\\n    function supportsFtsoDelegation(address token) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the maximum allowed number of delegates by percent for the selected token\\n     * @param token The token to be checked\\n     */\\n    function maxDelegatesByPercent(\\n        address token\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the incentive pool address for the selected token\\n     * @param token The token to be checked\\n     */\\n    function incentivePoolFor(address token) external view returns (address);\\n\\n    /**\\n     * @notice Returns the addresses of all Flare Assets\\n     */\\n    function allAssets() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the addresses and associated symbols of all Flare Assets\\n     */\\n    function allAssetsWithSymbols()\\n        external\\n        view\\n        returns (address[] memory, string[] memory);\\n\\n    /**\\n     * @notice Returns all asset types.\\n     */\\n    function allAssetTypes() external view returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the addresses of all Flare Assets of given type.\\n     * @param _assetType a type hash, all returned assets will have this assetType\\n     */\\n    function allAssetsOfType(\\n        bytes32 _assetType\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the addresses and associated symbols of all Flare Assets of given type.\\n     * @param _assetType a type hash, all returned assets will have this assetType\\n     */\\n    function allAssetsOfTypeWithSymbols(\\n        bytes32 _assetType\\n    ) external view returns (address[] memory, string[] memory);\\n\\n    /**\\n     * @notice Returns a generic asset attribute value.\\n     * @param token The token's address\\n     * @param nameHash attributes name's hash\\n     * @return defined true if the attribute is defined for this token\\n     * @return value attribute value, may have to be cast into some other type\\n     */\\n    function getAttribute(\\n        address token,\\n        bytes32 nameHash\\n    ) external view returns (bool defined, bytes32 value);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IClaimSetupManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IDelegationAccount.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IClaimSetupManager {\\n    event DelegationAccountCreated(\\n        address owner,\\n        IDelegationAccount delegationAccount\\n    );\\n    event DelegationAccountUpdated(\\n        address owner,\\n        IDelegationAccount delegationAccount,\\n        bool enabled\\n    );\\n    event ClaimExecutorsChanged(address owner, address[] executors);\\n    event AllowedClaimRecipientsChanged(address owner, address[] recipients);\\n    event ClaimExecutorFeeValueChanged(\\n        address executor,\\n        uint256 validFromRewardEpoch,\\n        uint256 feeValueWei\\n    );\\n    event ExecutorRegistered(address executor);\\n    event ExecutorUnregistered(address executor, uint256 validFromRewardEpoch);\\n    event MinFeeSet(uint256 minFeeValueWei);\\n    event MaxFeeSet(uint256 maxFeeValueWei);\\n    event RegisterExecutorFeeSet(uint256 registerExecutorFeeValueWei);\\n    event SetExecutorsExcessAmountRefunded(address owner, uint256 excessAmount);\\n\\n    /**\\n     * @notice Sets the addresses of executors and optionally enables (creates) delegation account.\\n     * @notice If setting registered executors some fee must be paid to them.\\n     * @param _executors        The new executors. All old executors will be deleted and replaced by these.\\n     */\\n    function setAutoClaiming(\\n        address[] memory _executors,\\n        bool _enableDelegationAccount\\n    ) external payable;\\n\\n    /**\\n     * @notice Sets the addresses of executors.\\n     * @notice If setting registered executors some fee must be paid to them.\\n     * @param _executors        The new executors. All old executors will be deleted and replaced by these.\\n     */\\n    function setClaimExecutors(address[] memory _executors) external payable;\\n\\n    /**\\n     * Set the addresses of allowed recipients.\\n     * Apart from these, the owner is always an allowed recipient.\\n     * @param _recipients The new allowed recipients. All old recipients will be deleted and replaced by these.\\n     */\\n    function setAllowedClaimRecipients(address[] memory _recipients) external;\\n\\n    /**\\n     * @notice Enables (creates) delegation account contract,\\n     * i.e. all airdrop and ftso rewards will be send to delegation account when using automatic claiming.\\n     * @return Address of delegation account contract.\\n     */\\n    function enableDelegationAccount() external returns (IDelegationAccount);\\n\\n    /**\\n     * @notice Disables delegation account contract,\\n     * i.e. all airdrop and ftso rewards will be send to owner's account when using automatic claiming.\\n     * @notice Automatic claiming will not claim airdrop and ftso rewards for delegation account anymore.\\n     * @dev Reverts if there is no delegation account\\n     */\\n    function disableDelegationAccount() external;\\n\\n    /**\\n     * @notice Allows executor to register and set initial fee value.\\n     * If executor was already registered before (has fee set), only update fee after `feeValueUpdateOffset`.\\n     * @notice Executor must pay fee in order to register - `registerExecutorFeeValueWei`.\\n     * @param _feeValue    number representing fee value\\n     * @return Returns the reward epoch number when the setting becomes effective.\\n     */\\n    function registerExecutor(\\n        uint256 _feeValue\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Allows executor to unregister.\\n     * @return Returns the reward epoch number when the setting becomes effective.\\n     */\\n    function unregisterExecutor() external returns (uint256);\\n\\n    /**\\n     * @notice Allows registered executor to set (or update last scheduled) fee value.\\n     * @param _feeValue    number representing fee value\\n     * @return Returns the reward epoch number when the setting becomes effective.\\n     */\\n    function updateExecutorFeeValue(\\n        uint256 _feeValue\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Delegate `_bips` of voting power to `_to` from msg.sender's delegation account\\n     * @param _to The address of the recipient\\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).\\n     */\\n    function delegate(address _to, uint256 _bips) external;\\n\\n    /**\\n     * @notice Undelegate all percentage delegations from the msg.sender's delegation account and then delegate\\n     *   corresponding `_bips` percentage of voting power to each member of `_delegatees`.\\n     * @param _delegatees The addresses of the new recipients.\\n     * @param _bips The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Total of all `_bips` values must be at most 10000.\\n     */\\n    function batchDelegate(\\n        address[] memory _delegatees,\\n        uint256[] memory _bips\\n    ) external;\\n\\n    /**\\n     * @notice Undelegate all voting power for delegates of msg.sender's delegation account\\n     */\\n    function undelegateAll() external;\\n\\n    /**\\n     * @notice Revoke all delegation from msg.sender's delegation account to `_who` at given block.\\n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\\n     *    Block `_blockNumber` must be in the past.\\n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\\n     *    To stop delegating use delegate with value of 0 or undelegateAll.\\n     */\\n    function revokeDelegationAt(address _who, uint256 _blockNumber) external;\\n\\n    /**\\n     * @notice Delegate all governance vote power of msg.sender's delegation account to `_to`.\\n     * @param _to The address of the recipient\\n     */\\n    function delegateGovernance(address _to) external;\\n\\n    /**\\n     * @notice Undelegate governance vote power for delegate of msg.sender's delegation account\\n     */\\n    function undelegateGovernance() external;\\n\\n    /**\\n     * @notice Allows user to transfer WNat to owner's account.\\n     * @param _amount           Amount of tokens to transfer\\n     */\\n    function withdraw(uint256 _amount) external;\\n\\n    /**\\n     * @notice Allows user to transfer balance of ERC20 tokens owned by the personal delegation contract.\\n     The main use case is to transfer tokens/NFTs that were received as part of an airdrop or register \\n     as participant in such airdrop.\\n     * @param _token            Target token contract address\\n     * @param _amount           Amount of tokens to transfer\\n     * @dev Reverts if target token is WNat contract - use method `withdraw` for that\\n     */\\n    function transferExternalToken(IERC20 _token, uint256 _amount) external;\\n\\n    /**\\n     * @notice Gets the delegation account of the `_owner`. Returns address(0) if not created yet.\\n     */\\n    function accountToDelegationAccount(\\n        address _owner\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Gets the delegation account data for the `_owner`. Returns address(0) if not created yet.\\n     * @param _owner                        owner's address\\n     * @return _delegationAccount           owner's delegation account address - could be address(0)\\n     * @return _enabled                     indicates if delegation account is enabled\\n     */\\n    function getDelegationAccountData(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (IDelegationAccount _delegationAccount, bool _enabled);\\n\\n    /**\\n     * @notice Get the addresses of executors.\\n     */\\n    function claimExecutors(\\n        address _owner\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * Get the addresses of allowed recipients.\\n     * Apart from these, the owner is always an allowed recipient.\\n     */\\n    function allowedClaimRecipients(\\n        address _rewardOwner\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns info if `_executor` is allowed to execute calls for `_owner`\\n     */\\n    function isClaimExecutor(\\n        address _owner,\\n        address _executor\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Get registered executors\\n     */\\n    function getRegisteredExecutors(\\n        uint256 _start,\\n        uint256 _end\\n    )\\n        external\\n        view\\n        returns (address[] memory _registeredExecutors, uint256 _totalLength);\\n\\n    /**\\n     * @notice Returns some info about the `_executor`\\n     * @param _executor             address representing executor\\n     * @return _registered          information if executor is registered\\n     * @return _currentFeeValue     executor's current fee value\\n     */\\n    function getExecutorInfo(\\n        address _executor\\n    ) external view returns (bool _registered, uint256 _currentFeeValue);\\n\\n    /**\\n     * @notice Returns the current fee value of `_executor`\\n     * @param _executor             address representing executor\\n     */\\n    function getExecutorCurrentFeeValue(\\n        address _executor\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the fee value of `_executor` at `_rewardEpoch`\\n     * @param _executor             address representing executor\\n     * @param _rewardEpoch          reward epoch number\\n     */\\n    function getExecutorFeeValue(\\n        address _executor,\\n        uint256 _rewardEpoch\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the scheduled fee value changes of `_executor`\\n     * @param _executor             address representing executor\\n     * @return _feeValue            positional array of fee values\\n     * @return _validFromEpoch      positional array of reward epochs the fee settings are effective from\\n     * @return _fixed               positional array of boolean values indicating if settings are subjected to change\\n     */\\n    function getExecutorScheduledFeeValueChanges(\\n        address _executor\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _feeValue,\\n            uint256[] memory _validFromEpoch,\\n            bool[] memory _fixed\\n        );\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IDelegationAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IClaimSetupManager.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDelegationAccount {\\n    event DelegateFtso(address to, uint256 bips);\\n    event RevokeFtso(address to, uint256 blockNumber);\\n    event UndelegateAllFtso();\\n    event DelegateGovernance(address to);\\n    event UndelegateGovernance();\\n    event WithdrawToOwner(uint256 amount);\\n    event ExternalTokenTransferred(IERC20 token, uint256 amount);\\n    event ExecutorFeePaid(address executor, uint256 amount);\\n    event Initialize(address owner, IClaimSetupManager manager);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVoterRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * VoterRegistry interface.\\n */\\ninterface IVoterRegistry {\\n    /// Signature data.\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// Event emitted when a beneficiary (c-chain address or node id) is chilled.\\n    event BeneficiaryChilled(\\n        bytes20 indexed beneficiary,\\n        uint256 untilRewardEpochId\\n    );\\n\\n    /// Event emitted when a voter is removed.\\n    event VoterRemoved(address indexed voter, uint256 indexed rewardEpochId);\\n\\n    /// Event emitted when a voter is registered.\\n    event VoterRegistered(\\n        address indexed voter,\\n        uint24 indexed rewardEpochId,\\n        address indexed signingPolicyAddress,\\n        address submitAddress,\\n        address submitSignaturesAddress,\\n        bytes32 publicKeyPart1,\\n        bytes32 publicKeyPart2,\\n        uint256 registrationWeight\\n    );\\n\\n    /**\\n     * Registers a voter if the weight is high enough.\\n     * @param _voter The voter address.\\n     * @param _signature The signature.\\n     */\\n    function registerVoter(\\n        address _voter,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Maximum number of voters in one reward epoch.\\n     */\\n    function maxVoters() external view returns (uint256);\\n\\n    /**\\n     * In case of providing bad votes (e.g. ftso collusion), the beneficiary can be chilled for a few reward epochs.\\n     * If beneficiary is chilled, the vote power assigned to it is zero.\\n     * @param _beneficiary The beneficiary (c-chain address or node id).\\n     * @return _rewardEpochId The reward epoch id until which the voter is chilled.\\n     */\\n    function chilledUntilRewardEpochId(\\n        bytes20 _beneficiary\\n    ) external view returns (uint256 _rewardEpochId);\\n\\n    /**\\n     * Returns the block number of the start of the new signing policy initialisation for a given reward epoch.\\n     * It is a snaphost block of the voters' addresses (it is zero if the reward epoch is not supported).\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function newSigningPolicyInitializationStartBlockNumber(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Indicates if the voter must have the public key set when registering.\\n     */\\n    function publicKeyRequired() external view returns (bool);\\n\\n    /**\\n     * Returns the list of registered voters for a given reward epoch.\\n     * List can be empty if the reward epoch is not supported (before initial reward epoch or future reward epoch).\\n     * List for the next reward epoch can still change until the signing policy snapshot is created.\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function getRegisteredVoters(\\n        uint256 _rewardEpochId\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * Returns the number of registered voters for a given reward epoch.\\n     * Size can be zero if the reward epoch is not supported (before initial reward epoch or future reward epoch).\\n     * Size for the next reward epoch can still change until the signing policy snapshot is created.\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function getNumberOfRegisteredVoters(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Returns true if a voter was (is currently) registered in a given reward epoch.\\n     * @param _voter The voter address.\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function isVoterRegistered(\\n        address _voter,\\n        uint256 _rewardEpochId\\n    ) external view returns (bool);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IEntityManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * EntityManager interface.\\n */\\ninterface IEntityManager {\\n    /// Voter addresses.\\n    struct VoterAddresses {\\n        address submitAddress;\\n        address submitSignaturesAddress;\\n        address signingPolicyAddress;\\n    }\\n\\n    /// Event emitted when a node id is registered.\\n    event NodeIdRegistered(address indexed voter, bytes20 indexed nodeId);\\n    /// Event emitted when a node id is unregistered.\\n    event NodeIdUnregistered(address indexed voter, bytes20 indexed nodeId);\\n    /// Event emitted when a public key is registered.\\n    event PublicKeyRegistered(\\n        address indexed voter,\\n        bytes32 indexed part1,\\n        bytes32 indexed part2\\n    );\\n    /// Event emitted when a public key is unregistered.\\n    event PublicKeyUnregistered(\\n        address indexed voter,\\n        bytes32 indexed part1,\\n        bytes32 indexed part2\\n    );\\n    /// Event emitted when a delegation address is proposed.\\n    event DelegationAddressProposed(\\n        address indexed voter,\\n        address indexed delegationAddress\\n    );\\n    /// Event emitted when a delegation address registration is confirmed.\\n    event DelegationAddressRegistrationConfirmed(\\n        address indexed voter,\\n        address indexed delegationAddress\\n    );\\n    /// Event emitted when a submit address is proposed.\\n    event SubmitAddressProposed(\\n        address indexed voter,\\n        address indexed submitAddress\\n    );\\n    /// Event emitted when a submit address registration is confirmed.\\n    event SubmitAddressRegistrationConfirmed(\\n        address indexed voter,\\n        address indexed submitAddress\\n    );\\n    /// Event emitted when a submit signatures address is proposed.\\n    event SubmitSignaturesAddressProposed(\\n        address indexed voter,\\n        address indexed submitSignaturesAddress\\n    );\\n    /// Event emitted when a submit signatures address registration is confirmed.\\n    event SubmitSignaturesAddressRegistrationConfirmed(\\n        address indexed voter,\\n        address indexed submitSignaturesAddress\\n    );\\n    /// Event emitted when a signing policy address is proposed.\\n    event SigningPolicyAddressProposed(\\n        address indexed voter,\\n        address indexed signingPolicyAddress\\n    );\\n    /// Event emitted when a signing policy address registration is confirmed.\\n    event SigningPolicyAddressRegistrationConfirmed(\\n        address indexed voter,\\n        address indexed signingPolicyAddress\\n    );\\n    /// Event emitted when the maximum number of node ids per entity is set.\\n    event MaxNodeIdsPerEntitySet(uint256 maxNodeIdsPerEntity);\\n\\n    /**\\n     * Registers a node id.\\n     * @param _nodeId Node id.\\n     * @param _certificateRaw Certificate in raw format.\\n     * @param _signature Signature.\\n     */\\n    function registerNodeId(\\n        bytes20 _nodeId,\\n        bytes calldata _certificateRaw,\\n        bytes calldata _signature\\n    ) external;\\n\\n    /**\\n     * Unregisters a node id.\\n     * @param _nodeId Node id.\\n     */\\n    function unregisterNodeId(bytes20 _nodeId) external;\\n\\n    /**\\n     * Registers a public key.\\n     * @param _part1 First part of the public key.\\n     * @param _part2 Second part of the public key.\\n     * @param _verificationData Additional data used to verify the public key.\\n     */\\n    function registerPublicKey(\\n        bytes32 _part1,\\n        bytes32 _part2,\\n        bytes calldata _verificationData\\n    ) external;\\n\\n    /**\\n     * Unregisters a public key.\\n     */\\n    function unregisterPublicKey() external;\\n\\n    /**\\n     * Proposes a delegation address (called by the voter).\\n     * @param _delegationAddress Delegation address.\\n     */\\n    function proposeDelegationAddress(address _delegationAddress) external;\\n\\n    /**\\n     * Confirms a delegation address registration (called by the delegation address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmDelegationAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Proposes a submit address (called by the voter).\\n     * @param _submitAddress Submit address.\\n     */\\n    function proposeSubmitAddress(address _submitAddress) external;\\n\\n    /**\\n     * Confirms a submit address registration (called by the submit address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmSubmitAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Proposes a submit signatures address (called by the voter).\\n     * @param _submitSignaturesAddress Submit signatures address.\\n     */\\n    function proposeSubmitSignaturesAddress(\\n        address _submitSignaturesAddress\\n    ) external;\\n\\n    /**\\n     * Confirms a submit signatures address registration (called by the submit signatures address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmSubmitSignaturesAddressRegistration(\\n        address _voter\\n    ) external;\\n\\n    /**\\n     * Proposes a signing policy address (called by the voter).\\n     * @param _signingPolicyAddress Signing policy address.\\n     */\\n    function proposeSigningPolicyAddress(\\n        address _signingPolicyAddress\\n    ) external;\\n\\n    /**\\n     * Confirms a signing policy address registration (called by the signing policy address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmSigningPolicyAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Gets the delegation address of a voter at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return Public key.\\n     */\\n    function getDelegationAddressOfAt(\\n        address _voter,\\n        uint256 _blockNumber\\n    ) external view returns (address);\\n\\n    /**\\n     * Gets the delegation address of a voter at the current block number.\\n     * @param _voter Voter address.\\n     * @return Public key.\\n     */\\n    function getDelegationAddressOf(\\n        address _voter\\n    ) external view returns (address);\\n\\n    /**\\n     * Gets the node ids of a voter at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return Node ids.\\n     */\\n    function getNodeIdsOfAt(\\n        address _voter,\\n        uint256 _blockNumber\\n    ) external view returns (bytes20[] memory);\\n\\n    /**\\n     * Gets the node ids of a voter at the current block number.\\n     * @param _voter Voter address.\\n     * @return Node ids.\\n     */\\n    function getNodeIdsOf(\\n        address _voter\\n    ) external view returns (bytes20[] memory);\\n\\n    /**\\n     * Gets the public key of a voter at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return Public key.\\n     */\\n    function getPublicKeyOfAt(\\n        address _voter,\\n        uint256 _blockNumber\\n    ) external view returns (bytes32, bytes32);\\n\\n    /**\\n     * Gets the public key of a voter at the current block number.\\n     * @param _voter Voter address.\\n     * @return Public key.\\n     */\\n    function getPublicKeyOf(\\n        address _voter\\n    ) external view returns (bytes32, bytes32);\\n\\n    /**\\n     * Gets voter's addresses at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return _addresses Voter addresses.\\n     */\\n    function getVoterAddressesAt(\\n        address _voter,\\n        uint256 _blockNumber\\n    ) external view returns (VoterAddresses memory _addresses);\\n\\n    /**\\n     * Gets voter's addresses at the current block number.\\n     * @param _voter Voter address.\\n     * @return _addresses Voter addresses.\\n     */\\n    function getVoterAddresses(\\n        address _voter\\n    ) external view returns (VoterAddresses memory _addresses);\\n\\n    /**\\n     * Gets voter's address for a node id at a specific block number.\\n     * @param _nodeId Node id.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForNodeId(\\n        bytes20 _nodeId,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a public key at a specific block number.\\n     * @param _part1 First part of the public key.\\n     * @param _part2 Second part of the public key.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForPublicKey(\\n        bytes32 _part1,\\n        bytes32 _part2,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a delegation address at a specific block number.\\n     * @param _delegationAddress Delegation address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForDelegationAddress(\\n        address _delegationAddress,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a submit address at a specific block number.\\n     * @param _submitAddress Submit address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForSubmitAddress(\\n        address _submitAddress,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a submit signatures address at a specific block number.\\n     * @param _submitSignaturesAddress Submit signatures address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForSubmitSignaturesAddress(\\n        address _submitSignaturesAddress,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a signing policy address at a specific block number.\\n     * @param _signingPolicyAddress Signing policy address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForSigningPolicyAddress(\\n        address _signingPolicyAddress,\\n        uint256 _blockNumber\\n    ) external view returns (address _voter);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWNatDelegationFee.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * WNatDelegationFee interface.\\n */\\ninterface IWNatDelegationFee {\\n    /// Event emitted when a voter fee percentage value is changed.\\n    event FeePercentageChanged(\\n        address indexed voter,\\n        uint16 value,\\n        uint24 validFromEpochId\\n    );\\n\\n    /**\\n     * Allows voter to set (or update last) fee percentage.\\n     * @param _feePercentageBIPS Number representing fee percentage in BIPS.\\n     * @return Returns the reward epoch number when the value becomes effective.\\n     */\\n    function setVoterFeePercentage(\\n        uint16 _feePercentageBIPS\\n    ) external returns (uint256);\\n\\n    /// The offset in reward epochs for the fee percentage value to become effective.\\n    function feePercentageUpdateOffset() external view returns (uint24);\\n\\n    /// The default fee percentage value.\\n    function defaultFeePercentageBIPS() external view returns (uint16);\\n\\n    /**\\n     * Returns the current fee percentage of `_voter`.\\n     * @param _voter Voter address.\\n     */\\n    function getVoterCurrentFeePercentage(\\n        address _voter\\n    ) external view returns (uint16);\\n\\n    /**\\n     * Returns the fee percentage of `_voter` for given reward epoch id.\\n     * @param _voter Voter address.\\n     * @param _rewardEpochId Reward epoch id.\\n     * **NOTE:** fee percentage might still change for the `current + feePercentageUpdateOffset` reward epoch id\\n     */\\n    function getVoterFeePercentage(\\n        address _voter,\\n        uint256 _rewardEpochId\\n    ) external view returns (uint16);\\n\\n    /**\\n     * Returns the scheduled fee percentage changes of `_voter`.\\n     * @param _voter Voter address.\\n     * @return _feePercentageBIPS Positional array of fee percentages in BIPS.\\n     * @return _validFromEpochId Positional array of reward epoch ids the fee setings are effective from.\\n     * @return _fixed Positional array of boolean values indicating if settings are subjected to change.\\n     */\\n    function getVoterScheduledFeePercentageChanges(\\n        address _voter\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory _feePercentageBIPS,\\n            uint256[] memory _validFromEpochId,\\n            bool[] memory _fixed\\n        );\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoInflationConfigurations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoInflationConfigurations interface.\\n */\\ninterface IFtsoInflationConfigurations {\\n    /// The FTSO configuration struct.\\n    struct FtsoConfiguration {\\n        // concatenated feed ids - i.e. category + base/quote symbol - multiple of 21 (one feedId is bytes21)\\n        bytes feedIds;\\n        // inflation share for this configuration group\\n        uint24 inflationShare;\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS;\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM;\\n        // secondary band width in PPM (parts per million) in relation to the median - multiple of 3 (uint24)\\n        bytes secondaryBandWidthPPMs;\\n        // rewards split mode (0 means equally, 1 means random,...)\\n        uint16 mode;\\n    }\\n\\n    /**\\n     * Returns the FTSO configuration at `_index`.\\n     * @param _index The index of the FTSO configuration.\\n     */\\n    function getFtsoConfiguration(\\n        uint256 _index\\n    ) external view returns (FtsoConfiguration memory);\\n\\n    /**\\n     * Returns the FTSO configurations.\\n     */\\n    function getFtsoConfigurations()\\n        external\\n        view\\n        returns (FtsoConfiguration[] memory);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/RewardsV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Rewards V2 long term support interface.\\n */\\ninterface RewardsV2Interface {\\n    /// Claim type enum.\\n    enum ClaimType {\\n        DIRECT,\\n        FEE,\\n        WNAT,\\n        MIRROR,\\n        CCHAIN\\n    }\\n\\n    /// Struct used for claiming rewards with Merkle proof.\\n    struct RewardClaimWithProof {\\n        bytes32[] merkleProof;\\n        RewardClaim body;\\n    }\\n\\n    /// Struct used in Merkle tree for storing reward claims.\\n    struct RewardClaim {\\n        uint24 rewardEpochId;\\n        bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR\\n        uint120 amount; // in wei\\n        ClaimType claimType;\\n    }\\n\\n    /// Struct used for returning state of rewards.\\n    struct RewardState {\\n        uint24 rewardEpochId;\\n        bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR\\n        uint120 amount; // in wei\\n        ClaimType claimType;\\n        bool initialised;\\n    }\\n\\n    /**\\n     * Claim rewards for `_rewardOwner` and transfer them to `_recipient`.\\n     * It can be called by reward owner or its authorized executor.\\n     * @param _rewardOwner Address of the reward owner.\\n     * @param _recipient Address of the reward recipient.\\n     * @param _rewardEpochId Id of the reward epoch up to which the rewards are claimed.\\n     * @param _wrap Indicates if the reward should be wrapped (deposited) to the WNAT contract.\\n     * @param _proofs Array of reward claims with merkle proofs.\\n     * @return _rewardAmountWei Amount of rewarded native tokens (wei).\\n     */\\n    function claim(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint24 _rewardEpochId,\\n        bool _wrap,\\n        RewardClaimWithProof[] calldata _proofs\\n    ) external returns (uint256 _rewardAmountWei);\\n\\n    /**\\n     * Indicates if the contract is active - claims are enabled.\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * Returns the start and the end of the reward epoch range for which the reward is claimable.\\n     * @return _startEpochId The oldest epoch id that allows reward claiming.\\n     * @return _endEpochId The newest epoch id that allows reward claiming.\\n     */\\n    function getRewardEpochIdsWithClaimableRewards()\\n        external\\n        view\\n        returns (uint24 _startEpochId, uint24 _endEpochId);\\n\\n    /**\\n     * Returns the next claimable reward epoch for a reward owner.\\n     * @param _rewardOwner Address of the reward owner to query.\\n     */\\n    function getNextClaimableRewardEpochId(\\n        address _rewardOwner\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Returns the state of rewards for a given address for all unclaimed reward epochs with claimable rewards.\\n     * @param _rewardOwner Address of the reward owner.\\n     * @return _rewardStates Array of reward states.\\n     */\\n    function getStateOfRewards(\\n        address _rewardOwner\\n    ) external view returns (RewardState[][] memory _rewardStates);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./RewardsV2Interface.sol\\\";\\n\\n/**\\n * RewardManager interface.\\n */\\ninterface IRewardManager is RewardsV2Interface {\\n    /// Struct used for storing unclaimed reward data.\\n    struct UnclaimedRewardState {\\n        bool initialised; // Information if already initialised\\n        // amount and weight might be 0 if all users already claimed\\n        uint120 amount; // Total unclaimed amount.\\n        uint128 weight; // Total unclaimed weight.\\n    }\\n\\n    /**\\n     * Emitted when rewards are claimed.\\n     * @param beneficiary Address of the beneficiary (voter or node id) that accrued the reward.\\n     * @param rewardOwner Address that was eligible for the rewards.\\n     * @param recipient Address that received the reward.\\n     * @param rewardEpochId Id of the reward epoch where the reward was accrued.\\n     * @param claimType Claim type\\n     * @param amount Amount of rewarded native tokens (wei).\\n     */\\n    event RewardClaimed(\\n        address indexed beneficiary,\\n        address indexed rewardOwner,\\n        address indexed recipient,\\n        uint24 rewardEpochId,\\n        ClaimType claimType,\\n        uint120 amount\\n    );\\n\\n    /**\\n     * Unclaimed rewards have expired and are now inaccessible.\\n     *\\n     * `getUnclaimedRewardState()` can be used to retrieve more information.\\n     * @param rewardEpochId Id of the reward epoch that has just expired.\\n     */\\n    event RewardClaimsExpired(uint256 indexed rewardEpochId);\\n\\n    /**\\n     * Emitted when reward claims have been enabled.\\n     * @param rewardEpochId First claimable reward epoch.\\n     */\\n    event RewardClaimsEnabled(uint256 indexed rewardEpochId);\\n\\n    /**\\n     * Claim rewards for `_rewardOwners` and their PDAs.\\n     * Rewards are deposited to the WNAT (to reward owner or PDA if enabled).\\n     * It can be called by reward owner or its authorized executor.\\n     * Only claiming from weight based claims is supported.\\n     * @param _rewardOwners Array of reward owners.\\n     * @param _rewardEpochId Id of the reward epoch up to which the rewards are claimed.\\n     * @param _proofs Array of reward claims with merkle proofs.\\n     */\\n    function autoClaim(\\n        address[] calldata _rewardOwners,\\n        uint24 _rewardEpochId,\\n        RewardClaimWithProof[] calldata _proofs\\n    ) external;\\n\\n    /**\\n     * Initialises weight based claims.\\n     * @param _proofs Array of reward claims with merkle proofs.\\n     */\\n    function initialiseWeightBasedClaims(\\n        RewardClaimWithProof[] calldata _proofs\\n    ) external;\\n\\n    /**\\n     * Returns the reward manager id.\\n     */\\n    function rewardManagerId() external view returns (uint256);\\n\\n    /**\\n     * Returns the number of weight based claims that have been initialised.\\n     * @param _rewardEpochId Reward epoch id.\\n     */\\n    function noOfInitialisedWeightBasedClaims(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256);\\n\\n    /**\\n     * Get the current cleanup block number.\\n     * @return The currently set cleanup block number.\\n     */\\n    function cleanupBlockNumber() external view returns (uint256);\\n\\n    /**\\n     * Returns the state of rewards for a given address at a specific reward epoch.\\n     * @param _rewardOwner Address of the reward owner.\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _rewardStates Array of reward states.\\n     */\\n    function getStateOfRewardsAt(\\n        address _rewardOwner,\\n        uint24 _rewardEpochId\\n    ) external view returns (RewardState[] memory _rewardStates);\\n\\n    /**\\n     * Gets the unclaimed reward state for a beneficiary, reward epoch id and claim type.\\n     * @param _beneficiary Address of the beneficiary to query.\\n     * @param _rewardEpochId Id of the reward epoch to query.\\n     * @param _claimType Claim type to query.\\n     * @return _state Unclaimed reward state.\\n     */\\n    function getUnclaimedRewardState(\\n        address _beneficiary,\\n        uint24 _rewardEpochId,\\n        ClaimType _claimType\\n    ) external view returns (UnclaimedRewardState memory _state);\\n\\n    /**\\n     * Returns totals.\\n     * @return _totalRewardsWei Total rewards (wei).\\n     * @return _totalInflationRewardsWei Total inflation rewards (wei).\\n     * @return _totalClaimedWei Total claimed rewards (wei).\\n     * @return _totalBurnedWei Total burned rewards (wei).\\n     */\\n    function getTotals()\\n        external\\n        view\\n        returns (\\n            uint256 _totalRewardsWei,\\n            uint256 _totalInflationRewardsWei,\\n            uint256 _totalClaimedWei,\\n            uint256 _totalBurnedWei\\n        );\\n\\n    /**\\n     * Returns reward epoch totals.\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _totalRewardsWei Total rewards (inflation + community) for the epoch (wei).\\n     * @return _totalInflationRewardsWei Total inflation rewards for the epoch (wei).\\n     * @return _initialisedRewardsWei Initialised rewards of all claim types for the epoch (wei).\\n     * @return _claimedRewardsWei Claimed rewards for the epoch (wei).\\n     * @return _burnedRewardsWei Burned rewards for the epoch (wei).\\n     */\\n    function getRewardEpochTotals(\\n        uint24 _rewardEpochId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 _totalRewardsWei,\\n            uint256 _totalInflationRewardsWei,\\n            uint256 _initialisedRewardsWei,\\n            uint256 _claimedRewardsWei,\\n            uint256 _burnedRewardsWei\\n        );\\n\\n    /**\\n     * Returns current reward epoch id.\\n     */\\n    function getCurrentRewardEpochId() external view returns (uint24);\\n\\n    /**\\n     * Returns initial reward epoch id.\\n     */\\n    function getInitialRewardEpochId() external view returns (uint256);\\n\\n    /**\\n     * Returns the reward epoch id that will expire next once a new reward epoch starts.\\n     */\\n    function getRewardEpochIdToExpireNext() external view returns (uint256);\\n\\n    /**\\n     * The first reward epoch id that was claimable.\\n     */\\n    function firstClaimableRewardEpochId() external view returns (uint24);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoRewardOffersManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoRewardOffersManager interface.\\n */\\ninterface IFtsoRewardOffersManager {\\n    /**\\n     * Defines a reward offer.\\n     */\\n    struct Offer {\\n        // amount (in wei) of reward in native coin\\n        uint120 amount;\\n        // feed id - i.e. category + base/quote symbol\\n        bytes21 feedId;\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS;\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM;\\n        // secondary band width in PPM (parts per million) in relation to the median\\n        uint24 secondaryBandWidthPPM;\\n        // address that can claim undistributed part of the reward (or burn address)\\n        address claimBackAddress;\\n    }\\n\\n    /// Event emitted when the minimal rewards offer value is set.\\n    event MinimalRewardsOfferValueSet(uint256 valueWei);\\n\\n    /// Event emitted when a reward offer is received.\\n    event RewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // feed id - i.e. category + base/quote symbol\\n        bytes21 feedId,\\n        // number of decimals (negative exponent)\\n        int8 decimals,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount,\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS,\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM,\\n        // secondary band width in PPM (parts per million) in relation to the median\\n        uint24 secondaryBandWidthPPM,\\n        // address that can claim undistributed part of the reward (or burn address)\\n        address claimBackAddress\\n    );\\n\\n    /// Event emitted when inflation rewards are offered.\\n    event InflationRewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // feed ids - i.e. category + base/quote symbols - multiple of 21 (one feedId is bytes21)\\n        bytes feedIds,\\n        // decimals encoded to - multiple of 1 (int8)\\n        bytes decimals,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount,\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS,\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM,\\n        // secondary band width in PPM (parts per million) in relation to the median - multiple of 3 (uint24)\\n        bytes secondaryBandWidthPPMs,\\n        // rewards split mode (0 means equally, 1 means random,...)\\n        uint16 mode\\n    );\\n\\n    /**\\n     * Allows community to offer rewards.\\n     * @param _nextRewardEpochId The next reward epoch id.\\n     * @param _offers The list of offers.\\n     */\\n    function offerRewards(\\n        uint24 _nextRewardEpochId,\\n        Offer[] calldata _offers\\n    ) external payable;\\n\\n    /**\\n     * Minimal rewards offer value (in wei).\\n     */\\n    function minimalRewardsOfferValueWei() external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedPublisher.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoFeedPublisher interface.\\n */\\ninterface IFtsoFeedPublisher {\\n    /// The FTSO feed struct.\\n    struct Feed {\\n        uint32 votingRoundId;\\n        bytes21 id;\\n        int32 value;\\n        uint16 turnoutBIPS;\\n        int8 decimals;\\n    }\\n\\n    /// The FTSO random struct.\\n    struct Random {\\n        uint32 votingRoundId;\\n        uint256 value;\\n        bool isSecure;\\n    }\\n\\n    /// The FTSO feed with proof struct.\\n    struct FeedWithProof {\\n        bytes32[] merkleProof;\\n        Feed body;\\n    }\\n\\n    /// Event emitted when a new feed is published.\\n    event FtsoFeedPublished(\\n        uint32 indexed votingRoundId,\\n        bytes21 indexed id,\\n        int32 value,\\n        uint16 turnoutBIPS,\\n        int8 decimals\\n    );\\n\\n    /**\\n     * Publishes feeds.\\n     * @param _proofs The FTSO feeds with proofs to publish.\\n     */\\n    function publish(FeedWithProof[] calldata _proofs) external;\\n\\n    /**\\n     *The FTSO protocol id.\\n     */\\n    function ftsoProtocolId() external view returns (uint8);\\n\\n    /**\\n     * The size of the feeds history.\\n     */\\n    function feedsHistorySize() external view returns (uint256);\\n\\n    /**\\n     * Returns the current feed.\\n     * @param _feedId Feed id.\\n     */\\n    function getCurrentFeed(\\n        bytes21 _feedId\\n    ) external view returns (Feed memory);\\n\\n    /**\\n     * Returns the feed for given voting round id.\\n     * @param _feedId Feed id.\\n     * @param _votingRoundId Voting round id.\\n     */\\n    function getFeed(\\n        bytes21 _feedId,\\n        uint256 _votingRoundId\\n    ) external view returns (Feed memory);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/ProtocolsV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Protocols V2 long term support interface.\\n */\\ninterface ProtocolsV2Interface {\\n    /**\\n     * Timestamp when the first reward epoch started, in seconds since UNIX epoch.\\n     */\\n    function firstRewardEpochStartTs() external view returns (uint64);\\n\\n    /**\\n     * Duration of reward epoch, in seconds.\\n     */\\n    function rewardEpochDurationSeconds() external view returns (uint64);\\n\\n    /**\\n     * Timestamp when the first voting epoch started, in seconds since UNIX epoch.\\n     */\\n    function firstVotingRoundStartTs() external view returns (uint64);\\n\\n    /**\\n     * Duration of voting epoch, in seconds.\\n     */\\n    function votingEpochDurationSeconds() external view returns (uint64);\\n\\n    /**\\n     * Returns the vote power block for given reward epoch id.\\n     */\\n    function getVotePowerBlock(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint64 _votePowerBlock);\\n\\n    /**\\n     * Returns the start voting round id for given reward epoch id.\\n     */\\n    function getStartVotingRoundId(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint32);\\n\\n    /**\\n     * Returns the current reward epoch id.\\n     */\\n    function getCurrentRewardEpochId() external view returns (uint24);\\n\\n    /**\\n     * Returns the current voting epoch id.\\n     */\\n    function getCurrentVotingEpochId() external view returns (uint32);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareSystemsManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./ProtocolsV2Interface.sol\\\";\\n\\n/**\\n * FlareSystemsManager interface.\\n */\\ninterface IFlareSystemsManager is ProtocolsV2Interface {\\n    /// Signature structure\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// Number of weight based claims structure\\n    struct NumberOfWeightBasedClaims {\\n        uint256 rewardManagerId;\\n        uint256 noOfWeightBasedClaims;\\n    }\\n\\n    /// Event emitted when random acquisition phase starts.\\n    event RandomAcquisitionStarted(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when vote power block is selected.\\n    event VotePowerBlockSelected(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint64 votePowerBlock, // Vote power block for given reward epoch\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when signing policy is signed.\\n    event SigningPolicySigned(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        address indexed signingPolicyAddress, // Address which signed this\\n        address indexed voter, // Voter (entity)\\n        uint64 timestamp, // Timestamp when this happened\\n        bool thresholdReached // Indicates if signing threshold was reached\\n    );\\n\\n    /// Event emitted when reward epoch starts.\\n    event RewardEpochStarted(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint32 startVotingRoundId, // First voting round id of validity\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when it is time to sign uptime vote.\\n    event SignUptimeVoteEnabled(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when uptime vote is submitted.\\n    event UptimeVoteSubmitted(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        address indexed signingPolicyAddress, // Address which signed this\\n        address indexed voter, // Voter (entity)\\n        bytes20[] nodeIds, // Node ids with high enough uptime\\n        uint64 timestamp // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when uptime vote is signed.\\n    event UptimeVoteSigned(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        address indexed signingPolicyAddress, // Address which signed this\\n        address indexed voter, // Voter (entity)\\n        bytes32 uptimeVoteHash, // Uptime vote hash\\n        uint64 timestamp, // Timestamp when this happened\\n        bool thresholdReached // Indicates if signing threshold was reached\\n    );\\n\\n    /// Event emitted when rewards are signed.\\n    event RewardsSigned(\\n        uint24 indexed rewardEpochId, // Reward epoch id\\n        address indexed signingPolicyAddress, // Address which signed this\\n        address indexed voter, // Voter (entity)\\n        bytes32 rewardsHash, // Rewards hash\\n        NumberOfWeightBasedClaims[] noOfWeightBasedClaims, // Number of weight based claims list\\n        uint64 timestamp, // Timestamp when this happened\\n        bool thresholdReached // Indicates if signing threshold was reached\\n    );\\n\\n    /**\\n     * Method for collecting signatures for the new signing policy.\\n     * @param _rewardEpochId Reward epoch id of the new signing policy.\\n     * @param _newSigningPolicyHash New signing policy hash.\\n     * @param _signature Signature.\\n     */\\n    function signNewSigningPolicy(\\n        uint24 _rewardEpochId,\\n        bytes32 _newSigningPolicyHash,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Method for submitting node ids with high enough uptime.\\n     * @param _rewardEpochId Reward epoch id of the uptime vote.\\n     * @param _nodeIds Node ids with high enough uptime.\\n     * @param _signature Signature.\\n     */\\n    function submitUptimeVote(\\n        uint24 _rewardEpochId,\\n        bytes20[] calldata _nodeIds,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Method for collecting signatures for the uptime vote.\\n     * @param _rewardEpochId Reward epoch id of the uptime vote.\\n     * @param _uptimeVoteHash Uptime vote hash.\\n     * @param _signature Signature.\\n     */\\n    function signUptimeVote(\\n        uint24 _rewardEpochId,\\n        bytes32 _uptimeVoteHash,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Method for collecting signatures for the rewards.\\n     * @param _rewardEpochId Reward epoch id of the rewards.\\n     * @param _noOfWeightBasedClaims Number of weight based claims list.\\n     * @param _rewardsHash Rewards hash.\\n     * @param _signature Signature.\\n     */\\n    function signRewards(\\n        uint24 _rewardEpochId,\\n        NumberOfWeightBasedClaims[] calldata _noOfWeightBasedClaims,\\n        bytes32 _rewardsHash,\\n        Signature calldata _signature\\n    ) external;\\n\\n    /**\\n     * Returns the seed for given reward epoch id.\\n     */\\n    function getSeed(uint256 _rewardEpochId) external view returns (uint256);\\n\\n    /**\\n     * Returns the threshold for given reward epoch id.\\n     */\\n    function getThreshold(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint16);\\n\\n    /**\\n     * Returns voter rgistration data for given reward epoch id.\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _votePowerBlock Vote power block.\\n     * @return _enabled Indicates if voter registration is enabled.\\n     */\\n    function getVoterRegistrationData(\\n        uint256 _rewardEpochId\\n    ) external view returns (uint256 _votePowerBlock, bool _enabled);\\n\\n    /**\\n     * Indicates if voter registration is currently enabled.\\n     */\\n    function isVoterRegistrationEnabled() external view returns (bool);\\n\\n    /**\\n     * Returns the current reward epoch id (backwards compatibility).\\n     */\\n    function getCurrentRewardEpoch() external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareSystemsCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FlareSystemsCalculator interface.\\n */\\ninterface IFlareSystemsCalculator {\\n    /// Event emitted when the registration weight of a voter is calculated.\\n    event VoterRegistrationInfo(\\n        address indexed voter,\\n        uint24 indexed rewardEpochId,\\n        address delegationAddress,\\n        uint16 delegationFeeBIPS,\\n        uint256 wNatWeight,\\n        uint256 wNatCappedWeight,\\n        bytes20[] nodeIds,\\n        uint256[] nodeWeights\\n    );\\n\\n    /// WNat cap used in signing policy weight.\\n    function wNatCapPPM() external view returns (uint24);\\n    /// Non-punishable time to sign new signing policy.\\n    function signingPolicySignNonPunishableDurationSeconds()\\n        external\\n        view\\n        returns (uint64);\\n    /// Number of non-punishable blocks to sign new signing policy.\\n    function signingPolicySignNonPunishableDurationBlocks()\\n        external\\n        view\\n        returns (uint64);\\n    /// Number of blocks (in addition to non-punishable blocks) after which all rewards are burned.\\n    function signingPolicySignNoRewardsDurationBlocks()\\n        external\\n        view\\n        returns (uint64);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedDecimals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoFeedDecimals interface.\\n */\\ninterface IFtsoFeedDecimals {\\n    /// Event emitted when a feed decimals value is changed.\\n    event DecimalsChanged(\\n        bytes21 indexed feedId,\\n        int8 decimals,\\n        uint24 rewardEpochId\\n    );\\n\\n    /// The offset in reward epochs for the decimals value to become effective.\\n    function decimalsUpdateOffset() external view returns (uint24);\\n\\n    /// The default decimals value.\\n    function defaultDecimals() external view returns (int8);\\n\\n    /**\\n     * Returns current decimals set for `_feedId`.\\n     * @param _feedId Feed id.\\n     */\\n    function getCurrentDecimals(bytes21 _feedId) external view returns (int8);\\n\\n    /**\\n     * Returns the decimals of `_feedId` for given reward epoch id.\\n     * @param _feedId Feed id.\\n     * @param _rewardEpochId Reward epoch id.\\n     * **NOTE:** decimals might still change for the `current + decimalsUpdateOffset` reward epoch id.\\n     */\\n    function getDecimals(\\n        bytes21 _feedId,\\n        uint256 _rewardEpochId\\n    ) external view returns (int8);\\n\\n    /**\\n     * Returns the scheduled decimals changes of `_feedId`.\\n     * @param _feedId Feed id.\\n     * @return _decimals Positional array of decimals.\\n     * @return _validFromEpochId Positional array of reward epoch ids the decimals settings are effective from.\\n     * @return _fixed Positional array of boolean values indicating if settings are subjected to change.\\n     */\\n    function getScheduledDecimalsChanges(\\n        bytes21 _feedId\\n    )\\n        external\\n        view\\n        returns (\\n            int8[] memory _decimals,\\n            uint256[] memory _validFromEpochId,\\n            bool[] memory _fixed\\n        );\\n\\n    /**\\n     * Returns current decimals setting for `_feedIds`.\\n     * @param _feedIds Concatenated feed ids (each feedId bytes21).\\n     * @return _decimals Concatenated corresponding decimals (each as bytes1(uint8(int8))).\\n     */\\n    function getCurrentDecimalsBulk(\\n        bytes memory _feedIds\\n    ) external view returns (bytes memory _decimals);\\n\\n    /**\\n     * Returns decimals setting for `_feedIds` at `_rewardEpochId`.\\n     * @param _feedIds Concatenated feed ids (each feedId bytes21).\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _decimals Concatenated corresponding decimals (each as bytes1(uint8(int8))).\\n     * **NOTE:** decimals might still change for the `current + decimalsUpdateOffset` reward epoch id.\\n     */\\n    function getDecimalsBulk(\\n        bytes memory _feedIds,\\n        uint256 _rewardEpochId\\n    ) external view returns (bytes memory _decimals);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IBn256.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n// G1Point implements a point in G1 group.\\nstruct G1Point {\\n    uint256 x;\\n    uint256 y;\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/ISortition.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {G1Point} from \\\"./IBn256.sol\\\";\\n\\nstruct SortitionCredential {\\n    uint256 replicate;\\n    G1Point gamma;\\n    uint256 c;\\n    uint256 s;\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFastUpdater.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {SortitionCredential} from \\\"./ISortition.sol\\\";\\n\\n/**\\n * Fast updater interface.\\n */\\ninterface IFastUpdater {\\n    /// Signature structure\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// Fast update structure\\n    struct FastUpdates {\\n        uint256 sortitionBlock;\\n        SortitionCredential sortitionCredential;\\n        bytes deltas;\\n        Signature signature;\\n    }\\n\\n    /// Event emitted when a new set of updates is submitted.\\n    event FastUpdateFeedsSubmitted(\\n        uint32 indexed votingRoundId,\\n        address indexed signingPolicyAddress\\n    );\\n\\n    /// Event emitted when a feed is added or reset.\\n    event FastUpdateFeedReset(\\n        uint256 indexed votingRoundId,\\n        uint256 indexed index,\\n        bytes21 indexed id,\\n        uint256 value,\\n        int8 decimals\\n    );\\n\\n    /// Event emitted when a feed is removed.\\n    event FastUpdateFeedRemoved(uint256 indexed index);\\n\\n    /// Event emitted at the start of a new voting epoch - current feeds' values and decimals.\\n    event FastUpdateFeeds(\\n        uint256 indexed votingEpochId,\\n        uint256[] feeds,\\n        int8[] decimals\\n    );\\n\\n    /**\\n     * The entry point for providers to submit an update transaction.\\n     * @param _updates Data of an update transaction, which in addition to the actual list of updates,\\n     * includes the sortition credential proving the provider's eligibility to make updates in the also-included\\n     * sortition round, as well as a signature allowing a single registered provider to submit from multiple\\n     * EVM accounts.\\n     */\\n    function submitUpdates(FastUpdates calldata _updates) external;\\n\\n    /**\\n     * Public access to the stored data of all feeds.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * **NOTE:** Overpayment is not refunded.\\n     * @return _feedIds The list of feed ids.\\n     * @return _feeds The list of feeds.\\n     * @return _decimals The list of decimal places for feeds.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function fetchAllCurrentFeeds()\\n        external\\n        payable\\n        returns (\\n            bytes21[] memory _feedIds,\\n            uint256[] memory _feeds,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Public access to the stored data of each feed, allowing controlled batch access to the lengthy complete data.\\n     * Feeds should be sorted for better performance.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * **NOTE:** Overpayment is not refunded.\\n     * @param _indices Index numbers of the feeds for which data should be returned, corresponding to `feedIds` in\\n     * the `FastUpdatesConfiguration` contract.\\n     * @return _feeds The list of data for the requested feeds, in the same order as the feed indices were given\\n     * (which may not be their sorted order).\\n     * @return _decimals The list of decimal places for the requested feeds, in the same order as the feed indices were\\n     * given (which may not be their sorted order).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function fetchCurrentFeeds(\\n        uint256[] calldata _indices\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256[] memory _feeds,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Informational getter concerning the eligibility criterion for being chosen by sortition.\\n     * @return _cutoff The upper endpoint of the acceptable range of \\\"scores\\\" that providers generate for sortition.\\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\\n     */\\n    function currentScoreCutoff() external view returns (uint256 _cutoff);\\n\\n    /**\\n     * Informational getter concerning the eligibility criterion for being chosen by sortition in a given block.\\n     * @param _blockNum The block for which the cutoff is requested.\\n     * @return _cutoff The upper endpoint of the acceptable range of \\\"scores\\\" that providers generate for sortition.\\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\\n     */\\n    function blockScoreCutoff(\\n        uint256 _blockNum\\n    ) external view returns (uint256 _cutoff);\\n\\n    /**\\n     * Informational getter concerning a provider's likelihood of being chosen by sortition.\\n     * @param _signingPolicyAddress The signing policy address of the specified provider. This is different from the\\n     * sender of an update transaction, due to the signature included in the `FastUpdates` type.\\n     * @return _weight The specified provider's weight for sortition purposes. This is derived from the provider's\\n     * delegation weight for the FTSO, but rescaled against a fixed number of \\\"virtual providers\\\", indicating how many\\n     * potential updates a single provider may make in a sortition round.\\n     */\\n    function currentSortitionWeight(\\n        address _signingPolicyAddress\\n    ) external view returns (uint256 _weight);\\n\\n    /**\\n     * The submission window is a number of blocks forming a \\\"grace period\\\" after a round of sortition starts,\\n     * during which providers may submit updates for that round. In other words, each block starts a new round of\\n     * sortition and that round lasts `submissionWindow` blocks.\\n     */\\n    function submissionWindow() external view returns (uint8);\\n\\n    /**\\n     * Id of the current reward epoch.\\n     */\\n    function currentRewardEpochId() external view returns (uint24);\\n\\n    /**\\n     * The number of updates submitted in each block for the last `_historySize` blocks (up to `MAX_BLOCKS_HISTORY`).\\n     * @param _historySize The number of blocks for which the number of updates should be returned.\\n     * @return _noOfUpdates The number of updates submitted in each block for the last `_historySize` blocks.\\n     * The array is ordered from the current block to the oldest block.\\n     */\\n    function numberOfUpdates(\\n        uint256 _historySize\\n    ) external view returns (uint256[] memory _noOfUpdates);\\n\\n    /**\\n     * The number of updates submitted in a block - available only for the last `MAX_BLOCKS_HISTORY` blocks.\\n     * @param _blockNumber The block number for which the number of updates should be returned.\\n     * @return _noOfUpdates The number of updates submitted in the specified block.\\n     */\\n    function numberOfUpdatesInBlock(\\n        uint256 _blockNumber\\n    ) external view returns (uint256 _noOfUpdates);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcRequestFeeConfigurations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FdcRequestFeeConfigurations interface.\\n */\\ninterface IFdcRequestFeeConfigurations {\\n    // Event emitted when a type and source price is set.\\n    event TypeAndSourceFeeSet(\\n        bytes32 indexed attestationType,\\n        bytes32 indexed source,\\n        uint256 fee\\n    );\\n\\n    // Event emitted when a type and source price is removed.\\n    event TypeAndSourceFeeRemoved(\\n        bytes32 indexed attestationType,\\n        bytes32 indexed source\\n    );\\n\\n    /**\\n     * Method to get the base fee for an attestation request. It reverts if the request is not supported.\\n     * @param _data ABI encoded attestation request\\n     */\\n    function getRequestFee(\\n        bytes calldata _data\\n    ) external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcInflationConfigurations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FdcInflationConfigurations interface.\\n */\\ninterface IFdcInflationConfigurations {\\n    /// The FDC configuration struct.\\n\\n    struct FdcConfiguration {\\n        // attestation type\\n        bytes32 attestationType;\\n        // source\\n        bytes32 source;\\n        // inflation share for this configuration\\n        uint24 inflationShare;\\n        // minimal reward eligibility threshold in number of request\\n        uint8 minRequestsThreshold;\\n        // mode (additional settings interpreted on the client side off-chain)\\n        uint224 mode;\\n    }\\n\\n    /**\\n     * Returns the FDC configuration at `_index`.\\n     * @param _index The index of the FDC configuration.\\n     */\\n    function getFdcConfiguration(\\n        uint256 _index\\n    ) external view returns (FdcConfiguration memory);\\n\\n    /**\\n     * Returns the FDC configurations.\\n     */\\n    function getFdcConfigurations()\\n        external\\n        view\\n        returns (FdcConfiguration[] memory);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcHub.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IFdcInflationConfigurations.sol\\\";\\nimport \\\"./IFdcRequestFeeConfigurations.sol\\\";\\n\\n/**\\n * FdcHub interface.\\n */\\ninterface IFdcHub {\\n    // Event emitted when an attestation request is made.\\n    event AttestationRequest(bytes data, uint256 fee);\\n\\n    // Event emitted when a requests offset is set.\\n    event RequestsOffsetSet(uint8 requestsOffsetSeconds);\\n\\n    /// Event emitted when inflation rewards are offered.\\n    event InflationRewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // fdc configurations\\n        IFdcInflationConfigurations.FdcConfiguration[] fdcConfigurations,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount\\n    );\\n\\n    /**\\n     * Method to request an attestation.\\n     * @param _data ABI encoded attestation request\\n     */\\n    function requestAttestation(bytes calldata _data) external payable;\\n\\n    /**\\n     * The offset (in seconds) for the requests to be processed during the current voting round.\\n     */\\n    function requestsOffsetSeconds() external view returns (uint8);\\n\\n    /**\\n     * The FDC inflation configurations contract.\\n     */\\n    function fdcInflationConfigurations()\\n        external\\n        view\\n        returns (IFdcInflationConfigurations);\\n\\n    /**\\n     * The FDC request fee configurations contract.\\n     */\\n    function fdcRequestFeeConfigurations()\\n        external\\n        view\\n        returns (IFdcRequestFeeConfigurations);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFastUpdatesConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FastUpdatesConfiguration interface.\\n */\\ninterface IFastUpdatesConfiguration {\\n    /**\\n     * The feed configuration struct.\\n     */\\n    struct FeedConfiguration {\\n        // feed id\\n        bytes21 feedId;\\n        // reward band value (interpreted off-chain) in relation to the median\\n        uint32 rewardBandValue;\\n        // inflation share\\n        uint24 inflationShare;\\n    }\\n\\n    /// Event emitted when a feed is added.\\n    event FeedAdded(\\n        bytes21 indexed feedId,\\n        uint32 rewardBandValue,\\n        uint24 inflationShare,\\n        uint256 index\\n    );\\n    /// Event emitted when a feed is updated.\\n    event FeedUpdated(\\n        bytes21 indexed feedId,\\n        uint32 rewardBandValue,\\n        uint24 inflationShare,\\n        uint256 index\\n    );\\n    /// Event emitted when a feed is removed.\\n    event FeedRemoved(bytes21 indexed feedId, uint256 index);\\n\\n    /**\\n     * Returns the index of a feed.\\n     * @param _feedId The feed id.\\n     * @return _index The index of the feed.\\n     */\\n    function getFeedIndex(\\n        bytes21 _feedId\\n    ) external view returns (uint256 _index);\\n\\n    /**\\n     * Returns the feed id at a given index. Removed (unused) feed index will return bytes21(0).\\n     * @param _index The index.\\n     * @return _feedId The feed id.\\n     */\\n    function getFeedId(uint256 _index) external view returns (bytes21 _feedId);\\n\\n    /**\\n     * Returns all feed ids. For removed (unused) feed indices, the feed id will be bytes21(0).\\n     */\\n    function getFeedIds() external view returns (bytes21[] memory);\\n\\n    /**\\n     * Returns the number of feeds, including removed ones.\\n     */\\n    function getNumberOfFeeds() external view returns (uint256);\\n\\n    /**\\n     * Returns the feed configurations, including removed ones.\\n     */\\n    function getFeedConfigurations()\\n        external\\n        view\\n        returns (FeedConfiguration[] memory);\\n\\n    /**\\n     * Returns the unused indices - indices of removed feeds.\\n     */\\n    function getUnusedIndices() external view returns (uint256[] memory);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IIncreaseManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Increase manager interface.\\n */\\ninterface IIncreaseManager {\\n    function getIncentiveDuration() external view returns (uint256);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFixedPointArithmetic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/*\\n * Opaque type synonyms to enforce arithemtic correctness.\\n * All of these are internally uint256 to avert solc's restricted-bit-size internal handling.\\n * Since the space is available, the fractional parts of all (except Price,\\n * which is not controlled by us) are very wide.\\n */\\n\\ntype Scale is uint256; // 1x127\\ntype Precision is uint256; // 0x127; the fractional part of Scale, top bit always 0\\ntype SampleSize is uint256; // 8x120; current gas usage and block gas limit force <32 update transactions per block\\ntype Range is uint256; // 8x120, with some space for >100% fluctuations\\n// (measured volatility per block is ~1e-3 at most)\\ntype Fractional is uint256; // 0x128\\n\\ntype Fee is uint256; // 128x0; same scale as currency units,restricted to bottom 128 bits\\n// (1e18 integer and fractional parts) to accommodate arithmetic\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFastUpdateIncentiveManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IFixedPointArithmetic.sol\\\" as FPA;\\nimport \\\"./IFastUpdatesConfiguration.sol\\\";\\nimport \\\"./IIncreaseManager.sol\\\";\\n\\n/**\\n * Fast update incentive manager interface.\\n */\\ninterface IFastUpdateIncentiveManager is IIncreaseManager {\\n    /// Incentive offer structure.\\n    struct IncentiveOffer {\\n        FPA.Range rangeIncrease;\\n        FPA.Range rangeLimit;\\n    }\\n\\n    /// Event emitted when an incentive is offered.\\n    event IncentiveOffered(\\n        uint24 indexed rewardEpochId,\\n        FPA.Range rangeIncrease,\\n        FPA.SampleSize sampleSizeIncrease,\\n        FPA.Fee offerAmount\\n    );\\n\\n    /// Event emitted when inflation rewards are offered.\\n    event InflationRewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // feed configurations\\n        IFastUpdatesConfiguration.FeedConfiguration[] feedConfigurations,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount\\n    );\\n\\n    /**\\n     * The entry point for third parties to make incentive offers. It accepts a payment and, using the contents of\\n     * `_offer`, computes how much the expected sample size will be increased to apply the requested (but capped) range\\n     * increase. If the ultimate value of the range exceeds the cap, funds are returned to the sender in proportion to\\n     * the amount by which the increase is adjusted to reach the cap.\\n     * @param _offer The requested amount of per-block variation range increase,\\n     * along with a cap for the ultimate range.\\n     */\\n    function offerIncentive(IncentiveOffer calldata _offer) external payable;\\n\\n    /// Viewer for the current value of the expected sample size.\\n    function getExpectedSampleSize() external view returns (FPA.SampleSize);\\n\\n    /// Viewer for the current value of the unit delta's precision (the fractional part of the scale).\\n    function getPrecision() external view returns (FPA.Precision);\\n\\n    /// Viewer for the current value of the per-block variation range.\\n    function getRange() external view returns (FPA.Range);\\n\\n    /// Viewer for the current value of sample size increase price.\\n    function getCurrentSampleSizeIncreasePrice()\\n        external\\n        view\\n        returns (FPA.Fee);\\n\\n    /// Viewer for the current value of the scale itself.\\n    function getScale() external view returns (FPA.Scale);\\n\\n    /// Viewer for the base value of the scale itself.\\n    function getBaseScale() external view returns (FPA.Scale);\\n\\n    /// The maximum amount by which the expected sample size can be increased by an incentive offer.\\n    /// This is controlled by governance and forces a minimum cost to increasing the sample size greatly,\\n    /// which would otherwise be an attack on the protocol.\\n    function sampleIncreaseLimit() external view returns (FPA.SampleSize);\\n\\n    /// The maximum value that the range can be increased to by an incentive offer.\\n    function rangeIncreaseLimit() external view returns (FPA.Range);\\n\\n    /// The price for increasing the per-block range of variation by 1, prorated for the actual amount of increase.\\n    function rangeIncreasePrice() external view returns (FPA.Fee);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IJsonApi.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IJsonApi\\n * @custom:supported WEB2\\n * @author Flare\\n * @notice An attestation request that fetches data from the given url and then edits the information with a\\n * jq transformation.\\n * @custom:verification  Data is fetched from an url `url`. The received data is then processed with jq as\\n * the `postprocessJq` states. The structure of the final json is written in the `abi_signature`.\\n *\\n * The response contains an abi encoding of the final data.\\n * @custom:lut `0xffffffffffffffff`\\n * @custom:lut-limit `0xffffffffffffffff`\\n */\\ninterface IJsonApi {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\\n     * by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for Payment attestation type\\n     * @param url URL of the data source\\n     * @param postprocessJq jq filter to postprocess the data\\n     * @param abi_signature ABI signature of the data\\n     */\\n    struct RequestBody {\\n        string url;\\n        string postprocessJq;\\n        string abi_signature;\\n    }\\n\\n    /**\\n     * @notice Response body for Payment attestation type\\n     * @param abi_encoded_data ABI encoded data\\n     */\\n    struct ResponseBody {\\n        bytes abi_encoded_data;\\n    }\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IJsonApiVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IJsonApi.sol\\\";\\n\\ninterface IJsonApiVerification {\\n    function verifyJsonApi(\\n        IJsonApi.Proof calldata _proof\\n    ) external view returns (bool _proved);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAssetManagerController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IAssetManager} from \\\"./IAssetManager.sol\\\";\\n\\ninterface IAssetManagerController {\\n    /**\\n     * Return the list of all asset managers managed by this controller.\\n     */\\n    function getAssetManagers() external view returns (IAssetManager[] memory);\\n\\n    /**\\n     * Check whether the asset manager is managed by this controller.\\n     * @param _assetManager an asset manager address\\n     */\\n    function assetManagerExists(\\n        address _assetManager\\n    ) external view returns (bool);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/IGenericRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IGenericRewardManager {\\n    event RewardClaimed(\\n        address indexed beneficiary,\\n        address indexed sentTo,\\n        uint256 amount\\n    );\\n\\n    event RewardsDistributed(address[] addresses, uint256[] rewards);\\n\\n    event ClaimExecutorsChanged(address rewardOwner, address[] executors);\\n\\n    event AllowedClaimRecipientsChanged(\\n        address rewardOwner,\\n        address[] recipients\\n    );\\n\\n    event RewardManagerActivated(address rewardManager);\\n    event RewardManagerDeactivated(address rewardManager);\\n\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf.\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner or\\n     *   one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardAmount         amount of rewards to claim\\n     * @param _wrap                 should reward be wrapped immediately\\n     */\\n    function claim(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint256 _rewardAmount,\\n        bool _wrap\\n    ) external;\\n\\n    /**\\n     * Set the addresses of executors, who are allowed to call `claim`.\\n     * @param _executors The new executors. All old executors will be deleted and replaced by these.\\n     */\\n    function setClaimExecutors(address[] memory _executors) external;\\n\\n    /**\\n     * Set the addresses of allowed recipients in the methods `claim`.\\n     * Apart from these, the reward owner is always an allowed recipient.\\n     * @param _recipients The new allowed recipients. All old recipients will be deleted and replaced by these.\\n     */\\n    function setAllowedClaimRecipients(address[] memory _recipients) external;\\n\\n    /**\\n     * @notice Allows reward claiming\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * @notice Returns information of beneficiary rewards\\n     * @param _beneficiary          beneficiary address\\n     * @return _totalReward         number representing the total reward\\n     * @return _claimedReward       number representing the amount of total reward that has been claimed\\n     */\\n    function getStateOfRewards(\\n        address _beneficiary\\n    ) external view returns (uint256 _totalReward, uint256 _claimedReward);\\n\\n    /**\\n     * Get the addresses of executors, who are allowed to call `claim`.\\n     */\\n    function claimExecutors(\\n        address _rewardOwner\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * Get the addresses of allowed recipients in the methods `claim`.\\n     * Apart from these, the reward owner is always an allowed recipient.\\n     */\\n    function allowedClaimRecipients(\\n        address _rewardOwner\\n    ) external view returns (address[] memory);\\n}\\n\",\"versionPragma\":\">=0.7.6 <0.9\"},\"@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.25;\\n\\nimport {IFlareContractRegistry} from \\\"./IFlareContractRegistry.sol\\\";\\n// AUTO GENERATED - DO NOT EDIT BELOW THIS LINE\\nimport {IPriceSubmitter} from \\\"./IPriceSubmitter.sol\\\";\\nimport {IGovernanceSettings} from \\\"./IGovernanceSettings.sol\\\";\\nimport {IFtsoRewardManager} from \\\"./IFtsoRewardManager.sol\\\";\\nimport {IFtsoRegistry} from \\\"./IFtsoRegistry.sol\\\";\\nimport {IVoterWhitelister} from \\\"./IVoterWhitelister.sol\\\";\\nimport {IFtsoManager} from \\\"./IFtsoManager.sol\\\";\\nimport {IWNat} from \\\"./IWNat.sol\\\";\\nimport {IGovernanceVotePower} from \\\"./IGovernanceVotePower.sol\\\";\\nimport {IClaimSetupManager} from \\\"./IClaimSetupManager.sol\\\";\\nimport {IFlareAssetRegistry} from \\\"./IFlareAssetRegistry.sol\\\";\\nimport {IFlareContractRegistry} from \\\"./IFlareContractRegistry.sol\\\";\\nimport {ISubmission} from \\\"./ISubmission.sol\\\";\\nimport {IEntityManager} from \\\"./IEntityManager.sol\\\";\\nimport {IVoterRegistry} from \\\"./IVoterRegistry.sol\\\";\\nimport {IFlareSystemsCalculator} from \\\"./IFlareSystemsCalculator.sol\\\";\\nimport {IFlareSystemsManager} from \\\"./IFlareSystemsManager.sol\\\";\\nimport {IRewardManager} from \\\"./IRewardManager.sol\\\";\\nimport {IRelay} from \\\"./IRelay.sol\\\";\\nimport {IWNatDelegationFee} from \\\"./IWNatDelegationFee.sol\\\";\\nimport {IFtsoInflationConfigurations} from \\\"./IFtsoInflationConfigurations.sol\\\";\\nimport {IFtsoRewardOffersManager} from \\\"./IFtsoRewardOffersManager.sol\\\";\\nimport {IFtsoFeedDecimals} from \\\"./IFtsoFeedDecimals.sol\\\";\\nimport {IFtsoFeedPublisher} from \\\"./IFtsoFeedPublisher.sol\\\";\\nimport {IFtsoFeedIdConverter} from \\\"./IFtsoFeedIdConverter.sol\\\";\\nimport {IFastUpdateIncentiveManager} from \\\"./IFastUpdateIncentiveManager.sol\\\";\\nimport {IFastUpdater} from \\\"./IFastUpdater.sol\\\";\\nimport {IFastUpdatesConfiguration} from \\\"./IFastUpdatesConfiguration.sol\\\";\\nimport {IFeeCalculator} from \\\"./IFeeCalculator.sol\\\";\\nimport {FtsoV2Interface} from \\\"./FtsoV2Interface.sol\\\";\\nimport {TestFtsoV2Interface} from \\\"./TestFtsoV2Interface.sol\\\";\\nimport {ProtocolsV2Interface} from \\\"./ProtocolsV2Interface.sol\\\";\\nimport {RandomNumberV2Interface} from \\\"./RandomNumberV2Interface.sol\\\";\\nimport {RewardsV2Interface} from \\\"./RewardsV2Interface.sol\\\";\\nimport {IFdcVerification} from \\\"./IFdcVerification.sol\\\";\\nimport {IFdcHub} from \\\"./IFdcHub.sol\\\";\\nimport {IFdcRequestFeeConfigurations} from \\\"./IFdcRequestFeeConfigurations.sol\\\";\\nimport {IAssetManagerController} from \\\"./IAssetManagerController.sol\\\";\\nimport {IAssetManager} from \\\"./IAssetManager.sol\\\";\\nimport {IJsonApiVerification} from \\\"./IJsonApiVerification.sol\\\";\\nimport {IGenericRewardManager} from \\\"./IGenericRewardManager.sol\\\";\\n// END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE\\n\\n// Library is intended to be used inline, so the strings are all memory allocated (instead of calldata)\\nlibrary ContractRegistry {\\n    address internal constant FLARE_CONTRACT_REGISTRY_ADDRESS =\\n        0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019;\\n\\n    IFlareContractRegistry internal constant FLARE_CONTRACT_REGISTRY =\\n        IFlareContractRegistry(FLARE_CONTRACT_REGISTRY_ADDRESS);\\n\\n    /**\\n     * @notice Returns contract address for the given name - might be address(0)\\n     * @param _name             name of the contract\\n     */\\n    function getContractAddressByName(\\n        string memory _name\\n    ) internal view returns (address) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressByName(_name);\\n    }\\n\\n    /**\\n     * @notice Returns contract address for the given name hash - might be address(0)\\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressByHash(\\n        bytes32 _nameHash\\n    ) internal view returns (address) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressByHash(_nameHash);\\n    }\\n\\n    /**\\n     * @notice Returns contract addresses for the given names - might be address(0)\\n     * @param _names            names of the contracts\\n     */\\n    function getContractAddressesByName(\\n        string[] memory _names\\n    ) internal view returns (address[] memory) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressesByName(_names);\\n    }\\n\\n    /**\\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressesByHash(\\n        bytes32[] memory _nameHashes\\n    ) internal view returns (address[] memory) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressesByHash(_nameHashes);\\n    }\\n\\n    /**\\n     * @notice Returns all contract names and corresponding addresses\\n     */\\n    function getAllContracts()\\n        internal\\n        view\\n        returns (string[] memory _names, address[] memory _addresses)\\n    {\\n        return FLARE_CONTRACT_REGISTRY.getAllContracts();\\n    }\\n\\n    // Nice typed getters for all the important contracts\\n    // AUTO GENERATED - DO NOT EDIT BELOW THIS LINE\\n    function getPriceSubmitter() internal view returns (IPriceSubmitter) {\\n        return\\n            IPriceSubmitter(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"PriceSubmitter\\\"))\\n                )\\n            );\\n    }\\n\\n    function getGovernanceSettings()\\n        internal\\n        view\\n        returns (IGovernanceSettings)\\n    {\\n        return\\n            IGovernanceSettings(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"GovernanceSettings\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoRewardManager() internal view returns (IFtsoRewardManager) {\\n        return\\n            IFtsoRewardManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoRewardManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoRegistry() internal view returns (IFtsoRegistry) {\\n        return\\n            IFtsoRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getVoterWhitelister() internal view returns (IVoterWhitelister) {\\n        return\\n            IVoterWhitelister(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"VoterWhitelister\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoManager() internal view returns (IFtsoManager) {\\n        return\\n            IFtsoManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getWNat() internal view returns (IWNat) {\\n        return\\n            IWNat(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"WNat\\\"))\\n                )\\n            );\\n    }\\n\\n    function getGovernanceVotePower()\\n        internal\\n        view\\n        returns (IGovernanceVotePower)\\n    {\\n        return\\n            IGovernanceVotePower(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"GovernanceVotePower\\\"))\\n                )\\n            );\\n    }\\n\\n    function getClaimSetupManager() internal view returns (IClaimSetupManager) {\\n        return\\n            IClaimSetupManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ClaimSetupManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareAssetRegistry()\\n        internal\\n        view\\n        returns (IFlareAssetRegistry)\\n    {\\n        return\\n            IFlareAssetRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareAssetRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareContractRegistry()\\n        internal\\n        view\\n        returns (IFlareContractRegistry)\\n    {\\n        return\\n            IFlareContractRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareContractRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getSubmission() internal view returns (ISubmission) {\\n        return\\n            ISubmission(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"Submission\\\"))\\n                )\\n            );\\n    }\\n\\n    function getEntityManager() internal view returns (IEntityManager) {\\n        return\\n            IEntityManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"EntityManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getVoterRegistry() internal view returns (IVoterRegistry) {\\n        return\\n            IVoterRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"VoterRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareSystemsCalculator()\\n        internal\\n        view\\n        returns (IFlareSystemsCalculator)\\n    {\\n        return\\n            IFlareSystemsCalculator(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareSystemsCalculator\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareSystemsManager()\\n        internal\\n        view\\n        returns (IFlareSystemsManager)\\n    {\\n        return\\n            IFlareSystemsManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareSystemsManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRewardManager() internal view returns (IRewardManager) {\\n        return\\n            IRewardManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RewardManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRelay() internal view returns (IRelay) {\\n        return\\n            IRelay(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"Relay\\\"))\\n                )\\n            );\\n    }\\n\\n    function getWNatDelegationFee() internal view returns (IWNatDelegationFee) {\\n        return\\n            IWNatDelegationFee(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"WNatDelegationFee\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoInflationConfigurations()\\n        internal\\n        view\\n        returns (IFtsoInflationConfigurations)\\n    {\\n        return\\n            IFtsoInflationConfigurations(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoInflationConfigurations\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoRewardOffersManager()\\n        internal\\n        view\\n        returns (IFtsoRewardOffersManager)\\n    {\\n        return\\n            IFtsoRewardOffersManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoRewardOffersManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoFeedDecimals() internal view returns (IFtsoFeedDecimals) {\\n        return\\n            IFtsoFeedDecimals(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoFeedDecimals\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoFeedPublisher() internal view returns (IFtsoFeedPublisher) {\\n        return\\n            IFtsoFeedPublisher(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoFeedPublisher\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoFeedIdConverter()\\n        internal\\n        view\\n        returns (IFtsoFeedIdConverter)\\n    {\\n        return\\n            IFtsoFeedIdConverter(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoFeedIdConverter\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFastUpdateIncentiveManager()\\n        internal\\n        view\\n        returns (IFastUpdateIncentiveManager)\\n    {\\n        return\\n            IFastUpdateIncentiveManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FastUpdateIncentiveManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFastUpdater() internal view returns (IFastUpdater) {\\n        return\\n            IFastUpdater(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FastUpdater\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFastUpdatesConfiguration()\\n        internal\\n        view\\n        returns (IFastUpdatesConfiguration)\\n    {\\n        return\\n            IFastUpdatesConfiguration(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FastUpdatesConfiguration\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFeeCalculator() internal view returns (IFeeCalculator) {\\n        return\\n            IFeeCalculator(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FeeCalculator\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoV2() internal view returns (FtsoV2Interface) {\\n        return\\n            FtsoV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getTestFtsoV2() internal view returns (TestFtsoV2Interface) {\\n        return\\n            TestFtsoV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getProtocolsV2() internal view returns (ProtocolsV2Interface) {\\n        return\\n            ProtocolsV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ProtocolsV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRandomNumberV2()\\n        internal\\n        view\\n        returns (RandomNumberV2Interface)\\n    {\\n        return\\n            RandomNumberV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RandomNumberV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRewardsV2() internal view returns (RewardsV2Interface) {\\n        return\\n            RewardsV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RewardsV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFdcVerification() internal view returns (IFdcVerification) {\\n        return\\n            IFdcVerification(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FdcVerification\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFdcHub() internal view returns (IFdcHub) {\\n        return\\n            IFdcHub(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FdcHub\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFdcRequestFeeConfigurations()\\n        internal\\n        view\\n        returns (IFdcRequestFeeConfigurations)\\n    {\\n        return\\n            IFdcRequestFeeConfigurations(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FdcRequestFeeConfigurations\\\"))\\n                )\\n            );\\n    }\\n\\n    function getAssetManagerController()\\n        internal\\n        view\\n        returns (IAssetManagerController)\\n    {\\n        return\\n            IAssetManagerController(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"AssetManagerController\\\"))\\n                )\\n            );\\n    }\\n\\n    function getAssetManagerFXRP() internal view returns (IAssetManager) {\\n        return\\n            IAssetManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"AssetManagerFXRP\\\"))\\n                )\\n            );\\n    }\\n\\n    function auxiliaryGetIJsonApiVerification()\\n        internal\\n        pure\\n        returns (IJsonApiVerification)\\n    {\\n        return IJsonApiVerification(0x07ad8508C9173DC845817472Ca0484035AbFA3c8);\\n    }\\n\\n    function getValidatorRewardManager()\\n        internal\\n        view\\n        returns (IGenericRewardManager)\\n    {\\n        return\\n            IGenericRewardManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ValidatorRewardManager\\\"))\\n                )\\n            );\\n    }\\n\\n    // END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE\\n}\\n\",\"versionPragma\":\"^0.8.25\"}}}","address":"0x7845fF302E85389E88c12F24D9cF479A56e3Dab0","bytecode":"0x608060405234801561000f575f80fd5b506040516123ef3803806123ef83398101604081905261002e91610137565b826001600160a01b03811661005c57604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b610065816100cd565b5060018055600d80546001600160a01b038085166001600160a01b03199283161790925560088054928416929091169190911790556040805180820190915260068152651899199a1a9b60d11b60208201526009906100c4908261020f565b505050506102ce565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b0381168114610132575f80fd5b919050565b5f805f60608486031215610149575f80fd5b6101528461011c565b92506101606020850161011c565b915061016e6040850161011c565b90509250925092565b634e487b7160e01b5f52604160045260245ffd5b600181811c9082168061019f57607f821691505b6020821081036101bd57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561020a57805f5260205f20601f840160051c810160208510156101e85750805b601f840160051c820191505b81811015610207575f81556001016101f4565b50505b505050565b81516001600160401b0381111561022857610228610177565b61023c81610236845461018b565b846101c3565b602080601f83116001811461026f575f84156102585750858301515b5f19600386901b1c1916600185901b1785556102c6565b5f85815260208120601f198616915b8281101561029d5788860151825594840194600190910190840161027e565b50858210156102ba57878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b612114806102db5f395ff3fe60806040526004361061014a575f3560e01c80638193efaa116100b3578063ae438db11161006d578063ae438db114610489578063b2745564146104aa578063d37b2d14146104bf578063ecfb49a3146104de578063ed88c68e146104f3578063f2fde38b146104fb575f80fd5b80638193efaa146103a157806381d12c58146103c0578063846ed207146103f25780638da5cb5b146104235780639bf070b61461043f578063a1b45b581461045e575f80fd5b80634681fdd2116101045780634681fdd2146102d85780635d97b3cd146102f757806366fa7c46146103165780636a84a98514610355578063715018a61461036a578063748d511a1461037e575f80fd5b806311d7184d146101d157806313d4d9721461020d5780632d9e33c8146102315780632fbde6b31461025057806338d212421461028e578063401fb22b146102b9575f80fd5b366101cd573460035f8282546101609190611564565b9091555050335f9081526007602052604081208054349290610183908490611564565b90915550506040805134815242602082015233917fd97bcdf12fa1d5342fc942da5eadf35c7597f34f8da7274c2b0d2ad979842679910160405180910390a26101cb3361051a565b005b5f80fd5b3480156101dc575f80fd5b506008546101f0906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b348015610218575f80fd5b50610223620f424081565b604051908152602001610204565b34801561023c575f80fd5b5061022361024b3660046115c2565b610612565b34801561025b575f80fd5b5061027e61026a366004611636565b60056020525f908152604090205460ff1681565b6040519015158152602001610204565b348015610299575f80fd5b506102236102a8366004611671565b60076020525f908152604090205481565b3480156102c4575f80fd5b5061027e6102d33660046116a2565b6107eb565b3480156102e3575f80fd5b506101cb6102f2366004611636565b61086a565b348015610302575f80fd5b506101cb610311366004611636565b610966565b348015610321575f80fd5b50610335610330366004611671565b61097a565b604080519485526020850193909352918301526060820152608001610204565b348015610360575f80fd5b5061022360025481565b348015610375575f80fd5b506101cb610a61565b348015610389575f80fd5b50610392610a74565b6040516102049392919061171f565b3480156103ac575f80fd5b506101cb6103bb366004611752565b610b28565b3480156103cb575f80fd5b506103df6103da366004611636565b610e73565b60405161020497969594939291906117bd565b3480156103fd575f80fd5b5061041161040c366004611636565b610fd1565b60405161020496959493929190611817565b34801561042e575f80fd5b505f546001600160a01b03166101f0565b34801561044a575f80fd5b50610223610459366004611636565b61109a565b348015610469575f80fd5b50610223610478366004611671565b60066020525f908152604090205481565b348015610494575f80fd5b5061049d6110b9565b604051610204919061185e565b3480156104b5575f80fd5b5061022360045481565b3480156104ca575f80fd5b50600d546101f0906001600160a01b031681565b3480156104e9575f80fd5b5061022360035481565b6101cb611145565b348015610506575f80fd5b506101cb610515366004611671565b6111fb565b6001600160a01b0381165f9081526007602090815260408083205460069092528220546105479190611564565b9050678ac7230489e80000811061060e57600d5460405163128dbdb960e21b81526001600160a01b0384811660048301525f921690634a36f6e4906024016020604051808303815f875af11580156105a1573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105c59190611870565b60408051828152602081018590529192506001600160a01b038516917f3f1171297c35ca225263338ac9a229d96149e8c1eea55d597eaa85b135f8640a910160405180910390a2505b5050565b600280545f918291908261062583611887565b90915550604080516101206020601f8b01819004028201810190925261010081018981529293509182918a908a90819085018382808284375f920191909152505050908252503360208083019190915260408051601f880183900483028101830182528781529201919087908790819084018382808284375f9201829052509385525050506020808301899052604080840183905260608401839052608084018390528051838152808301825260a090940193909352848252600a905220815181906106f19082611931565b5060208201516001820180546001600160a01b0319166001600160a01b039092169190911790556040820151600282019061072c9082611931565b5060608201516003820155608082015160048201805460a085015115156101000261ff00199315159390931661ffff199091161791909117905560c0820151600582015560e0820151805161078b9160068401916020909101906114d9565b50905050807fe0b645c4fd45ece69cc31b0f8633c801e9e2b98a2b1a429efa597f1dace80f6088888888886040516107c7959493929190611a19565b60405180910390a284600354106107e1576107e181611235565b9695505050505050565b5f806107f5611365565b6040516358fbe9e160e01b81529091506001600160a01b038216906358fbe9e190610824908690600401611d9f565b602060405180830381865afa15801561083f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108639190611edd565b9392505050565b610872611434565b5f818152600a60205260409020600481015460ff166108c55760405162461bcd60e51b815260206004820152600a602482015269139bdd08199d5b99195960b21b60448201526064015b60405180910390fd5b6004810154610100900460ff161561090e5760405162461bcd60e51b815260206004820152600c60248201526b105b1c9958591e481c185a5960a21b60448201526064016108bc565b60048101805461ff001916610100179055600381015460405183917f1d6c1911dff15af6ed91890c881c1b34646051b66fd5a2bde246eb7c8ee0e7569161095a91906002860190611f71565b60405180910390a25050565b61096e611434565b61097781611235565b50565b6001600160a01b0381165f9081526006602090815260408083205460079092528220549091806109aa8385611564565b91505f90505f5b600254811015610a59575f818152600a602052604090206004015460ff1615610a51575f5b5f828152600a6020526040902060060154811015610a4f575f828152600a6020526040902060060180546001600160a01b038916919083908110610a1c57610a1c611f89565b5f918252602090912001546001600160a01b031603610a475782610a3f81611887565b935050610a4f565b6001016109d6565b505b6001016109b1565b509193509193565b610a69611434565b610a725f611460565b565b5f60605f60085f9054906101000a90046001600160a01b03166009620f4240818054610a9f906118b3565b80601f0160208091040260200160405190810160405280929190818152602001828054610acb906118b3565b8015610b165780601f10610aed57610100808354040283529160200191610b16565b820191905f5260205f20905b815481529060010190602001808311610af957829003601f168201915b50505050509150925092509250909192565b610b306114af565b5f610b3e6020860186611f9d565b610b4c906080810190611fbb565b355f8181526005602052604090205490915060ff1615610bae5760405162461bcd60e51b815260206004820152601d60248201527f5472616e73616374696f6e20616c72656164792070726f63657373656400000060448201526064016108bc565b610bb7856107eb565b610c035760405162461bcd60e51b815260206004820152601e60248201527f496e76616c6964205852504c207472616e73616374696f6e2070726f6f66000060448201526064016108bc565b5f818152600560205260408120805460ff19166001179055610c28620f424084611fcf565b9050670de0b6b3a7640000811015610c825760405162461bcd60e51b815260206004820152601860248201527f4d696e696d756d20646f6e6174696f6e206e6f74206d6574000000000000000060448201526064016108bc565b8260045f828254610c939190611564565b925050819055508060035f828254610cab9190611564565b9091555050335f9081526006602052604081208054859290610cce908490611564565b90915550506040515f90610cec908790879033904290602001611fee565b6040516020818303038152906040528051906020012090506040518060c00160405280336001600160a01b0316815260200183815260200185815260200142815260200187878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920182905250938552505060016020938401819052858352600b8452604092839020855181546001600160a01b0319166001600160a01b0390911617815593850151908401555082015160028201556060820151600382015560808201516004820190610dc89082611931565b5060a091909101516005909101805460ff1916911515919091179055600c80546001810182555f919091527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c70181905560405133907f1d58ae764d4ee47d6fb4cd691ccb1c215b66fd1a23940dd16cc230c2aea6181790610e509087908a908a90889061201e565b60405180910390a2610e613361051a565b505050610e6d60018055565b50505050565b600a6020525f9081526040902080548190610e8d906118b3565b80601f0160208091040260200160405190810160405280929190818152602001828054610eb9906118b3565b8015610f045780601f10610edb57610100808354040283529160200191610f04565b820191905f5260205f20905b815481529060010190602001808311610ee757829003601f168201915b505050600184015460028501805494956001600160a01b03909216949193509150610f2e906118b3565b80601f0160208091040260200160405190810160405280929190818152602001828054610f5a906118b3565b8015610fa55780601f10610f7c57610100808354040283529160200191610fa5565b820191905f5260205f20905b815481529060010190602001808311610f8857829003601f168201915b505050600384015460048501546005909501549394909360ff8083169450610100909204909116915087565b600b6020525f9081526040902080546001820154600283015460038401546004850180546001600160a01b0390951695939492939192611010906118b3565b80601f016020809104026020016040519081016040528092919081815260200182805461103c906118b3565b80156110875780601f1061105e57610100808354040283529160200191611087565b820191905f5260205f20905b81548152906001019060200180831161106a57829003601f168201915b5050506005909301549192505060ff1686565b600c81815481106110a9575f80fd5b5f91825260209091200154905081565b600980546110c6906118b3565b80601f01602080910402602001604051908101604052809291908181526020018280546110f2906118b3565b801561113d5780601f106111145761010080835404028352916020019161113d565b820191905f5260205f20905b81548152906001019060200180831161112057829003601f168201915b505050505081565b5f34116111865760405162461bcd60e51b815260206004820152600f60248201526e4d7573742073656e642076616c756560881b60448201526064016108bc565b3460035f8282546111979190611564565b9091555050335f90815260076020526040812080543492906111ba908490611564565b90915550506040805134815242602082015233917fd97bcdf12fa1d5342fc942da5eadf35c7597f34f8da7274c2b0d2ad979842679910160405180910390a2565b611203611434565b6001600160a01b03811661122c57604051631e4fbdf760e01b81525f60048201526024016108bc565b61097781611460565b5f818152600a60205260409020600481015460ff16156112885760405162461bcd60e51b815260206004820152600e60248201526d105b1c9958591e48199d5b99195960921b60448201526064016108bc565b806003015460035410156112d25760405162461bcd60e51b8152602060048201526011602482015270125b9cdd59999a58da595b9d081c1bdbdb607a1b60448201526064016108bc565b60048101805460ff1916600117905542600582015560038082015481549091905f906112ff908490612048565b90915550506006810180546001810182555f828152602090200180546001600160a01b03191633179055600382015460405184927f2203c9a905ca577b515bf59afc8d4fbe417c7c6af7419272964ea1defaaa889e9261095a929091600287019161205b565b5f73ad67fe66660fb8dfe9d6b1b4240d8650e30f60196001600160a01b031663159354a26040516020016113bc906020808252600f908201526e233231ab32b934b334b1b0ba34b7b760891b604082015260600190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b81526004016113f091815260200190565b602060405180830381865afa15801561140b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061142f91906120c3565b905090565b5f546001600160a01b03163314610a725760405163118cdaa760e01b81523360048201526024016108bc565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6002600154036114d257604051633ee5aeb560e01b815260040160405180910390fd5b6002600155565b828054828255905f5260205f2090810192821561152c579160200282015b8281111561152c57825182546001600160a01b0319166001600160a01b039091161782556020909201916001909101906114f7565b5061153892915061153c565b5090565b5b80821115611538575f815560010161153d565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561157757611577611550565b92915050565b5f8083601f84011261158d575f80fd5b50813567ffffffffffffffff8111156115a4575f80fd5b6020830191508360208285010111156115bb575f80fd5b9250929050565b5f805f805f606086880312156115d6575f80fd5b853567ffffffffffffffff808211156115ed575f80fd5b6115f989838a0161157d565b9097509550602088013594506040880135915080821115611618575f80fd5b506116258882890161157d565b969995985093965092949392505050565b5f60208284031215611646575f80fd5b5035919050565b6001600160a01b0381168114610977575f80fd5b803561166c8161164d565b919050565b5f60208284031215611681575f80fd5b81356108638161164d565b5f6040828403121561169c575f80fd5b50919050565b5f602082840312156116b2575f80fd5b813567ffffffffffffffff8111156116c8575f80fd5b6116d48482850161168c565b949350505050565b5f81518084525f5b81811015611700576020818501810151868301820152016116e4565b505f602082860101526020601f19601f83011685010191505092915050565b6001600160a01b03841681526060602082018190525f90611742908301856116dc565b9050826040830152949350505050565b5f805f8060608587031215611765575f80fd5b843567ffffffffffffffff8082111561177c575f80fd5b6117888883890161168c565b9550602087013591508082111561179d575f80fd5b506117aa8782880161157d565b9598909750949560400135949350505050565b60e081525f6117cf60e083018a6116dc565b6001600160a01b038916602084015282810360408401526117f081896116dc565b60608401979097525050921515608084015290151560a083015260c0909101529392505050565b60018060a01b038716815285602082015284604082015283606082015260c060808201525f61184960c08301856116dc565b905082151560a0830152979650505050505050565b602081525f61086360208301846116dc565b5f60208284031215611880575f80fd5b5051919050565b5f6001820161189857611898611550565b5060010190565b634e487b7160e01b5f52604160045260245ffd5b600181811c908216806118c757607f821691505b60208210810361169c57634e487b7160e01b5f52602260045260245ffd5b601f82111561192c57805f5260205f20601f840160051c8101602085101561190a5750805b601f840160051c820191505b81811015611929575f8155600101611916565b50505b505050565b815167ffffffffffffffff81111561194b5761194b61189f565b61195f8161195984546118b3565b846118e5565b602080601f831160018114611992575f841561197b5750858301515b5f19600386901b1c1916600185901b1785556119e9565b5f85815260208120601f198616915b828110156119c0578886015182559484019460019091019084016119a1565b50858210156119dd57878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b606081525f611a2c6060830187896119f1565b8560208401528281036040840152611a458185876119f1565b98975050505050505050565b5f808335601e19843603018112611a66575f80fd5b830160208101925035905067ffffffffffffffff811115611a85575f80fd5b8060051b36038213156115bb575f80fd5b8183525f6001600160fb1b03831115611aad575f80fd5b8260051b80836020870137939093016020019392505050565b803567ffffffffffffffff8116811461166c575f80fd5b5f8235609e19833603018112611af1575f80fd5b90910192915050565b8015158114610977575f80fd5b803561166c81611afa565b803563ffffffff8116811461166c575f80fd5b8183525f60208085019450825f5b85811015611b5c5763ffffffff611b4983611b12565b1687529582019590820190600101611b33565b509495945050505050565b5f823561011e19833603018112611af1575f80fd5b5f808335601e19843603018112611b91575f80fd5b830160208101925035905067ffffffffffffffff811115611bb0575f80fd5b8036038213156115bb575f80fd5b803560ff8116811461166c575f80fd5b5f8383855260208086019550808560051b830101845f5b87811015611ca357848303601f19018952611c008288611add565b60a063ffffffff611c1083611b12565b16855285820135611c208161164d565b6001600160a01b0316858701526040611c3b83820184611a51565b8383890152611c4d8489018284611a96565b93505050506060611c6081840184611b7c565b87840383890152611c728482846119f1565b93505050506080808301359250611c8883611afa565b91151594909101939093529783019790830190600101611be5565b5090979650505050505050565b5f610120611ccf84611cc185611ac6565b67ffffffffffffffff169052565b611cdb60208401611ac6565b67ffffffffffffffff166020850152611cf660408401611661565b6001600160a01b03166040850152611d1060608401611b07565b15156060850152611d2360808401611661565b6001600160a01b0316608085015260a08381013590850152611d4860c0840184611b7c565b8260c0870152611d5b83870182846119f1565b92505050611d6b60e08401611bbe565b60ff1660e0850152610100611d8284820185611a51565b86840383880152611d94848284611bce565b979650505050505050565b5f6020808352611daf8485611a51565b604083860152611dc3606086018284611a96565b9150508185013560be19863603018112611ddb575f80fd5b8581019050601f19858303016040860152803582528281013583830152611e0460408201611ac6565b67ffffffffffffffff808216604085015280611e2260608501611ac6565b1660608501525050611e376080820182611add565b60c06080840152803560c084015283810135935061ffff8416808514611e5b575f80fd5b60e084015260408101359350611e7084611afa565b921515610100830152606083013592611e8884611afa565b831515610120840152611e9e6080820182611a51565b9450905060a0610140840152611eb961016084018583611b25565b935050611ec960a0820182611b67565b905081830360a08301526107e18382611cb0565b5f60208284031215611eed575f80fd5b815161086381611afa565b5f8154611f04816118b3565b808552602060018381168015611f215760018114611f3b57611f66565b60ff1985168884015283151560051b880183019550611f66565b865f52825f205f5b85811015611f5e5781548a8201860152908301908401611f43565b890184019650505b505050505092915050565b828152604060208201525f6116d46040830184611ef8565b634e487b7160e01b5f52603260045260245ffd5b5f823560be19833603018112611fb1575f80fd5b9190910192915050565b5f8235609e19833603018112611fb1575f80fd5b5f82611fe957634e487b7160e01b5f52601260045260245ffd5b500490565b8385823760609290921b6bffffffffffffffffffffffff1916919092019081526014810191909152603401919050565b848152606060208201525f6120376060830185876119f1565b905082604083015295945050505050565b8181038181111561157757611577611550565b8381525f6020606060208401526120756060840186611ef8565b838103604085015284548082525f8681526020808220930191905b818110156120b55783546001600160a01b031683526001938401939285019201612090565b509098975050505050505050565b5f602082840312156120d3575f80fd5b81516108638161164d56fea26469706673582212204eecdb9a78f06df9da0271b72d16a680ec56594ec6c8b8900eea480aa8d292f764736f6c63430008190033","deployedBytecode":"0x60806040526004361061014a575f3560e01c80638193efaa116100b3578063ae438db11161006d578063ae438db114610489578063b2745564146104aa578063d37b2d14146104bf578063ecfb49a3146104de578063ed88c68e146104f3578063f2fde38b146104fb575f80fd5b80638193efaa146103a157806381d12c58146103c0578063846ed207146103f25780638da5cb5b146104235780639bf070b61461043f578063a1b45b581461045e575f80fd5b80634681fdd2116101045780634681fdd2146102d85780635d97b3cd146102f757806366fa7c46146103165780636a84a98514610355578063715018a61461036a578063748d511a1461037e575f80fd5b806311d7184d146101d157806313d4d9721461020d5780632d9e33c8146102315780632fbde6b31461025057806338d212421461028e578063401fb22b146102b9575f80fd5b366101cd573460035f8282546101609190611564565b9091555050335f9081526007602052604081208054349290610183908490611564565b90915550506040805134815242602082015233917fd97bcdf12fa1d5342fc942da5eadf35c7597f34f8da7274c2b0d2ad979842679910160405180910390a26101cb3361051a565b005b5f80fd5b3480156101dc575f80fd5b506008546101f0906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b348015610218575f80fd5b50610223620f424081565b604051908152602001610204565b34801561023c575f80fd5b5061022361024b3660046115c2565b610612565b34801561025b575f80fd5b5061027e61026a366004611636565b60056020525f908152604090205460ff1681565b6040519015158152602001610204565b348015610299575f80fd5b506102236102a8366004611671565b60076020525f908152604090205481565b3480156102c4575f80fd5b5061027e6102d33660046116a2565b6107eb565b3480156102e3575f80fd5b506101cb6102f2366004611636565b61086a565b348015610302575f80fd5b506101cb610311366004611636565b610966565b348015610321575f80fd5b50610335610330366004611671565b61097a565b604080519485526020850193909352918301526060820152608001610204565b348015610360575f80fd5b5061022360025481565b348015610375575f80fd5b506101cb610a61565b348015610389575f80fd5b50610392610a74565b6040516102049392919061171f565b3480156103ac575f80fd5b506101cb6103bb366004611752565b610b28565b3480156103cb575f80fd5b506103df6103da366004611636565b610e73565b60405161020497969594939291906117bd565b3480156103fd575f80fd5b5061041161040c366004611636565b610fd1565b60405161020496959493929190611817565b34801561042e575f80fd5b505f546001600160a01b03166101f0565b34801561044a575f80fd5b50610223610459366004611636565b61109a565b348015610469575f80fd5b50610223610478366004611671565b60066020525f908152604090205481565b348015610494575f80fd5b5061049d6110b9565b604051610204919061185e565b3480156104b5575f80fd5b5061022360045481565b3480156104ca575f80fd5b50600d546101f0906001600160a01b031681565b3480156104e9575f80fd5b5061022360035481565b6101cb611145565b348015610506575f80fd5b506101cb610515366004611671565b6111fb565b6001600160a01b0381165f9081526007602090815260408083205460069092528220546105479190611564565b9050678ac7230489e80000811061060e57600d5460405163128dbdb960e21b81526001600160a01b0384811660048301525f921690634a36f6e4906024016020604051808303815f875af11580156105a1573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105c59190611870565b60408051828152602081018590529192506001600160a01b038516917f3f1171297c35ca225263338ac9a229d96149e8c1eea55d597eaa85b135f8640a910160405180910390a2505b5050565b600280545f918291908261062583611887565b90915550604080516101206020601f8b01819004028201810190925261010081018981529293509182918a908a90819085018382808284375f920191909152505050908252503360208083019190915260408051601f880183900483028101830182528781529201919087908790819084018382808284375f9201829052509385525050506020808301899052604080840183905260608401839052608084018390528051838152808301825260a090940193909352848252600a905220815181906106f19082611931565b5060208201516001820180546001600160a01b0319166001600160a01b039092169190911790556040820151600282019061072c9082611931565b5060608201516003820155608082015160048201805460a085015115156101000261ff00199315159390931661ffff199091161791909117905560c0820151600582015560e0820151805161078b9160068401916020909101906114d9565b50905050807fe0b645c4fd45ece69cc31b0f8633c801e9e2b98a2b1a429efa597f1dace80f6088888888886040516107c7959493929190611a19565b60405180910390a284600354106107e1576107e181611235565b9695505050505050565b5f806107f5611365565b6040516358fbe9e160e01b81529091506001600160a01b038216906358fbe9e190610824908690600401611d9f565b602060405180830381865afa15801561083f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108639190611edd565b9392505050565b610872611434565b5f818152600a60205260409020600481015460ff166108c55760405162461bcd60e51b815260206004820152600a602482015269139bdd08199d5b99195960b21b60448201526064015b60405180910390fd5b6004810154610100900460ff161561090e5760405162461bcd60e51b815260206004820152600c60248201526b105b1c9958591e481c185a5960a21b60448201526064016108bc565b60048101805461ff001916610100179055600381015460405183917f1d6c1911dff15af6ed91890c881c1b34646051b66fd5a2bde246eb7c8ee0e7569161095a91906002860190611f71565b60405180910390a25050565b61096e611434565b61097781611235565b50565b6001600160a01b0381165f9081526006602090815260408083205460079092528220549091806109aa8385611564565b91505f90505f5b600254811015610a59575f818152600a602052604090206004015460ff1615610a51575f5b5f828152600a6020526040902060060154811015610a4f575f828152600a6020526040902060060180546001600160a01b038916919083908110610a1c57610a1c611f89565b5f918252602090912001546001600160a01b031603610a475782610a3f81611887565b935050610a4f565b6001016109d6565b505b6001016109b1565b509193509193565b610a69611434565b610a725f611460565b565b5f60605f60085f9054906101000a90046001600160a01b03166009620f4240818054610a9f906118b3565b80601f0160208091040260200160405190810160405280929190818152602001828054610acb906118b3565b8015610b165780601f10610aed57610100808354040283529160200191610b16565b820191905f5260205f20905b815481529060010190602001808311610af957829003601f168201915b50505050509150925092509250909192565b610b306114af565b5f610b3e6020860186611f9d565b610b4c906080810190611fbb565b355f8181526005602052604090205490915060ff1615610bae5760405162461bcd60e51b815260206004820152601d60248201527f5472616e73616374696f6e20616c72656164792070726f63657373656400000060448201526064016108bc565b610bb7856107eb565b610c035760405162461bcd60e51b815260206004820152601e60248201527f496e76616c6964205852504c207472616e73616374696f6e2070726f6f66000060448201526064016108bc565b5f818152600560205260408120805460ff19166001179055610c28620f424084611fcf565b9050670de0b6b3a7640000811015610c825760405162461bcd60e51b815260206004820152601860248201527f4d696e696d756d20646f6e6174696f6e206e6f74206d6574000000000000000060448201526064016108bc565b8260045f828254610c939190611564565b925050819055508060035f828254610cab9190611564565b9091555050335f9081526006602052604081208054859290610cce908490611564565b90915550506040515f90610cec908790879033904290602001611fee565b6040516020818303038152906040528051906020012090506040518060c00160405280336001600160a01b0316815260200183815260200185815260200142815260200187878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920182905250938552505060016020938401819052858352600b8452604092839020855181546001600160a01b0319166001600160a01b0390911617815593850151908401555082015160028201556060820151600382015560808201516004820190610dc89082611931565b5060a091909101516005909101805460ff1916911515919091179055600c80546001810182555f919091527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c70181905560405133907f1d58ae764d4ee47d6fb4cd691ccb1c215b66fd1a23940dd16cc230c2aea6181790610e509087908a908a90889061201e565b60405180910390a2610e613361051a565b505050610e6d60018055565b50505050565b600a6020525f9081526040902080548190610e8d906118b3565b80601f0160208091040260200160405190810160405280929190818152602001828054610eb9906118b3565b8015610f045780601f10610edb57610100808354040283529160200191610f04565b820191905f5260205f20905b815481529060010190602001808311610ee757829003601f168201915b505050600184015460028501805494956001600160a01b03909216949193509150610f2e906118b3565b80601f0160208091040260200160405190810160405280929190818152602001828054610f5a906118b3565b8015610fa55780601f10610f7c57610100808354040283529160200191610fa5565b820191905f5260205f20905b815481529060010190602001808311610f8857829003601f168201915b505050600384015460048501546005909501549394909360ff8083169450610100909204909116915087565b600b6020525f9081526040902080546001820154600283015460038401546004850180546001600160a01b0390951695939492939192611010906118b3565b80601f016020809104026020016040519081016040528092919081815260200182805461103c906118b3565b80156110875780601f1061105e57610100808354040283529160200191611087565b820191905f5260205f20905b81548152906001019060200180831161106a57829003601f168201915b5050506005909301549192505060ff1686565b600c81815481106110a9575f80fd5b5f91825260209091200154905081565b600980546110c6906118b3565b80601f01602080910402602001604051908101604052809291908181526020018280546110f2906118b3565b801561113d5780601f106111145761010080835404028352916020019161113d565b820191905f5260205f20905b81548152906001019060200180831161112057829003601f168201915b505050505081565b5f34116111865760405162461bcd60e51b815260206004820152600f60248201526e4d7573742073656e642076616c756560881b60448201526064016108bc565b3460035f8282546111979190611564565b9091555050335f90815260076020526040812080543492906111ba908490611564565b90915550506040805134815242602082015233917fd97bcdf12fa1d5342fc942da5eadf35c7597f34f8da7274c2b0d2ad979842679910160405180910390a2565b611203611434565b6001600160a01b03811661122c57604051631e4fbdf760e01b81525f60048201526024016108bc565b61097781611460565b5f818152600a60205260409020600481015460ff16156112885760405162461bcd60e51b815260206004820152600e60248201526d105b1c9958591e48199d5b99195960921b60448201526064016108bc565b806003015460035410156112d25760405162461bcd60e51b8152602060048201526011602482015270125b9cdd59999a58da595b9d081c1bdbdb607a1b60448201526064016108bc565b60048101805460ff1916600117905542600582015560038082015481549091905f906112ff908490612048565b90915550506006810180546001810182555f828152602090200180546001600160a01b03191633179055600382015460405184927f2203c9a905ca577b515bf59afc8d4fbe417c7c6af7419272964ea1defaaa889e9261095a929091600287019161205b565b5f73ad67fe66660fb8dfe9d6b1b4240d8650e30f60196001600160a01b031663159354a26040516020016113bc906020808252600f908201526e233231ab32b934b334b1b0ba34b7b760891b604082015260600190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b81526004016113f091815260200190565b602060405180830381865afa15801561140b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061142f91906120c3565b905090565b5f546001600160a01b03163314610a725760405163118cdaa760e01b81523360048201526024016108bc565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6002600154036114d257604051633ee5aeb560e01b815260040160405180910390fd5b6002600155565b828054828255905f5260205f2090810192821561152c579160200282015b8281111561152c57825182546001600160a01b0319166001600160a01b039091161782556020909201916001909101906114f7565b5061153892915061153c565b5090565b5b80821115611538575f815560010161153d565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561157757611577611550565b92915050565b5f8083601f84011261158d575f80fd5b50813567ffffffffffffffff8111156115a4575f80fd5b6020830191508360208285010111156115bb575f80fd5b9250929050565b5f805f805f606086880312156115d6575f80fd5b853567ffffffffffffffff808211156115ed575f80fd5b6115f989838a0161157d565b9097509550602088013594506040880135915080821115611618575f80fd5b506116258882890161157d565b969995985093965092949392505050565b5f60208284031215611646575f80fd5b5035919050565b6001600160a01b0381168114610977575f80fd5b803561166c8161164d565b919050565b5f60208284031215611681575f80fd5b81356108638161164d565b5f6040828403121561169c575f80fd5b50919050565b5f602082840312156116b2575f80fd5b813567ffffffffffffffff8111156116c8575f80fd5b6116d48482850161168c565b949350505050565b5f81518084525f5b81811015611700576020818501810151868301820152016116e4565b505f602082860101526020601f19601f83011685010191505092915050565b6001600160a01b03841681526060602082018190525f90611742908301856116dc565b9050826040830152949350505050565b5f805f8060608587031215611765575f80fd5b843567ffffffffffffffff8082111561177c575f80fd5b6117888883890161168c565b9550602087013591508082111561179d575f80fd5b506117aa8782880161157d565b9598909750949560400135949350505050565b60e081525f6117cf60e083018a6116dc565b6001600160a01b038916602084015282810360408401526117f081896116dc565b60608401979097525050921515608084015290151560a083015260c0909101529392505050565b60018060a01b038716815285602082015284604082015283606082015260c060808201525f61184960c08301856116dc565b905082151560a0830152979650505050505050565b602081525f61086360208301846116dc565b5f60208284031215611880575f80fd5b5051919050565b5f6001820161189857611898611550565b5060010190565b634e487b7160e01b5f52604160045260245ffd5b600181811c908216806118c757607f821691505b60208210810361169c57634e487b7160e01b5f52602260045260245ffd5b601f82111561192c57805f5260205f20601f840160051c8101602085101561190a5750805b601f840160051c820191505b81811015611929575f8155600101611916565b50505b505050565b815167ffffffffffffffff81111561194b5761194b61189f565b61195f8161195984546118b3565b846118e5565b602080601f831160018114611992575f841561197b5750858301515b5f19600386901b1c1916600185901b1785556119e9565b5f85815260208120601f198616915b828110156119c0578886015182559484019460019091019084016119a1565b50858210156119dd57878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b606081525f611a2c6060830187896119f1565b8560208401528281036040840152611a458185876119f1565b98975050505050505050565b5f808335601e19843603018112611a66575f80fd5b830160208101925035905067ffffffffffffffff811115611a85575f80fd5b8060051b36038213156115bb575f80fd5b8183525f6001600160fb1b03831115611aad575f80fd5b8260051b80836020870137939093016020019392505050565b803567ffffffffffffffff8116811461166c575f80fd5b5f8235609e19833603018112611af1575f80fd5b90910192915050565b8015158114610977575f80fd5b803561166c81611afa565b803563ffffffff8116811461166c575f80fd5b8183525f60208085019450825f5b85811015611b5c5763ffffffff611b4983611b12565b1687529582019590820190600101611b33565b509495945050505050565b5f823561011e19833603018112611af1575f80fd5b5f808335601e19843603018112611b91575f80fd5b830160208101925035905067ffffffffffffffff811115611bb0575f80fd5b8036038213156115bb575f80fd5b803560ff8116811461166c575f80fd5b5f8383855260208086019550808560051b830101845f5b87811015611ca357848303601f19018952611c008288611add565b60a063ffffffff611c1083611b12565b16855285820135611c208161164d565b6001600160a01b0316858701526040611c3b83820184611a51565b8383890152611c4d8489018284611a96565b93505050506060611c6081840184611b7c565b87840383890152611c728482846119f1565b93505050506080808301359250611c8883611afa565b91151594909101939093529783019790830190600101611be5565b5090979650505050505050565b5f610120611ccf84611cc185611ac6565b67ffffffffffffffff169052565b611cdb60208401611ac6565b67ffffffffffffffff166020850152611cf660408401611661565b6001600160a01b03166040850152611d1060608401611b07565b15156060850152611d2360808401611661565b6001600160a01b0316608085015260a08381013590850152611d4860c0840184611b7c565b8260c0870152611d5b83870182846119f1565b92505050611d6b60e08401611bbe565b60ff1660e0850152610100611d8284820185611a51565b86840383880152611d94848284611bce565b979650505050505050565b5f6020808352611daf8485611a51565b604083860152611dc3606086018284611a96565b9150508185013560be19863603018112611ddb575f80fd5b8581019050601f19858303016040860152803582528281013583830152611e0460408201611ac6565b67ffffffffffffffff808216604085015280611e2260608501611ac6565b1660608501525050611e376080820182611add565b60c06080840152803560c084015283810135935061ffff8416808514611e5b575f80fd5b60e084015260408101359350611e7084611afa565b921515610100830152606083013592611e8884611afa565b831515610120840152611e9e6080820182611a51565b9450905060a0610140840152611eb961016084018583611b25565b935050611ec960a0820182611b67565b905081830360a08301526107e18382611cb0565b5f60208284031215611eed575f80fd5b815161086381611afa565b5f8154611f04816118b3565b808552602060018381168015611f215760018114611f3b57611f66565b60ff1985168884015283151560051b880183019550611f66565b865f52825f205f5b85811015611f5e5781548a8201860152908301908401611f43565b890184019650505b505050505092915050565b828152604060208201525f6116d46040830184611ef8565b634e487b7160e01b5f52603260045260245ffd5b5f823560be19833603018112611fb1575f80fd5b9190910192915050565b5f8235609e19833603018112611fb1575f80fd5b5f82611fe957634e487b7160e01b5f52601260045260245ffd5b500490565b8385823760609290921b6bffffffffffffffffffffffff1916919092019081526014810191909152603401919050565b848152606060208201525f6120376060830185876119f1565b905082604083015295945050505050565b8181038181111561157757611577611550565b8381525f6020606060208401526120756060840186611ef8565b838103604085015284548082525f8681526020808220930191905b818110156120b55783546001600160a01b031683526001938401939285019201612090565b509098975050505050505050565b5f602082840312156120d3575f80fd5b81516108638161164d56fea26469706673582212204eecdb9a78f06df9da0271b72d16a680ec56594ec6c8b8900eea480aa8d292f764736f6c63430008190033","abi":[{"inputs":[{"internalType":"address","name":"initialOwner","type":"address"},{"internalType":"address","name":"_badgeNft","type":"address"},{"internalType":"address","name":"_xrplReceiver","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"donor","type":"address"},{"indexed":false,"internalType":"uint256","name":"badgeId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"totalContributions","type":"uint256"}],"name":"BadgeAwarded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"donor","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountWei","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"time","type":"uint256"}],"name":"DonationMade","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"requestId","type":"uint256"},{"indexed":false,"internalType":"string","name":"invoiceId","type":"string"},{"indexed":false,"internalType":"uint256","name":"amountWei","type":"uint256"},{"indexed":false,"internalType":"string","name":"hospitalXrpl","type":"string"}],"name":"RequestCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"requestId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountWei","type":"uint256"},{"indexed":false,"internalType":"string","name":"hospitalXrpl","type":"string"},{"indexed":false,"internalType":"address[]","name":"contributors","type":"address[]"}],"name":"RequestFunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"requestId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountWei","type":"uint256"},{"indexed":false,"internalType":"string","name":"hospitalXrpl","type":"string"}],"name":"RequestPaidOut","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"donor","type":"address"},{"indexed":false,"internalType":"uint256","name":"xrplAmount","type":"uint256"},{"indexed":false,"internalType":"string","name":"xrplTxHash","type":"string"},{"indexed":false,"internalType":"uint256","name":"flareAmount","type":"uint256"}],"name":"XrplDonationReceived","type":"event"},{"inputs":[],"name":"MIN_DONATION_AMOUNT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"badgeNft","outputs":[{"internalType":"contract BadgeNFT","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"invoiceId","type":"string"},{"internalType":"uint256","name":"amountWei","type":"uint256"},{"internalType":"string","name":"hospitalXrpl","type":"string"}],"name":"createRequest","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"crossChainDonations","outputs":[{"internalType":"address","name":"donor","type":"address"},{"internalType":"uint256","name":"amountWei","type":"uint256"},{"internalType":"uint256","name":"xrplAmount","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"string","name":"xrplTxHash","type":"string"},{"internalType":"bool","name":"processed","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"donate","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"donationHashes","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"donorFlareContributions","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"donorXrplContributions","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"requestId","type":"uint256"}],"name":"fundRequest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"donor","type":"address"}],"name":"getDonorImpact","outputs":[{"internalType":"uint256","name":"xrplContributions","type":"uint256"},{"internalType":"uint256","name":"flareContributions","type":"uint256"},{"internalType":"uint256","name":"totalContributions","type":"uint256"},{"internalType":"uint256","name":"requestsHelped","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getXrplPaymentDetails","outputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"string","name":"destinationTag","type":"string"},{"internalType":"uint256","name":"minAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"bytes32[]","name":"merkleProof","type":"bytes32[]"},{"components":[{"internalType":"bytes32","name":"attestationType","type":"bytes32"},{"internalType":"bytes32","name":"sourceId","type":"bytes32"},{"internalType":"uint64","name":"votingRound","type":"uint64"},{"internalType":"uint64","name":"lowestUsedTimestamp","type":"uint64"},{"components":[{"internalType":"bytes32","name":"transactionHash","type":"bytes32"},{"internalType":"uint16","name":"requiredConfirmations","type":"uint16"},{"internalType":"bool","name":"provideInput","type":"bool"},{"internalType":"bool","name":"listEvents","type":"bool"},{"internalType":"uint32[]","name":"logIndices","type":"uint32[]"}],"internalType":"struct IEVMTransaction.RequestBody","name":"requestBody","type":"tuple"},{"components":[{"internalType":"uint64","name":"blockNumber","type":"uint64"},{"internalType":"uint64","name":"timestamp","type":"uint64"},{"internalType":"address","name":"sourceAddress","type":"address"},{"internalType":"bool","name":"isDeployment","type":"bool"},{"internalType":"address","name":"receivingAddress","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"input","type":"bytes"},{"internalType":"uint8","name":"status","type":"uint8"},{"components":[{"internalType":"uint32","name":"logIndex","type":"uint32"},{"internalType":"address","name":"emitterAddress","type":"address"},{"internalType":"bytes32[]","name":"topics","type":"bytes32[]"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"bool","name":"removed","type":"bool"}],"internalType":"struct IEVMTransaction.Event[]","name":"events","type":"tuple[]"}],"internalType":"struct IEVMTransaction.ResponseBody","name":"responseBody","type":"tuple"}],"internalType":"struct IEVMTransaction.Response","name":"data","type":"tuple"}],"internalType":"struct IEVMTransaction.Proof","name":"transaction","type":"tuple"}],"name":"isXrplTransactionProofValid","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"requestId","type":"uint256"}],"name":"markPaidOut","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"nextRequestId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"bytes32[]","name":"merkleProof","type":"bytes32[]"},{"components":[{"internalType":"bytes32","name":"attestationType","type":"bytes32"},{"internalType":"bytes32","name":"sourceId","type":"bytes32"},{"internalType":"uint64","name":"votingRound","type":"uint64"},{"internalType":"uint64","name":"lowestUsedTimestamp","type":"uint64"},{"components":[{"internalType":"bytes32","name":"transactionHash","type":"bytes32"},{"internalType":"uint16","name":"requiredConfirmations","type":"uint16"},{"internalType":"bool","name":"provideInput","type":"bool"},{"internalType":"bool","name":"listEvents","type":"bool"},{"internalType":"uint32[]","name":"logIndices","type":"uint32[]"}],"internalType":"struct IEVMTransaction.RequestBody","name":"requestBody","type":"tuple"},{"components":[{"internalType":"uint64","name":"blockNumber","type":"uint64"},{"internalType":"uint64","name":"timestamp","type":"uint64"},{"internalType":"address","name":"sourceAddress","type":"address"},{"internalType":"bool","name":"isDeployment","type":"bool"},{"internalType":"address","name":"receivingAddress","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"input","type":"bytes"},{"internalType":"uint8","name":"status","type":"uint8"},{"components":[{"internalType":"uint32","name":"logIndex","type":"uint32"},{"internalType":"address","name":"emitterAddress","type":"address"},{"internalType":"bytes32[]","name":"topics","type":"bytes32[]"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"bool","name":"removed","type":"bool"}],"internalType":"struct IEVMTransaction.Event[]","name":"events","type":"tuple[]"}],"internalType":"struct IEVMTransaction.ResponseBody","name":"responseBody","type":"tuple"}],"internalType":"struct IEVMTransaction.Response","name":"data","type":"tuple"}],"internalType":"struct IEVMTransaction.Proof","name":"_transaction","type":"tuple"},{"internalType":"string","name":"xrplTxHash","type":"string"},{"internalType":"uint256","name":"xrplAmount","type":"uint256"}],"name":"processXrplPayment","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"processedXrplTransactions","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"requests","outputs":[{"internalType":"string","name":"invoiceId","type":"string"},{"internalType":"address","name":"creator","type":"address"},{"internalType":"string","name":"hospitalXrpl","type":"string"},{"internalType":"uint256","name":"amountWei","type":"uint256"},{"internalType":"bool","name":"funded","type":"bool"},{"internalType":"bool","name":"paidOut","type":"bool"},{"internalType":"uint256","name":"fundedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalPool","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalXrplDonations","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"xrplDestinationTag","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"xrplReceiverAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}]}